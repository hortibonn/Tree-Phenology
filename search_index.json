[["index.html", "Tree phenology analysis with R Chapter 1 Introduction 1.1 Objectives 1.2 Performance assessment 1.3 House rules", " Tree phenology analysis with R Eike Luedeling 2025-01-06 Chapter 1 Introduction Welcome to Tree Phenology Analysis with R! My name is Eike Luedeling, and I lead the HortiBonn research group within the Institute of Crop Science and Resource Conservation (INRES) at the University of Bonn. In this course/module/book, I will provide an overview of methods we can use to study the impact of climate - and climate change - on tree phenology. If you don’t know what phenology is and you have no idea how to analyze climate change impacts, you’ve come to the right place. If you already know a bit about these topics, I hope you’ll still be able to learn a few new things here. This course was developed for M.Sc. students in Crop Science and Agricultural Science and Resource Management in the Tropics and Subtropics (ARTS) at the University of Bonn, but you’re welcome to go through the materials even if you’re not a member of this illustrious circle. After some introduction of the subject matter, i.e. phenology (with special focus on dormancy) and climate change, much of this course will consist of practical application of the chillR package for R, which I have been developing since 2013 to facilitate this kind of analysis. Some people have started using this package. Here are some statistics on package downloads directly from CRAN, the main server that hosts R packages: 1.1 Objectives In this course, I aim to provide you with the following skills and experiences: Knowledge about phenology Knowledge about tree dormancy Understanding of climate change impact projection methods Appreciation for the importance of risks and uncertainty in climate change projection Understanding of how to use some staple tools of R code development Ability to use chillR functions for climate change impact projection Ability to use chillR functions for tree phenology analysis Understanding and ability to use the PhenoFlex dormancy analysis framework 1.2 Performance assessment In this module, there will be no exam, but you’ll still have to put in a bit of effort to pass and get a good grade here. Over the course of the semester, we’ll be developing a learning logbook. This will be an Rmarkdown document (here’s an example of what this is), where you’ll record your learning and your coding work. This document will contain short thematic chapters on the lecture contents, as well as the code you’ll produce and the outputs you’ll generate. The final chapters will contain some discussion of the results you’ll have obtained. This document will be evaluated, and it will be the major determinant of your final grade (participation in class will also count for some of the grade). To help you stay on track with the development of your logbook, we’ll occasionally take a look at your draft during the semester. 1.3 House rules In this course, we’ll gradually work our way into the chillR package. At the end of the semester, you should be able to do some state-of-the-art analyses in this space. Yet even if it’s not your ambition to become a phenology analyst, you’ll have picked up a bunch of useful skills along the way. I’ll try to teach you how to use some staple programming tools and techniques that can be used for all kinds of programming challenges. These will include the use of github and Rmarkdown, as well the the ability to create, manipulate and use R functions and packages. You’ll also gain familiarity with the challenges of modeling tree dormancy and making state-of-the-art climate change impact projections. For impacts that depend entirely on temperature, you’ll learn how to use tools that can produce projections that (as far as I’m aware) are robust enough to be acceptable by an academic journal - even one specialized on the study of climate change impacts. What is expected of you is to be engaged in this class, and to diligently complete the assignments you receive. Learning things in R requires practice, through which many things that seem cumbersome at first eventually become almost automatic. I’m absolutely convinced that the things you’ll get exposed to in this class can be great assets in your scientific (or other) career. So please take the materials seriously! "],["the-tools-we-use.html", "Chapter 2 The tools we use 2.1 R and RStudio 2.2 git and github 2.3 Rmarkdown", " Chapter 2 The tools we use This course not only aims to teach you things about tree phenology, climate change and related topics - it also provides hands-on exercises to illustrate the functions of the chillR package. You should also document everything you learn in a learning logbook. For all of these practical components, we need tools. chillR is an R package, so we’ll need R, which is most comfortably operated through the RStudio interface. We could simply start running RStudio on our local computer, save our files somewhere on our hard drive and generally operate the way we usually work with our computer. But this is not how real programmers work, and since this is what we’re trying to be, we should familiarize ourselves with some code development tools that such people use. We’ll therefore introduce you to git and github, which are very useful for keeping code organized and secure (and to share it with the world, if that’s what you want to do). Finally, we want to show you how to properly document what you do in R, and how to compile professional-looking reports of your work. This is what Rmarkdown helps us do. Some of this may be a bit confusing in the beginning, but you’ll probably learn to appreciate the value of these tools, as we keep using them in this module. Dr. Cory Whitney was volunteered to produce some nice tutorial videos to introduce you to all these tools. You’ll find these below. 2.1 R and RStudio The first video shows you how to install and run R and RStudio 2.2 git and github Now we look at the programming version control environment git and the interface github, which we use to access these features. 2.3 Rmarkdown Now let’s check out Rmarkdown, a powerful tool that allows making fancy reports, websites etc. out of our R code. You’re already looking at an example, by the way. This website was produced with Rmarkdown (and it wasn’t hard at all)! Now we’re equipped with all the basic tools for this course. We’ll start using them pretty soon. Below you’ll find occasional references to your learning logbook. This is supposed to be produced with Rmarkdown, with subsequent versions of it stored on github. "],["tree-dormancy.html", "Chapter 3 Tree dormancy 3.1 Learning goals for this lesson: 3.2 Introduction to dormancy 3.3 Dormancy physiology 3.4 Experimental and statistical determination of the chilling and forcing periods 3.5 Phenology record and BBCH scale Exercises on tree dormancy", " Chapter 3 Tree dormancy This chapter is brought to you by Dr. Erica Fadón, a researcher at HortiBonn from 2018-2021. Dormancy in temperate fruit trees is a fascinating topic of which we still have a lot to discover before having a full understanding of the process. The main question on the minds of dormancy researchers is “how do trees know when to flower?” Perhaps the answer seems easy… in spring!!! But there is much more behind this… This chapter will help you understand dormancy and also develop the necessary skills with chillR to predict when trees will flower, even under the changing circumstances caused by global warming. 3.1 Learning goals for this lesson: Learn about dormancy in temperate fruit trees Be able to identify the phenological stages of a fruit tree and understand phenology data sets Describe and compare the two methodologies (empirical and statistical) to identify the chilling and forcing periods of a certain cultivar 3.2 Introduction to dormancy First things first! In this introductory video, you will get the basic knowledge of dormancy. 3.3 Dormancy physiology Now I’ll give you a general overview of the most important physiological processes that occur during dormancy. Numerous approaches have tried to decipher the physiology of dormancy, but these efforts have usually remained relatively narrowly focused on particular regulatory or metabolic processes, recently integrated and linked by transcriptomic studies. We recently tried to synthesize existing knowledge on dormancy into a general conceptual framework to enhance dormancy comprehension. The proposed conceptual framework covers four physiological processes involved in dormancy progression: transport at both whole-plant and cellular level phytohormone dynamics genetic and epigenetic regulation dynamics of nonstructural carbohydrates We merged the regulatory levels into a seasonal framework integrating the environmental signals (i.e., temperature and photoperiod) that trigger each dormancy phase. Also check out our paper on the conceptual model of tree dormancy (Fadón et al., 2020) 3.4 Experimental and statistical determination of the chilling and forcing periods Dormancy presents two phases during which temperatures have opposite effects on flowering. High chill accumulation during endodormancy advances flowering dates, but similarly cool temperatures during ecodormancy may cause flowering delays. So how can we differentiate between these phases that occur while tree buds remain in the same developmental stage? 3.5 Phenology record and BBCH scale In this module, you will eventually work with phenology data sets. We’ll mostly focus on just one stage, usually budbreak, but trees go through many more developmental stages over the course of the year. These are usually referred to by a number code. The next video is about what these numbers indicate. It is important to know how to relate these stage numbers to images of trees full of flowers, trees with yellowish leaves, or trees with lots of sweet fruits ready to be eaten! Exercises on tree dormancy Please document all results of the following assignments in your learning logbook. Put yourself in the place of a breeder who wants to calculate the temperature requirements of a newly released cultivar. Which method will you use to calculate the chilling and forcing periods? Please justify your answer. Which are the advantages (2) of the BBCH scale compared with earlies scales? Classify the following phenological stages of sweet cherry according to the BBCH scale: Phenological stages of cherry References Fadón E, Fernandez E, Behn H &amp; Luedeling E. (2020). A conceptual framework for winter dormancy in deciduous trees. Agronomy, 10(2), 241. doi: 10.3390/agronomy10020241 "],["climate-change-and-impact-projection.html", "Chapter 4 Climate change and impact projection 4.1 The drivers of climate change 4.2 What we’ve already seen 4.3 Future scenarios 4.4 Impact projection approaches Exercises on climate change", " Chapter 4 Climate change and impact projection Before we get started with chillR, I want to give you an overview of climate change, because much of the work that follows will be focused on forecasting how phenology-related metrics will be impacted by global warming. 4.1 The drivers of climate change To fully appreciate what’s currently happening to our planet, we need some basic understanding of the drivers of climate change. This also helps prepare us for misleading claims that the sun, urban heat islands or similar peripheral factors are responsible for the alarming global warming we’re currently experiencing - or that this warming can be explained by the natural variation of our climate. Spoiler alert: it’s totally uncontroversial by now that anthropogenic emissions of greenhouse gases are warming our planet, and the only way to stop this from happening is a drastic reduction of man-made emissions. Here are the slides that belong to this video. 4.2 What we’ve already seen This video presents climatic changes that we’ve already experienced, or which we have very robust evidence for. Spoiler alert: the planet has been warming dramatically for several decades already, almost everywhere. Here are the slides that belong to this video. 4.3 Future scenarios When it comes to climate change, the worst is yet to come. This is because the rate of greenhouse gas emissions over the past few decades has been much greater than in the past, and it doesn’t look like these emissions will stop very soon. In consequence, the man-made ‘forcing’ effect on our climate has never been greater than now, which makes it likely that future changes will occur even more rapidly than what we’ve seen so far. This video introduces the methods that climate scientists use to gain a glimpse of the future. It also introduces climate scenarios produced by climate scientists, which can then be used by researchers from other disciplines to project climate change impacts on ecological or agricultural systems. Here are the slides that belong to this video. 4.4 Impact projection approaches Having good climate scenarios is important, but it only takes us part of the way towards reliable assessments of climate change impacts. A possibly greater challenge is the translation of climate scenarios into biological consequences. For this, we need impact models, or some other way to derive impacts from climate. This video provides an introduction to climate impact projection methods. Here are the slides that belong to this video. Exercises on climate change Please document all results of the following assignments in your learning logbook. List the main drivers of climate change at the decade to century scale, and briefly explain the mechanism through which the currently most important driver affects our climate. Explain briefly what is special about temperature dynamics of recent decades, and why we have good reasons to be concerned. What does the abbreviation ‘RCP’ stand for, how are RCPs defined, and what is their role in projecting future climates? Briefly describe the 4 climate impact projection methods described in the fourth video. "],["winter-chill-projections.html", "Chapter 5 Winter chill projections Learning goals for this lesson 5.1 Winter chill projections Exercises on past chill projections", " Chapter 5 Winter chill projections Learning goals for this lesson Be aware of past studies that have projected climate change impacts on winter chill Get a rough idea of how such studies are done Get curious about how to do such studies 5.1 Winter chill projections This lesson will give you an overview of how winter chill can be modeled. More precisely, it will be a little tour of the studies I’ve done on this in the past. I’ll lead you through these studies to help you understand how the methodological pieces of the puzzle fit together. If everything goes according to plan, you should be able to do most of the analyses that are behind these papers after completing this class. 5.1.1 Winter chill in Oman As a student at the University of Kassel, I had the chance to participate in research projects focusing on mountain oases in the Sultanate of Oman. I also worked on these systems for my PhD, where I first started to get interested in winter chill. This wasn’t the original study plan. We were going to calculate nutrient budgets for the oases, and this required measuring the yields of the various fruit trees there. Here’s an impression of the oasis orchards: The ‘Hanging Gardens’ of Ash Sharayjah, one of the oases of Al Jabal Al Akhdar This is where you can find these beautiful villages: Figure 5.1: Location of the oases of Al Jabal Al Akhdar in the Sultanate of Oman Unfortunately, many of the trees in the oasis system we worked in produced no fruits in the years we were there. One of my colleagues, Jens Gebauer (now Professor of Horticultural Sciences at Rhine-Waal University of Applied Sciences) suggested that this could have something to do with lack of chilling. This made sense, because most of the trees in these high-altitude oases were not the typical species of the Arabian Peninsula, but temperate trees, such as pomegranates (Punica granatum), walnuts (Juglans regia) or apricots (Prunus armeniaca), as you can see here: So, rather than focusing on the nutrient budgets, I started looking into this. I quickly came across the Chilling Hours model, which I assumed would be a suitable model to quantify chill. I later realized that this model can’t really be trusted, especially in such a warm location (we’re at almost 2000 m of elevation here, but it’s still pretty warm), but I didn’t know that then (many people still don’t seem to know this, even today). We had placed temperature loggers in three oases at different levels of elevation, which allowed studying chill accumulation along an elevation gradient. Here’s a map of the study area: Map of oasis systems in Al Jabal Al Akhdar, Oman The temperature loggers were installed in small sensor shelters, such as the one you see in the image below. Note that this is the one in Masayrat ar Ruwajah, the lowest oasis along the gradient. This is why in this picture, we see the heat-loving date palm (Phoenix dactylifera), rather than temperate trees. Temperature logger in Masayrat ar Ruwajah, Al Jabal Al Akhdar, Oman If you want to do a climate change analysis, you can’t really just put up a temperature sensor and hope to collect meaningful data in a reasonable period of time. Fortunately for us, an official long-term weather station is located in the vicinity, near the top of the valley. However, this station is roughly 1000 m above the lowest oasis, and it is clear that its readings aren’t representative of all locations along the elevation gradient. Since we had records from the oases, however, we were able to define transfer functions that allowed deriving oasis temperatures from the long-term data. We set these transfer functions up (using PLS regression, which in hindsight wasn’t a very good idea) to directly calculate hourly temperatures in the oases from the daily records of the official station at Saiq. Regression between temperature at Saiq and temperature in three oases, Al Jabal Al Akhdar, Oman Hourly data were needed to calculate the number of Chilling Hours, so this procedure allowed us to calculate winter chill dynamics over the entire time span covered by the official weather station: Chill dynamics between 1983 and 2007, Al Jabal Al Akhdar, Oman (- indicates years with insufficient data coverage) We submitted a manuscript on this analysis to the journal Climatic Change (where I now have the honor of serving as a Deputy Editor). The reviewers there generally liked the study, but they requested that we add future climate scenarios. This is when I first came across a weather generator. Weather generators are tools that can produce random draws of plausible weather, based on observed weather for a particular location. So we fed such a weather generator (in this case the LARS-WG weather generator maintained by Mikhail Semenov) with the data we had for the highest-elevation oasis and told it to generate plausible weather for a number of years for us. We also requested the generator to produce comparable records for possible future scenarios, where temperatures were 1 and 2°C higher than during the historic period. We used our transfer functions on these datasets, and got the following results: Chill prospects for 1°C and 2°C warming scenarios in Al Jabal Al Akhdar, Oman This study, which was ultimately accepted by Climatic Change (Luedeling et al., 2009b) (Link), was the beginning of my chill modeling career. Turns our there was still a lot to learn… 5.1.2 Chill model sensitivity After finishing my PhD in Kassel, I moved to the University of California at Davis to work as a Postdoctoral Scholar (I had already done an MSc in International Agricultural Development there, and I wrote a grant proposal with Prof. Minghua Zhang, whose lab I had been working in then). The new project was on projecting climate change impacts on winter chill in the Central Valley, one of the world’s most productive regions for temperate fruit trees. The first thing I noticed is that the choice of chill model matters - a lot! I had noticed that there are different models to quantify winter chill, but - like many modelers - I decided to go with the one that seemed easiest to handle. This may have been unavoidable at the time, because I had zero programming skills, but this is really not how we should choose models! We’ll see a bit more evidence of what errors can result from this later. After I arrived in California, one of the first things I did was disappear into the library for quite some time to read everything I could find on winter chill. What I found made it pretty clear that model choice was worth looking into. So I used the methodological knowledge I had gained in Oman, created a bunch of temperature scenarios for multiple locations and calculated how chill accumulation was likely to change in the future, according to multiple chill models. I looked at what changes the various models predicted for the same locations and the same future scenarios. Here are the locations I looked at: Weather station locations in California Note that ‘Hollister’, a word many people like to display on their clothes in this age we have the privilege of living in, is actually a place in California where people grow walnuts. Interestingly, the chill projection results varied considerably across the four models I looked at: Sensitivity of chill projections to model choice (CH - Chilling Hours; Utah - Utah Model; Utah+ - Positive Utah Model; Port. - Dynamic Model) In this figure, the past distribution of winter chill is shown on the left, and estimates for 2000 on the second panel. The remaining three panels show three scenarios for 2050. All data are normalized by the median of the 1950 distribution. You can see that especially by 2050, the models differ strongly in the extent of chill losses they project. Since all models are trying to describe the same thing, this is a strong indication that not all models can be right! This study appeared in Agriculture, Ecosystems and Environment (Luedeling et al., 2009e) (Link). I got some welcome help from my brother, who was able to program a little tool to implement the Dynamic Model. Based on the literature, as well as on another study (Luedeling et al., 2009f) (Link) that I don’t want to go into here, I concluded that the Dynamic Model was the most reliable one. So this is the model that will be used for the most part in this course. By the time I did this study, I began to realize that I was running into a few major problems: The model that appeared most reliable - the Dynamic Model - was complicated, and I could only calculate Chill Portions (the unit of this model) with a decades-old Excel sheet (Erez &amp; Fishman, 1997). This wasn’t satisfying. Going through the various data processing steps that were needed to produce credible temperature scenarios was cumbersome and error-prone - and boring. I was going to have to learn programming… 5.1.3 Winter chill in California The main objective of my stay in California was to produce a winter chill projection for California’s fruit and nut growing region - the Central Valley. Here’s an impression of what some orchards there look like: California has a fairly dense network of weather stations, and I wanted to use records from all of them. And for all of these 100+ stations, I wanted multiple climate scenarios (20 or so). This was going to take a long time! The only way to deal with this was to automate most of the process, which made me look into programming. For some reasons that now seem like a major mistake, I decided to automate many steps in JSL, the programming language of a statistics program called JMP. While this wasn’t a very smart choice, it mostly worked, and I managed to automate most steps. The only step I still had to do manually was run the weather generator (20+ times for each of 100+ weather stations, so this was still pretty annoying…). In the end, I managed to produce projections for all stations, which consisted of chill accumulation over 100 plausible winter seasons per scenario, generated with a weather generator. To condense these results into a format that could be shown in a map, I summarized the data by defining a metric called ‘Safe Winter Chill’. This is the 10th percentile of the chill distribution, i.e. the amount of chill that is exceeded in 90% of all years. Economically, it may be feasible to grow a tree cultivar that requires this much chill. Here’s an illustration of the Safe Winter Chill metric: Illustration of the Safe Winter Chill concept I also figured out a way to spatially interpolate the station results. We’ll get to this later, but here’s one of the maps that resulted from this: Winter chill prospects for California’s Central Valley This analysis appeared in the journal PLOS ONE (Luedeling et al., 2009d) (Link) . 5.1.4 Winter chill ratios Having figured out how to automate processing steps (in that JSL language), I could move on to greater numbers of stations. The goal was to produce a chill projection for the whole planet. I identified a good data source for setting this up in the Global Summary of the Day database (we’ll get back to this later). This had useful data for several thousand weather stations (and thousands more of not-so-useful stations, which had to be identified and filtered out). Especially with my fairly poor programming skills, this was a huge endeavor. At some point, the data were being processed on 6 computers, which were running day and night for several weeks. Quite likely, this was not because the analyses were so complex, but because I set things up poorly… Anyway, eventually I managed to process data for about 5000 globally distributed weather stations, for which I calculated multiple chill metrics. This provided an opportunity to compare chill models again. So I calculated, for each weather station in my dataset, the ratio between various chill metrics. Had these ratios been largely constant all over the planet (e.g. one Chill Portion always corresponds to 10 Chilling Hours), we would have been faily safe using any of the chill models. Unfortunately, this wasn’t the case, with enormous variation in chill metric ratios around the world. Chill metric ratios around the world This study got published in the International Journal of Biometeorology (Luedeling &amp; Brown, 2011a) (Link). 5.1.5 A global projection of future winter chill Based on the same analysis procedures, we were also able to produce a global projection of the likely impacts of climate change on winter chill: Projected decline in available winter chill around the world This study was published in PLOS ONE (Luedeling et al., 2011b) (Link). Especially in the areas shown in red and orange in the lower two maps, fruit and nut production may be quite heavily impacted by declining winter chill. With such dramatic chill losses, it seems unlikely that growers will remain able to grow the tree cultivars they currently rely on. In terms of world regions, the Mediterranean region may be hit particularly hard. Winter chill projection for the Mediterranean region This is one of the reasons why we started working with partners in this region, as well as other countries with similar climatic settings (e.g. South Africa, Chile). 5.1.6 Winter chill in Germany Germany is not highlighed as particularly vulnerable to chill losses. Analyzing historic chilling trends between 1950, we were able to confirm this impression (Luedeling et al., 2009a) (Link). Winter chill in Germany in 2010, and changes between 1950 and 2010 The reason for this lack of major changes is that current winter temperatures in Germany are right in the middle of what appears to be the most effective temperature range for chill accumulation. A little warmer or a little colder therefore doesn’t make much of a difference. 5.1.7 Winter chill in Tunisia Prospects are quite different for orchards in Tunisia. Here we’re close to the warmest margin of the production range for many fruit and nut tree species. We published an assessment of past and future trends in winter chill for an orchard in Central Tunisia in 2018, about 7 years after all the other projection studies shown above. This long break was partly because my day job at the time involved agroforestry, decision analysis (you can learn about this in our summer term module Decision Analysis and Forecasting in Agriculture) and a few other things, but not winter chill. More importantly, however, it took me quite a while to overcome a major challenge of climate change analysis - where to find appropriate information on future climates. Difficulties in finding future climate data may seem surprising, given the ubiquity of climate change research. In fact, finding data is not difficult, but data that can easily be used for the purposes of chill modeling (of the kind I like doing) still wasn’t readily available. For some reason, most future climate projections were mostly disseminated as spatial grids covering various extents. Some datasets were only within my reach as raster files covering the whole planet. At even a moderate spatial resolution of 2.5 arcminutes, each of these grids had a size of about 170 MB. This may not sound like much, but consider that for each climate scenario, we need 12 grids, for the mean daily minimum temperature of each month, and another 12 for the maximum temperature (for some weather generators, we need another 12 for rainfall). Consider further that for state-of-the-art climate change scenarios, we should investigate multiple future climate ‘pathways’. In my earlier studies, we used the so-called SRES emissions scenarios (named after the IPCC Special Report on Emissions Scenarios), usually focusing on the three most commonly used scenarios B2, A1B and A2. So now we’re already at 72 grids (assuming we don’t need rainfall). Since we still have incomplete understanding on how the global climate system works, many research groups have developed so-called ‘General Circulation Models’ (GCMs; many people also use an alternative long form: ‘Global Climate Models’), all of which differ slightly in their projections. We currently have no way of deciding which of these models, if any, is right, so the climate science community decided that we should produce ensemble forecasts, i.e. project changes using outputs from all the available models (that are considered credible). The dataset I typically worked with included 20 GCMs. To make matters worse, I typically wanted to project gradual changes over time by including multiple years in an analysis, e.g. the 2020s, the 2050s and the 2080s. You can probably see where this is headed. When we multiply all these numbers, we realize that we need 4320 grids. The disk space required to store these data (in uncompressed form) is more than 700 GB. This is not impossible to find, but processing this amount of data is cumbersome and time-consuming. Still, I actually managed to set up a data processing structure for this and download all the data to an external hard drive. Soon after I had set up this structure, the IPCC came up with a new report that introduced the ‘Representative Concentration Pathways’ (RCPs) to replace the SRES scenarios. For a few years, it was still ok to work with the old scenarios, but eventually it got harder and harder to get such studies through the peer-review process. The scenarios simply weren’t up to date any more. However, I was not excited by the prospect of downloading another massive dataset and starting all over again… What made this particularly difficult for me was that I was based in Kenya then, with fairly poor data transfer rates. It was only until I started working with colleagues in Tunisia, specifically with Haifa Benmoussa, who was doing her PhD at the University of Tunis, but collaborated intensively with me on most of her dissertation chapters. In some of these chapters, we discovered that tree crops grown in Central Tunisia, specifically almonds (Benmoussa et al., 2017a) (Link) and pistachios (Benmoussa et al., 2017b) (Link) were highly vulnerable to the impacts of climate change. In order to forecast the future prospects for pistachios and almonds in Tunisia, we needed climate scenarios. It turned out that in the meantime, some climate scientists had produced a future climate database specifically for Africa - AFRICLIM (Platts et al., 2015), which contained exactly what we needed. Since this database didn’t include the whole planet, it was much easier to download and store, and processing the data was much less cumbersome. So I added functions to chillR to implement procedures to sample from the AFRICLIM grids and produce ensembles of climate scenarios. I also started putting together a framework to automatically produce the kind of plots that are shown below. Here’s the plot we produced for this paper (Benmoussa et al., 2018) (Link): Winter chill analysis for an orchard near Sfax in Central Tunisia. The blue bars indicate approximate chilling requirements of pistachios and two types of almonds If all goes well, you’ll be able to produce such a figure by the end of the semester. This figure contains a number of interesting features that you’ll learn about in this module. The plots on the left indicate the historic development of chill accumulation at this location. In this, the actually observed values are indicated by red dots. In addition to these dots, the plots also contain boxplots that describe the typical chill distribution at a particular point in time. These were generated with a weather generator that is accessed by chillR. This weather generator is calibrated with observed weather data and provided with an estimate of how various climate metrics differed from the long-term average climate in 1975, 2000 and 2015. With this information, we can generate a large number of artificial yearly weather records that might have occurred at these points in time. The weather generator was also used to produce future scenarios. Also here, the tool was calibrated with observed weather data, but the scenarios that were added were not derived from the historic record, but extracted from the AFRICLIM database. Now let’s look at what this figure shows, because that it quite alarming. Usually, in a climate change projection, we would now start comparing forecasts for different scenarios, which are often not entirely consistent. Here, we don’t have such a problem. It seems very clear that there is not a single future scenario in this analysis, where cultivation of pistachios or high-chill almonds remains viable! This conclusion is based on the assumption that our understanding of how to quantify winter chill isn’t totally wrong. It is supported by recent observations in Tunisia, where, after the particularly warm winter of 2015/16, many pistachio trees barely developed any flowers, which resulted in virtually complete crop failure: Pistachio tree near Sfax, Central Tunisia, in April of 2016, after a particularly warm winter. This tree clearly didn’t fulfill its chilling requirement 5.1.8 Winter chill in Chile AFRICLIM solved the future climate data problem for locations in Africa. However, this dataset fell short of what was needed in order to add climate change projection capability to chillR. First, it was unsatisfying that this dataset only covered Africa. Second, users who are only interested in data for a single location, which is what chillR is designed for, shouldn’t have to download a large dataset, before they can run analyses. What was needed was a tool that could quickly access single-location data for weather stations anywhere on the planet. One of my early sources of climate information was a tool called ‘ClimateWizard’, put together by my friend and collaborator Evan Girvetz, who now works for the International Centre for Tropical Agriculture (CIAT) in Nairobi. This tool initially only made gridded data available, but already for the California study cited above (Luedeling et al., 2009d) (Link), Evan had written a script to quickly extract information for single locations, which is really all that’s needed for single-site studies. Eventually, at CIAT, he made this function available to a wider audience through an application programming interface (API), to allow accessing outputs from 15 climate models for state-of-the-art RCP scenarios. This tool allowed us, in this case led by Eduardo Fernández, to expand our geographic reach into South America. Focusing on nine locations throughout Chile, Eduardo analyzed past and future chill development across a wide climatic gradient (Fernandez et al., 2020a) (Link). Map of fruit growing locations in Chile, for which chill accumulation was assessed Assessment of past and future winter chill for 9 locations across Chile Apparently, Eduardo didn’t like my plot design, so he redesigned it using the ggplot2 package, a powerful plotting package for R. One of the things that we can see here is that with data for many sites, things get a bit too complex to easily grasp. So Eduardo thought of a creative way to extract some key information for each scenario and display it as a heat map: Heatmap showing Safe Winter Chill (10% quantile of chill distribution) for nine locations in Chile We see here clearly the north-south gradient in available chill, as well as (less clearly) the tendency for lower chill towards the right panels, especially towards the lower right corner. 5.1.9 Chill projection for Patagonia Some locations on our planet may become more hospitable for agriculture, as the climate changes. We used our analysis framework to look into the climatic suitability for fruit and nut trees near agriculture’s southern frontier - in Patagonia, in southern Argentina (del Barrio et al., 2020) (Link). Map of parts of Patagonia in Argentina, showing locations that were analyzed in this study We got weather station records for all the locations shown in the map, used them to calibrate our weather generator and downloaded climate projections from the ClimateWizard database. This then allowed making past and future temperature scenarios for all stations and to compute winter chill and a few other agroclimatic metrics. Results of the winter chill calculation were not so interesting here, with very little change projected. Heatmap showing Safe Winter Chill (10% quantile of chill distribution) for eleven locations in Patagonia In fact, climate change may have a positive effect on land suitability for fruit trees, because more summer heat will be available: Past and projected future heat availability for four exemplary locations in Patagonia A further beneficial development is a likely reduction in the number of frost hours: Past and projected frost risk for four exemplary locations in Patagonia This may all not look very spectacular, but it seems quite likely to me that the small changes we’re seeing will promote many locations from a climate that is really too cool for agriculture, especially for fruit trees, to a fairly optimal situation. For a change, some possibly good news related to climate change (though also this will likely come with negative implications for natural ecosystems and possibly other agricultural systems). 5.1.10 Chill model comparison Eduardo Fernandez recently used our climate change analysis framework to compare chill models (Fernandez et al., 2020b) (Link), greatly expanding on my earlier chill model comparisons (Luedeling et al., 2011a) (Link). He assembled a collection of 13 approaches to quantify chill accumulation from the literature and applied the models he found to datasets from a number of locations in Germany, Tunisia and Chile (the countries involved in our PASIT project). Here’s a map of the locations: Locations used for comparing predictions by a total of 13 chill models across different climates The expectation was that the models would differ strongly in the extent of changes they predicted. This expectation was not disappointed: Chill change projections by a total of 13 chill models across different climate scenarios This figure shows the changes predicted by the 13 models (y-axes) across various sites and climate scenarios. Note that Eduardo already did a lot of data compression here, categorizing the various climate models into three categories (warm, moderate and cool), and summarizing across all models in each of the classes. What we see here should be pretty disturbing for everyone who (like me, a decade before) simply chooses the most convenient model for predicting something. This analysis reveals massive differences across the models! This can easily be seen by comparing the color distribution across the rows in each of the panels. A set of equivalent models would have produced the same shade of red or blue for each column of the plots in this figure. The result we obtained is far from that, showing huge differences in model predictions. For locations in Tunisia and Chile, this variation mainly concerns the extent of chill losses, with predictions ranging from rather mild to alarming. For locations in Germany, not even the direction of change is clear, with some models predicting increases, others decreases in available chill. These results clearly indicate that model choice matters! Fortunately, many of these models seem rather arbitrary and can easily be dismissed. Yet there surely is residual uncertainty about which of these models, if any, makes the right calls. This is an active field of research that creative minds can/will make meaningful contributions to in the future. 5.1.11 Chill projection for all of Tunisia As mentioned above, we projected climate change impacts on winter chill for an orchard near Sfax in Central Tunisia (Benmoussa et al., 2018) (Link). This is, however, not the most interesting region in the country for growing temperate fruit and nut trees. Despite its rather modest size, Tunisia is a climatically diverse country, with mountains and plains, coastal areas and interior deserts. Historic and future chill availability therefore shows considerable variation within the country. Led by Haifa Benmoussa, we mapped chill accumulation across Tunisia, based on the framework we’ve already encountered (Benmoussa et al., 2020) (Link) This analysis was based on 20 weather station locations across Tunisia and neighboring countries. By now, you probably have a pretty good idea of how we did this analysis - we just applied the analysis framework we developed to each of the 20 locations. In addition to the site-specific analysis we had produced earlier, we were now able to interpolate our results to produce chill maps that track chill availability in Tunisia over the past few decades: Chill availability maps for Tunisia for several past scenarios You may wonder here how we managed to interpolate the site-specific results into a map that covers the whole country. Well, this is an area that we may still make some improvements in. The current procedure, which is probably not perfect yet, is that we take the site-specific predictions of Safe Winter Chill (remember that’s the 10th percentile of the chill distribution derived from the ‘replicates’ of annual temperature dynamics produced by the weather generator), and interpolate a surface through them (using the Kriging technique). We did the same for the elevations of the locations we modeled chill for. We then fitted a linear model to relate chill accumulation to elevation. Making use of a Digital Elevation Model (DEM), we were able to calculate the difference between the elevation model derived from the weather station elevations and the true elevations of each location of the country. Considering that this difference is not yet accounted for by the chill surface that was derived by interpolating chill data for the weather stations, we used the elevation~chill relationship we determined to correct chill predictions. Was this confusing? Well, there’s room for improvement here, and it’s pretty clear that the procedure I just described will only work in places with a linear relationship between elevation and chill availability. This seems a fairly reasonable assumption in Tunisia, but it would not work in many cooler locations, such as Germany. Here’s the projection of future chill we produced for Tunisia: Chill availability for Tunisia for various plausible scenarios of future climate What we see here is pretty concerning. The Dynamic Model, which we used to predict chill here, is considered rather credible, and we’re seeing massive decreases in Chill Portions, the units the Dynamic Model uses. This is bad news for most of Tunisia! Note that even in the places where we expect substantial winter chill to remain, farmers will likely have to adapt, because the trees they grow are aligned with the climate of the past. Adaptation strategies may involve transitioning to tree cultivars with low chilling requirements (if such cultivars are available). 5.1.12 Revisiting chill accumulation in Oman After a decade of foraging in other parts of the world, let’s come back to Oman. I’d long been a bit dissatisfied with the initial work we did there. Note that the first analysis was my first study on chill accumulation. At the time, I did not know about the hazards involved in model choice. I also didn’t have proper data on projected future climates then, and the process that converted daily to hourly temperatures was quite a bit less than ideal. My PhD supervisor and mentor Prof. Dr. Andreas Bürkert had pushed me for quite some time to redo the analysis for Oman. With our climate change analysis framework, we could finally do it. Adding some new ideas on how to convert daily into hourly temperatures in a place like the oases of Oman we were interested in (you’ll learn about these ideas later in this module), we produced updated assessments of past winter chill and forecasts of future chill for the oases of Al Jabal Al Akhdar. The results appeared once again in Climatic Change (Buerkert et al., 2020) (Link). 5.1.13 Future studies? Now we’ve reached the present. By now you should have a pretty good overview of the state of the art in chill modeling (or the modeling of climate change impacts on any temperature-related phenomenon). By the end of this module, you should be able to do such analyses yourself. The next steps will be up to you! Exercises on past chill projections Please document all results of the following assignments in your learning logbook. Sketch out three data access and processing challenges that had to be overcome in order to produce chill projections with state-of-the-art methodology. Outline, in your understanding, the basic steps that are necessary to make such projections. References Benmoussa H, Ghrab M, Mimoun MB &amp; Luedeling E. (2017a). Chilling and heat requirements for local and foreign almond (prunus dulcis mill.) cultivars in a warm mediterranean location based on 30 years of phenology records. Agricultural and Forest Meteorology, 239, 34–46. doi: 10.1016/j.agrformet.2017.02.030 Benmoussa H, Luedeling E, Ghrab M, Ben Yahmed J &amp; Ben Mimoun M. (2017b). Performance of pistachio (Pistacia vera L.) in warming Mediterranean orchards. Environmental and Experimental Botany, 140, 76–85. doi: 10.1016/j.envexpbot.2017.05.007 Benmoussa H, Luedeling E, Ghrab M &amp; Mimoun MB. (2020). Severe winter chill decline impacts tunisian fruit and nut orchards. Climatic Change, 162, 1249–1267. doi: 10.1007/s10584-020-02774-7 Benmoussa H, Mimoun MB, Ghrab M &amp; Luedeling E. (2018). Climate change threatens central tunisian nut orchards. International Journal of Biometeorology, 62(12), 2245–2255. doi: 10.1007/s00484-018-1628-x Buerkert A, Fernandez E, Tietjen B &amp; Luedeling E. (2020). Revisiting climate change effects on winter chill in mountain oases of northern oman. Climatic Change, 162, 1399–1417. doi: 10.1007/s10584-020-02862-8 del Barrio R, Fernandez E, Brendel AS, Whitney C, Campoy JA &amp; Luedeling E. (2020). Climate change impacts on agriculture’s southern frontier–perspectives for farming in north patagonia. International Journal of Climatology, 41(1), 726–742. doi: doi.org/10.1002/joc.6649 Erez A &amp; Fishman S. (1997). Dynamic model chilling portions (excel worksheet). Retrieved from http://ucanr.edu/sites/fruittree/files/49319.xls Fernandez E, Whitney C, Cuneo IF &amp; Luedeling E. (2020a). Prospects of decreasing winter chill for deciduous fruit production in chile throughout the 21st century. Climatic Change, 423–439. doi: 10.1007/s10584-019-02608-1 Fernandez E, Whitney C &amp; Luedeling E. (2020b). The importance of chill model selection—a multi-site analysis. European Journal of Agronomy, 119, 126103. doi: 10.1016/j.eja.2020.126103 Luedeling E, Blanke M &amp; Gebauer J. (2009a). Auswirkungen des Klimawandels auf die Verfügbarkeit von Kältewirkung (Chilling) für Obstgehölze in Deutschland. Erwerbs-Obstbau, 51(3), 81–94. doi: 10.1007/s10341-009-0085-4 Luedeling E &amp; Brown PH. (2011a). A global analysis of the comparability of winter chill models for fruit and nut trees. International Journal of Biometeorology, 55(3), 411–421. doi: 10.1007/s00484-010-0352-y Luedeling E, Gebauer J &amp; Buerkert A. (2009b). Climate change effects on winter chill for tree crops with chilling requirements on the Arabian Peninsula. Climatic Change, 96(1-2), 219–237. doi: 10.1007/s10584-009-9581-7 Luedeling E, Girvetz EH, Semenov MA &amp; Brown PH. (2011b). Climate change affects winter chill for temperate fruit and nut trees. PloS One, 6(5), e20155. Retrieved from https://journals.plos.org/plosone/article?id=10.1371/journal.pone.0020155 Luedeling E, Zhang M &amp; Girvetz EH. (2009d). Climatic Changes Lead to Declining Winter Chill for Fruit and Nut Trees in California during 1950–2099. PLoS ONE, 4(7), e6166. doi: 10.1371/journal.pone.0006166 Luedeling E, Zhang M, Luedeling V &amp; Girvetz EH. (2009e). Sensitivity of winter chill models for fruit and nut trees to climatic changes expected in California’s Central Valley. Agriculture, Ecosystems &amp; Environment, 133(1-2), 23–31. doi: 10.1016/j.agee.2009.04.016 Luedeling E, Zhang M, McGranahan G &amp; Leslie C. (2009f). Validation of winter chill models using historic records of walnut phenology. Agricultural and Forest Meteorology, 149(11), 1854–1864. doi: 10.1016/j.agrformet.2009.06.013 Platts PJ, Omeny P &amp; Marchant R. (2015). AFRICLIM: High-resolution climate projections for ecological applications in africa. African Journal of Ecology, 103–108. doi: 10.1111/aje.12180 "],["manual-chill-analysis.html", "Chapter 6 Manual chill analysis Learning goals for this lesson 6.1 Computing Chilling Hours from hourly temperature data 6.2 Our first chill function Exercises on basic chill modeling", " Chapter 6 Manual chill analysis Learning goals for this lesson Learn about some basic R operations we need for calculating Chilling Hours Be able to calculate Chilling Hours Understand what an R function is Be able to write your own basic function 6.1 Computing Chilling Hours from hourly temperature data Basic chill models like the Chilling Hours Model aren’t particularly complicated, so it’s not so hard to calculate chill manually (at least not if you’re familiar with R, or even a spreadsheet program). So we’re going to try this here to gain some understanding of what the respective functions in the chillR package do. One important challenge that most people who want to compute Chilling Hours quickly realize is that we need hourly temperature data. Quite often, such data aren’t available, and that’s already where the problems start. For now, we’re going to ignore this problem and work with data that already has an hourly time step. A bit later, we’ll talk about ways to make pretty good approximations of hourly temperature data from daily records, for which chillR offers a few neat tools. Let me first say that I always have to swallow a toad when I use Chilling Hours, because I don’t think they are very useful. They are, however, the chill model that is most widely known, they are very easy to explain, and they are not hard to calculate. Since at this point we’re absolute beginners in chill modeling, let’s start there. First, we have to get data into R. The most obvious way to achieve this is reading a data table into R with the read.table or read.csv functions. There are also packages that can read in .xls or .xlsx files. For this initial example, we won’t do this, but work with a sample dataset that comes with chillR. The package contains the dataset Winters_hours_gaps, which was recorded in a walnut orchard near Winters, California, in 2008. You can get some impressions of the setting here: These three pictures were taken between March and May of 2008. Note how the light conditions change over time. This impacts the daily temperature dynamics, which we’ll talk about in one of the next chapters To gain access to the Winters_hours_gaps dataset, and to all other functionality in the chillR package, we have to first install and load chillR. Note that in the call below, the install.packages command is ‘commented out’ by the hashtag (#). This means that the respective line isn’t evaluated. If you haven’t installed ‘chillR’ yet, you’ll have to run this line without the #. I’m also loading a couple of additional packages (knitr, pander, kableExtra) that are needed for making the website you’re looking at. #install.packages(&quot;chillR&quot;) library(chillR) library(knitr) library(pander) library(kableExtra) ## ## Attaching package: &#39;kableExtra&#39; ## The following object is masked from &#39;package:dplyr&#39;: ## ## group_rows Especially if you’re a beginner in R or with chillR, but probably also very often later, you may want more information about the functionality you just loaded. You can get more information with the ? command. For more information about a package, you can type something like ?\"chillR-package\" (note the quotation marks). For a function within a loaded package (here the chilling function), simply type ?chilling. To find information about a function across all packages that are installed (but not necessarily loaded), you can use a double question mark: ??chilling. Since the Winters_hours_gaps dataset comes with chillR, we can now display it by running Winters_Hours_gaps. For this website, I’ll use a slightly more complex code to ensure that the table is properly formatted (using the kable format, which you don’t need in R, but which makes the markdown output prettier - you’ll learn later what this means). kable(Winters_hours_gaps[1:10,]) %&gt;% kable_styling(&quot;striped&quot;, position = &quot;left&quot;,font_size = 10) Year Month Day Hour Temp_gaps Temp 2008 3 3 10 15.127 15.127 2008 3 3 11 17.153 17.153 2008 3 3 12 18.699 18.699 2008 3 3 13 18.699 18.699 2008 3 3 14 18.842 18.842 2008 3 3 15 19.508 19.508 2008 3 3 16 19.318 19.318 2008 3 3 17 17.701 17.701 2008 3 3 18 15.414 15.414 2008 3 3 19 12.727 12.727 The dataset contains a column that we don’t need (Temps_gaps, which I added to demonstrate the use of a chillR function that can fill such gaps), so I’m creating a new dataset (hourtemps) that only contains the columns we want. hourtemps &lt;- Winters_hours_gaps[, c(&quot;Year&quot;, &quot;Month&quot;, &quot;Day&quot;, &quot;Hour&quot;, &quot;Temp&quot;)] What we get now is the standard format of an hourly chillR temperature record - with separate columns for Year, Month, Day, Hour and Temp. The last column contains hourly temperatures (without gaps), which we can use to calculate Chilling Hours. The data format of this dataset is called data.frame. This is a structure with multiple columns and rows. We can access information in this hourtemps data.frame by referring to it as hourtemps[row,column]. Here row can be a number, a range of numbers (e.g. c(1,2,4), 1:5), or even a name, if you’re using the option to assign names to rows (we’re not doing that here). column is the same for the columns, except that for this we are using names (e.g. Year, Temp). If you want all rows (columns), leave the column (row) argument blank. To refer to a column, you can also add the name directly after the data.frame name, separated by a $ sign. hourtemps[3, ] ## Year Month Day Hour Temp ## 3 2008 3 3 12 18.699 hourtemps[3, &quot;Temp&quot;] ## [1] 18.699 hourtemps$Temp[1:5] ## [1] 15.127 17.153 18.699 18.699 18.842 hourtemps[1:5, ] ## Year Month Day Hour Temp ## 1 2008 3 3 10 15.127 ## 2 2008 3 3 11 17.153 ## 3 2008 3 3 12 18.699 ## 4 2008 3 3 13 18.699 ## 5 2008 3 3 14 18.842 To assign new values to R objects, you can use the &lt;- sign. You already saw an example of this above, where the hourtemps data.frame was defined. You can also use such an assignment to create a new column in a data.frame. To do this, you just assign new values to a column with the name of your choice hourtemps[,\"myColumn\"]&lt;-NA. NA means ‘not available’. It’s R’s way of saying there’s no data here. But let’s directly jump to a more useful example that will set us on the path to calculating Chilling Hours. We’ve already talked about Chilling Hours, but here’s a reminder of what they are: Every hour with temperatures above (and including) 0°C and below (and including) 7.2°C is considered a Chilling Hour. So what we have to do is check for every hour whether temperatures fall in this range. Such checks can be implemented in R with fairly simple comparison commands (&lt;, &lt;=, ==, =&gt; and &gt;). These can be applied to single numbers, or to so-called vectors, which are strings of numbers (such as the ones created by the c() command - we already used this above). We can combine multiple such comparisons with the &amp; command. 1 == 2 ## [1] FALSE 1 == 1 ## [1] TRUE c(1, 2, 3) &gt; 2 ## [1] FALSE FALSE TRUE a &lt;- 1 b &lt;- 2 c &lt;- 3 c(a, b, c) &gt;= 2 ## [1] FALSE TRUE TRUE c(a, b, c) &gt;= 2 &amp; c(a, b, c) &lt; 3 ## [1] FALSE TRUE FALSE So now we want to check if temperatures in a given hour are within the range considered to be effective for chill accumulation by the Chilling Hours Model. We then want to assign this result to a new column Chilling_Hour. hourtemps[, &quot;Chilling_Hour&quot;] &lt;- hourtemps$Temp &gt;= 0 &amp; hourtemps$Temp &lt;= 7.2 hourtemps[13:20, ] ## Year Month Day Hour Temp Chilling_Hour ## 13 2008 3 3 22 9.040 FALSE ## 14 2008 3 3 23 7.920 FALSE ## 15 2008 3 4 0 6.535 TRUE ## 16 2008 3 4 1 6.687 TRUE ## 17 2008 3 4 2 8.767 FALSE ## 18 2008 3 4 3 9.139 FALSE ## 19 2008 3 4 4 6.788 TRUE ## 20 2008 3 4 5 5.076 TRUE I’m showing you here the rows 13-20 of the dataset, because temperatures only then reached the interesting range. The Chilling_Hour column now reads FALSE and TRUE, but these values are equivalent to 0 and 1, and we can calculate with them. It’s now easy to add up the Chilling Hours of a particular period, which we can do with the sum command. sum(hourtemps$Chilling_Hour[13:20]) ## [1] 4 So between the 13th and 20th hour, we had 4 Chilling Hours. With a slightly more complex command, we can calculate chill between actual dates. We’ll use the which command to identify the hours in the dataset that correspond to the date we’re interested in. Start_Date &lt;- which(hourtemps$Year == 2008 &amp; hourtemps$Month == 10 &amp; hourtemps$Day == 1 &amp; hourtemps$Hour == 12) End_Date &lt;- which(hourtemps$Year == 2008 &amp; hourtemps$Month == 10 &amp; hourtemps$Day == 31 &amp; hourtemps$Hour == 12) sum(hourtemps$Chilling_Hour[Start_Date:End_Date]) ## [1] 28 So in October of 2008, Winters experienced 28 Chilling Hours. 6.2 Our first chill function The code for calculating Chilling Hours wasn’t very complex, and we could easily program it again next time we want to do this. However, this is the simplest chill model, and it’s not very good. The other models are more complicated, and we would probably not want to code them again and again. In such situations programmers use functions. A function is a tool that automates a particular procedure. Even up to here, we’ve already encountered a few functions, including read.csv(), c() and sum(). Now we make one ourselves. A function consists of a name, some arguments that are passed to the function, and some code that should be executed. We can define is as OurFunctionName &lt;- function(argument1, argument2, ...) {ourCode}. All the arguments can be used in the function. What’s returned is either the last object that’s mentioned in the function code or some content specified by the return() function. Here’s an example of this for the Chilling Hours calculation: CH&lt;-function(hourtemps) { hourtemps[, &quot;Chilling_Hour&quot;] &lt;- hourtemps$Temp &gt;= 0 &amp; hourtemps$Temp &lt;= 7.2 return(hourtemps) } Now we have a function that adds a column called Chilling_Hour to our dataframe, which indicates whether an hour is a Chilling Hour or not. Here’s how we can use this: CH(hourtemps)[13:20, ] # again restricted to rows 13-20, ## Year Month Day Hour Temp Chilling_Hour ## 13 2008 3 3 22 9.040 FALSE ## 14 2008 3 3 23 7.920 FALSE ## 15 2008 3 4 0 6.535 TRUE ## 16 2008 3 4 1 6.687 TRUE ## 17 2008 3 4 2 8.767 FALSE ## 18 2008 3 4 3 9.139 FALSE ## 19 2008 3 4 4 6.788 TRUE ## 20 2008 3 4 5 5.076 TRUE # because we don&#39;t want to see the whole output here. We can also make more complex functions, e.g. to calculate the number of Chilling Hours between two dates, which we can specify in the YEARMODA format (i.e. year, month and day, combined in one number). sum_CH &lt;- function(hourtemps, Start_YEARMODA, End_YEARMODA) { Start_Year &lt;- trunc(Start_YEARMODA / 10000) # &quot;trunc&quot; removes all decimals Start_Month &lt;- trunc((Start_YEARMODA - Start_Year*10000) / 100) Start_Day &lt;- Start_YEARMODA - Start_Year * 10000 - Start_Month * 100 Start_Hour &lt;- 12 # This could also be flexible, but let&#39;s skip this for now End_Year &lt;- trunc(End_YEARMODA / 10000) End_Month &lt;- trunc((End_YEARMODA - End_Year * 10000) / 100) End_Day &lt;- End_YEARMODA - End_Year * 10000 - End_Month * 100 End_Hour &lt;- 12 # This could also be flexible, but let&#39;s skip this for now Start_Date &lt;- which(hourtemps$Year == Start_Year &amp; hourtemps$Month == Start_Month &amp; hourtemps$Day == Start_Day &amp; hourtemps$Hour == Start_Hour) End_Date &lt;- which(hourtemps$Year == End_Year &amp; hourtemps$Month == End_Month &amp; hourtemps$Day == End_Day &amp; hourtemps$Hour == End_Hour) Chill_hours &lt;- CH(hourtemps) return(sum(Chill_hours$Chilling_Hour[Start_Date:End_Date])) } This function now includes the pretty annoying conversion between YEARMODA format and the separate columns that are required by chillR. This is stuff you wouldn’t want to program again and again… You see that we’re already making use of our CH() function here, to abbreviate the check for whether temperatures during a particular hour are in the ‘chilling range’. With one call, we can now compute chill accumulation between two dates. Note that the dataset only goes from 3rd March to 11th November 2008, so use of any dates outside that range will generate an error message. If we want to make a more user-friendly function, we’d now add checks for date validity etc. Maybe we’ll do such things later. Here’s how we can now calculate Chilling Hours between two dates: sum_CH(hourtemps, 20080401, 20081011) ## [1] 77 This is basically how functions work, and we’ll encounter lots of this throughout this course. chillR contains many small functions that do specific things. These are then used by other functions to achieve bigger and better things, and in the end we can manage to automatically do some pretty complex analyses. Exercises on basic chill modeling Please document all results of the following assignments in your learning logbook. Write a basic function that calculates warm hours (&gt;25°C) Apply this function to the Winters_hours_gaps dataset Extend this function, so that it can take start and end dates as inputs and sums up warm hours between these dates "],["chill-models.html", "Chapter 7 Chill models Learning goals for this lesson 7.1 Chill models in chillR Exercises on chill models", " Chapter 7 Chill models Learning goals for this lesson Learn how to run chill models using chillR Learn how to produce your own temperature response model in chillR 7.1 Chill models in chillR We already learned how to write a function to calculate Chilling Hours. Unfortunately, you may never have to do that, because chillR already contains such a function. It’s called Chilling_Hours(), and here’s what it looks like: library(chillR) Chilling_Hours ## function(HourTemp,summ=TRUE) ## { ## CH_range&lt;-which(HourTemp&lt;=7.2&amp;HourTemp&gt;=0) ## CH_weights&lt;-rep(0,length(HourTemp)) ## CH_weights[CH_range]&lt;-1 ## if(summ==TRUE) return(cumsum(CH_weights)) else ## return(CH_weights) ## } ## &lt;bytecode: 0x561e2b861450&gt; ## &lt;environment: namespace:chillR&gt; This is a pretty basic function that takes an hourly temperature dataset (HourTemp) as input and determines for each hour if temperatures are below 7.2°C and above 0°C. If the argument summ is TRUE, the function returns the cumulative Chilling Hours that have accumulated by every hour of the record. If this argument is FALSE, we just get a list of 1s and 0s to indicate which hours are Chilling Hours and which ones aren’t. The default version of the function is to run it with summ==TRUE, as you can see in the first line of the function. So if you don’t specify anything for the summ argument, it will return the cumulative sum of Chilling Hours. We can easily apply this now to our Winters_hours_gap dataset: Chilling_Hours(Winters_hours_gaps$Temp)[1:100] ## [1] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 2 2 2 3 4 5 6 6 6 6 ## [26] 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 ## [51] 6 6 6 6 6 6 6 6 6 6 6 7 8 9 10 11 12 13 14 15 16 16 16 16 16 ## [76] 16 16 16 16 16 16 16 16 16 16 17 18 19 20 21 22 23 24 25 25 25 25 25 25 25 I only returned the first 100 values. The dataset contains 5974 more. The last number in this entire series is 203. Chilling Hours are great for an entry-level tutorial on chill modeling, but they’re not a particularly credible metric, so I suggest you forget them right away. Let’s turn our eyes towards more credible models. The Utah Model (Richardson et al., 1974) is somewhat more credible, since it assumes different weights for different temperatures. This model is also implemented in chillR: Utah_Model ## function(HourTemp,summ=TRUE) ## return(step_model(HourTemp,df=data.frame(lower=c(-1000,1.4,2.4,9.1,12.4,15.9,18),upper=c(1.4,2.4,9.1,12.4,15.9,18,1000),weight=c(0,0.5,1,0.5,0,-0.5,-1)),summ=summ)) ## &lt;bytecode: 0x561e2bea1a68&gt; ## &lt;environment: namespace:chillR&gt; Utah_Model(Winters_hours_gaps$Temp)[1:100] ## [1] 0.0 -0.5 -1.5 -2.5 -3.5 -4.5 -5.5 -6.0 -6.0 -6.0 -5.5 -5.0 -4.0 -3.0 -2.0 ## [16] -1.0 0.0 0.5 1.5 2.5 3.5 4.5 5.0 5.0 5.0 4.0 3.0 2.0 1.0 0.0 ## [31] -1.0 -2.0 -2.5 -2.5 -2.0 -1.5 -1.0 -0.5 0.5 1.0 1.5 2.0 2.0 2.5 3.0 ## [46] 3.5 4.0 4.0 4.0 3.5 2.5 1.5 0.5 -0.5 -1.5 -2.5 -3.0 -3.0 -2.5 -1.5 ## [61] -0.5 0.5 1.5 2.5 3.5 4.5 5.5 6.5 7.5 8.5 9.5 10.0 10.0 9.5 9.0 ## [76] 8.5 8.0 7.5 7.0 6.5 6.5 7.0 7.5 8.5 9.5 10.5 11.5 12.5 13.5 14.5 ## [91] 15.5 16.5 17.5 18.5 19.0 19.0 19.0 18.5 17.5 16.5 In the definition of this model, you see another function called step_model(). This is also a chillR function, which allows you to define your own model, based on temperature thresholds and weights. You could, for example, use this function to implement various variations of the Utah Model that have been developed for different locations. The function takes as input a data.frame that contains the weights you want to apply to different temperature ranges. Here’s an example of such a data.frame, a function called custom() that implements a chill model based on this, and the application of this function to the Winters_hours_gaps dataset: df&lt;-data.frame( lower= c(-1000, 1, 2, 3, 4, 5, 6), upper= c( 1, 2, 3, 4, 5, 6, 1000), weight=c( 0, 1, 2, 3, 2, 1, 0)) kable(df) %&gt;% kable_styling(&quot;striped&quot;, position = &quot;left&quot;, font_size = 10) lower upper weight -1000 1 0 1 2 1 2 3 2 3 4 3 4 5 2 5 6 1 6 1000 0 custom &lt;- function(x) step_model(x, df) custom(Winters_hours_gaps$Temp)[1:100] ## [1] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 4 7 7 7 7 ## [26] 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 ## [51] 7 7 7 7 7 7 7 7 7 7 7 7 7 7 8 10 13 16 19 22 22 22 22 22 22 ## [76] 22 22 22 22 22 22 22 22 22 22 22 22 23 25 27 29 31 34 37 37 37 37 37 37 37 The Chilling Hours and Utah Models are fairly straightforward. We could probably have calculated these metrics without these functions, though of course the process gets easier with them. What has long been a much greater challenge to dormancy modelers is implementing the ‘Dynamic Model’, which involves pretty complicated equations. The original papers on this model were rather heavy on maths, leaving many horticultural researchers a bit lost. For a long time, the only version of the model that people could easily use was an Excel sheet that was put together a few decades ago. For chillR, I extracted all the equations from this Excel sheet, to make the Dynamic_Model() function. This is pretty complicated, and a bit of effort was needed to get this right. But the effort was worth it - now we’ll never have to deal with these equations again, because we have a function that does all the calculations for us. Dynamic_Model(Winters_hours_gaps$Temp)[1:100] ## [1] 0.0000000 0.0000000 0.0000000 0.0000000 0.0000000 0.0000000 0.0000000 ## [8] 0.0000000 0.0000000 0.0000000 0.0000000 0.0000000 0.0000000 0.0000000 ## [15] 0.0000000 0.0000000 0.0000000 0.0000000 0.0000000 0.0000000 0.0000000 ## [22] 0.0000000 0.0000000 0.0000000 0.0000000 0.0000000 0.0000000 0.0000000 ## [29] 0.0000000 0.0000000 0.0000000 0.0000000 0.0000000 0.0000000 0.0000000 ## [36] 0.0000000 0.0000000 0.0000000 0.0000000 0.0000000 0.0000000 0.0000000 ## [43] 0.0000000 0.0000000 0.0000000 0.0000000 0.0000000 0.0000000 0.0000000 ## [50] 0.0000000 0.0000000 0.0000000 0.0000000 0.0000000 0.0000000 0.0000000 ## [57] 0.0000000 0.0000000 0.0000000 0.0000000 0.0000000 0.0000000 0.0000000 ## [64] 0.0000000 0.0000000 0.0000000 0.0000000 0.0000000 0.0000000 0.0000000 ## [71] 0.0000000 0.9698435 0.9698435 0.9698435 0.9698435 0.9698435 0.9698435 ## [78] 0.9698435 0.9698435 0.9698435 0.9698435 0.9698435 0.9698435 0.9698435 ## [85] 0.9698435 0.9698435 0.9698435 0.9698435 0.9698435 0.9698435 0.9698435 ## [92] 0.9698435 0.9698435 0.9698435 0.9698435 0.9698435 0.9698435 0.9698435 ## [99] 0.9698435 0.9698435 So chillR has a few functions that can be applied to hourly temperature data. It also has wrapper functions that allow computing chill between specific start and end dates. The chilling() function automatically calculates a few basic metrics for us. Note that we have to use the chillR function make_JDay() here to add the Julian dates (counts the days of the year) to the dataset for this to work. output &lt;- chilling(make_JDay(Winters_hours_gaps), Start_JDay = 90, End_JDay = 100) kable(output) %&gt;% kable_styling(&quot;striped&quot;, position = &quot;left&quot;, font_size = 10) Season End_year Season_days Data_days Perc_complete Chilling_Hours Utah_Model Chill_portions GDH 2007/2008 2008 11 11 100 40 15.5 2.009147 2406.52 So the chilling() function implements the Chilling Hours, Utah and Dynamic Models, and it also calculates Growing Degree Days (GDH). But maybe we don’t want all of these, or we want other metrics. In that case, we can make use of the tempResponse function, which is somewhat similar to chilling(), but it takes as input a list of temperature models to be computed. output &lt;- tempResponse(make_JDay(Winters_hours_gaps), Start_JDay = 90, End_JDay = 100, models = list(Chill_Portions = Dynamic_Model, GDH = GDH)) kable(output) %&gt;% kable_styling(&quot;striped&quot;, position = &quot;left&quot;, font_size = 10) Season End_year Season_days Data_days Perc_complete Chill_Portions GDH 2007/2008 2008 11 11 100 2.009147 2406.52 Exercises on chill models Please document all results of the following assignments in your learning logbook. Run the chilling() function on the Winters_hours_gap dataset Create your own temperature-weighting chill model using the step_model() function Run this model on the Winters_hours_gaps dataset using the tempResponse() function. References Richardson E, Seeley S &amp; Walker D. (1974). A model for estimating the completion of rest for \"redhaven\" and \"elberta\" peach trees. HortScience, 9(4), 331–332. "],["making-hourly-temperatures.html", "Chapter 8 Making hourly temperatures Learning goals for this lesson 8.1 Generating hourly temperatures Exercises on hourly temperatures", " Chapter 8 Making hourly temperatures Learning goals for this lesson Understand why we often need hourly temperature data and why we need ways of making them out of daily data Understand some basic algorithms for making hourly data from daily minimum and maximum temperatures Understand how we can make use of observed hourly temperatures to produce our own empirical transfer function that can make hourly from daily data Be able to use the respective chillR functions that implement these steps 8.1 Generating hourly temperatures Now that we have the Chilling Hours function coded, we can move on to the next problem - we don’t usually have hourly temperature data. Most sources only provide daily data, usually including minimum and maximum temperature of the day, from which we can’t directly calculate Chilling Hours. This has long been a challenge, and people found a bunch of suboptimal solutions for this. For example, some reseachers calculated Chilling Hours for a certain number of days based on high-resolution data and then related the number of Chilling Hours to the minimum temperature (Crossa-Raynaud, 1955), or they made a more complex regression equation. When computing became easier, people started assuming that the daily minimum temperature occurred at a certain time of day, and the maximum temperature at another time. For hours between these times, they interpolated linearly, which resulted in a ‘triangular’ daily temperature pattern (Baldocchi &amp; Wong, 2008) (Link). Here’s what this looks like: This may not be a totally unreasonable approximation, but of course this isn’t particularly realistic. The rate of temperature increase in the morning is not the same as the rate of decrease in the evening. Besides, in particular the time of the lowest daily temperature varies considerably throughout the year (unless you’re close to the equator), and it would be good to consider this. 8.1.1 Idealized daily temperature curves A major step forward was taken when Dale E. Linvill from Clemson University in South Carolina (USA) published a paper (Linvill, 1990) (Link) that described the daily temperature curve using a combination of two mathematical equations: a sine curve to describe daytime warming, and a logarithmic decay function for nighttime cooling. The transition points between the two parts were determined by sunrise and sunset, and the duration of the parts was related to daylength. The equations in this paper paved the way for making more realistic daily temperature curves than could easily be constructed before. This of course doesn’t mean that all studies that came later used these equations - very far from it! This is mainly because people have either not been aware of these equations, or they were lacking the data processing skills to use them in their work. One aspect that made Linvill’s equations hard to use across different locations was the dependency on sunrise and sunset times. Of course, tables of these times can be produced from observations everywhere, but modelers would greatly benefit from a generic method to determine these. Fortunately, at least for locations without major topographic features, sunrise and sunset times can be calculated based on what we know about the geometry of our solar system. As agricultural scientists, this doesn’t come naturally to us, but we can make use of what researchers in other fields have found out. The procedures in chillR rely on equations produced by Spencer (1971) (Link) and Almorox et al. (2005) (Link). Don’t ask me now how exactly these equations work, since I don’t remember… It was enough to figure this out once, in the early days of my chilling analysis career, code it into an R function (or actually first a JSL function, but that’s another story) and then just rely on that function for all subsequent work. Putting together all these functions (Almorox et al., 2005; Linvill, 1990; Spencer, 1971) basically worked the same way as what we’ve just seen with the development of the CH() function and its subsequent embedding in the sum_CH function - just that the individual components were a bit more complex. The result was a function that can produce credible daily temperature curves based only on the latitude of the location of interest. The code below provides some use examples of the daylength function, which is involved in producing daily temperature curves. Let’s make plots of the sunrise time, sunset time and daylength at Klein-Altendorf (Latitude: 50.4°N) over the course of the year. require(chillR) require(ggplot2) require(tidyr) Days &lt;- daylength(latitude = 50.4, JDay = 1:365) Days_df &lt;- data.frame( JDay = 1:365, Sunrise = Days$Sunrise, Sunset = Days$Sunset, Daylength = Days$Daylength ) Days_df &lt;- pivot_longer(Days_df,cols=c(Sunrise:Daylength)) ggplot(Days_df, aes(JDay, value)) + geom_line(lwd = 1.5) + facet_grid(cols = vars(name)) + ylab(&quot;Time of Day / Daylength (Hours)&quot;) + theme_bw(base_size = 20) Here, JDay is the so-called Julian Date, which basically means the Day of the Year. January 1st ist JDay 1, and December 31st either JDay 365 (in normal years) or JDay 366 (in leap years). I’m using the ggplot2 package, which is a really elegant tool for making attractive plots. We’ll get to talk a bit more about how this works. The ideal input for this is a data.frame, so I converted the outputs of the daylength() function into a data.frame first. I also had to convert the data.frame, so that the three time series (Sunrise, Sunset and Daylength) were stacked on top of each other. That was accomplished by the pivot_longer command of the tidyr package. These daily dynamics are integrated in the stack_hourly_temps() function in chillR. This function takes as input a dataset of daily minimum and maximum temperatures (must have columns called Tmin and Tmax, as well as Year, Month and Day). It also needs to be told the latitude of the place of interest. With these inputs, we can apply the various equations we just discussed and calculate hourly temperatures. Optionally, we can also choose to output, in addition, the sunrise and sunset times. To illustrate how this works, we’ll use another dataset that comes with chillR: KA_weather. This is a data.frame that contains temperature data for the experimental station of the University of Bonn at Klein-Altendorf. Here are the first 10 rows of the KA_weather dataset: Year Month Day Tmax Tmin 1998 1 1 8.2 5.1 1998 1 2 9.1 5.0 1998 1 3 10.4 3.3 1998 1 4 8.4 4.5 1998 1 5 7.7 4.5 1998 1 6 8.1 4.4 1998 1 7 12.0 6.9 1998 1 8 11.2 8.6 1998 1 9 13.9 8.5 1998 1 10 14.5 3.6 And this is how we can convert this to hourly temperatures based on the idealized curve: stack_hourly_temps(KA_weather, latitude=50.4) Year Month Day Tmax Tmin JDay Hour Temp 1998 1 5 7.7 4.5 5 3 4.844164 1998 1 5 7.7 4.5 5 4 4.746566 1998 1 5 7.7 4.5 5 5 4.656244 1998 1 5 7.7 4.5 5 6 4.572187 1998 1 5 7.7 4.5 5 7 4.493583 1998 1 5 7.7 4.5 5 8 4.569464 1998 1 5 7.7 4.5 5 9 5.384001 1998 1 5 7.7 4.5 5 10 6.139939 1998 1 5 7.7 4.5 5 11 6.787169 1998 1 5 7.7 4.5 5 12 7.282787 1998 1 5 7.7 4.5 5 13 7.593939 1998 1 5 7.7 4.5 5 14 7.700000 1998 1 5 7.7 4.5 5 15 7.593939 1998 1 5 7.7 4.5 5 16 7.282787 1998 1 5 7.7 4.5 5 17 6.591821 1998 1 5 7.7 4.5 5 18 6.168074 1998 1 5 7.7 4.5 5 19 5.870570 1998 1 5 7.7 4.5 5 20 5.641106 1998 1 5 7.7 4.5 5 21 5.454280 1998 1 5 7.7 4.5 5 22 5.296704 1998 1 5 7.7 4.5 5 23 5.160445 And here’s a plot of the data: 8.1.2 Empirical daily temperature curves There are some locations where idealized daily temperature curves don’t work. For instance, some places where temperate fruit trees are grown feature rugged topography, so that trees may be shaded for part of the day. The pictures below show the region where I first started working on winter chill - the Jabal Al Akhdar (the Green Mountain) region in Oman. We investigated several oases in Wadi Muaydin, a deeply incised canyon. Near the top of the canyon, trees get a lot more sunlight than at the bottom of the valley, about 1000 m below. Overview of Wadi Muaydin - the lowest oasis, Masayrat ar Ruwajah, is at the end of the steep, curvy road you can see disappear at the bottom of the image. Impression of the oasis of Wadi Bani Habib (a few kilometers away) illustrating the impact that toppgraphic shading can have. Terraced oasis fields at Ash Sharayjah. The pomegranates and other temperate tree crops there are already enjoying the morning sun. Trees in the oasis of Qasha’, located in the lower left corner of the image, are still hidden in the shadows. Even without such mountains, it seems quite likely that the temperature curve in an orchard, which may feature its own microclimate, with shaded and sunny spots, with dew-covered grass or bare ground etc., may not closely resemble the curve drawn up by Linvill (1990) (Link). In our first study on the Omani oases (Luedeling et al., 2009b) (Link), we didn’t address this issue very well (not even with the idealized daily curve yet), but we recently revisited this location, this time committed to doing this better. Here’s what we came up with (Buerkert et al., 2020) (Link): First we need a dataset of hourly temperature data for the location of interest. This should cover a full year, and ideally multiple years. For the purpose of this exercise, we’ll use the Winters_hours_gaps dataset, which is included in chillR. I collected this dataset in a walnut orchard near Winters, California. The temperature logger was attached directly to a tree branch, so I wouldn’t expect the data to precisely mirror the usual daily temperature curve. We now use the Empirical_daily_temperature_curve() function to determine the typical pattern of hourly temperatures at this location. This is done separately for each month of the year (there may still be room for improvement here - this could be continuous and not broken down by months). empi_curve &lt;- Empirical_daily_temperature_curve(Winters_hours_gaps) Let’s see what the results look like, in a table and a figure. kable(empi_curve[1:48, ]) %&gt;% kable_styling(&quot;striped&quot;, position = &quot;left&quot;, font_size = 10) Month Hour Prediction_coefficient 3 0 0.1774859 3 1 0.1550693 3 2 0.1285651 3 3 0.1145597 3 4 0.0696064 3 5 0.0339583 3 6 0.0000000 3 7 0.0313115 3 8 0.3121959 3 9 0.4953232 3 10 0.6819674 3 11 0.8227423 3 12 0.9506491 3 13 0.9662604 3 14 0.9915996 3 15 1.0000000 3 16 0.9490319 3 17 0.8483098 3 18 0.6864529 3 19 0.4945415 3 20 0.3636642 3 21 0.2972377 3 22 0.2360349 3 23 0.1794802 4 0 0.1960789 4 1 0.1407018 4 2 0.1283250 4 3 0.0819307 4 4 0.0541415 4 5 0.0188241 4 6 0.0000000 4 7 0.1697052 4 8 0.4442722 4 9 0.5939797 4 10 0.7363923 4 11 0.8399804 4 12 0.9245702 4 13 0.9770693 4 14 0.9963131 4 15 1.0000000 4 16 0.9568107 4 17 0.8698369 4 18 0.7343896 4 19 0.5330597 4 20 0.3941038 4 21 0.3186075 4 22 0.2594569 4 23 0.2114486 ggplot(data = empi_curve[1:96, ], aes(Hour, Prediction_coefficient)) + geom_line(lwd = 1.3, col = &quot;red&quot;) + facet_grid(rows = vars(Month)) + xlab(&quot;Hour of the day&quot;) + ylab(&quot;Prediction coefficient&quot;) + theme_bw(base_size = 20) We can now apply this set of coefficients to a daily dataset from the same location, which should give us a reasonable hourly temperature record for this orchard. For this, we can use the Empirical_hourly_temperatures function, which requires as inputs a set of hourly coefficients (such as the one we just made), and a daily temperature record (which includes Tmin and Tmax columns). Did I mention that you can always use the ? to get help on how to use a function (e.g. ?Empirical_hourly_temperatures). So here’s how this works. Note that this also demonstrates use of the make_all_day_table function, which can fill gaps in daily or hourly temperature records and - as in this case - summarize hourly records into daily minimum and maximum temperatures: coeffs &lt;- Empirical_daily_temperature_curve(Winters_hours_gaps) Winters_daily &lt;- make_all_day_table(Winters_hours_gaps, input_timestep = &quot;hour&quot;) Winters_hours &lt;- Empirical_hourly_temperatures(Winters_daily, coeffs) This is it really. Let’s plot the result to see what it looks like. We can also compare the results to those of the triangular function and the idealized temperature curve. In this example, we also have the actual observed temperatures, so we can use these to validate the results as well. First, let’s simplify the data a bit, so that it gets easier to use: require(reshape2) Winters_hours &lt;- Winters_hours[, c(&quot;Year&quot;, &quot;Month&quot;, &quot;Day&quot;, &quot;Hour&quot;, &quot;Temp&quot;)] colnames(Winters_hours)[ncol(Winters_hours)] &lt;- &quot;Temp_empirical&quot; Winters_ideal &lt;- stack_hourly_temps(Winters_daily, latitude = 38.5)$hourtemps Winters_ideal &lt;- Winters_ideal[, c(&quot;Year&quot;, &quot;Month&quot;, &quot;Day&quot;, &quot;Hour&quot;, &quot;Temp&quot;)] colnames(Winters_ideal)[ncol(Winters_ideal)] &lt;- &quot;Temp_ideal&quot; Now we make the ‘triangular’ dataset. See if you can understand how this works. Winters_triangle &lt;- Winters_daily Winters_triangle[, &quot;Hour&quot;] &lt;- 0 Winters_triangle$Hour[nrow(Winters_triangle)] &lt;- 23 Winters_triangle[, &quot;Temp&quot;] &lt;- 0 Winters_triangle &lt;- make_all_day_table(Winters_triangle, timestep = &quot;hour&quot;) colnames(Winters_triangle)[ncol(Winters_triangle)] &lt;- &quot;Temp_triangular&quot; # with the following loop, we fill in the daily Tmin and Tmax values for every # hour of the dataset for (i in 2:nrow(Winters_triangle)) { if (is.na(Winters_triangle$Tmin[i])) Winters_triangle$Tmin[i] &lt;- Winters_triangle$Tmin[i - 1] if (is.na(Winters_triangle$Tmax[i])) Winters_triangle$Tmax[i] &lt;- Winters_triangle$Tmax[i - 1] } Winters_triangle$Temp_triangular &lt;- NA # now we assign the daily Tmin value to the 6th hour of every day Winters_triangle$Temp_triangular[which(Winters_triangle$Hour == 6)] &lt;- Winters_triangle$Tmin[which(Winters_triangle$Hour == 6)] # we also assign the daily Tmax value to the 18th hour of every day Winters_triangle$Temp_triangular[which(Winters_triangle$Hour == 18)] &lt;- Winters_triangle$Tmax[which(Winters_triangle$Hour == 18)] # in the following step, we use the chillR function &quot;interpolate_gaps&quot; # to fill in all the gaps in the hourly record with straight lines Winters_triangle$Temp_triangular &lt;- interpolate_gaps(Winters_triangle$Temp_triangular)$interp Winters_triangle &lt;- Winters_triangle[, c(&quot;Year&quot;, &quot;Month&quot;, &quot;Day&quot;, &quot;Hour&quot;, &quot;Temp_triangular&quot;)] Now we merge all these data.frames so that we can easily display them: Winters_temps &lt;- merge(Winters_hours_gaps, Winters_hours, by = c(&quot;Year&quot;, &quot;Month&quot;, &quot;Day&quot;, &quot;Hour&quot;)) Winters_temps &lt;- merge(Winters_temps, Winters_triangle, by = c(&quot;Year&quot;, &quot;Month&quot;, &quot;Day&quot;, &quot;Hour&quot;)) Winters_temps &lt;- merge(Winters_temps, Winters_ideal, by = c(&quot;Year&quot;, &quot;Month&quot;, &quot;Day&quot;, &quot;Hour&quot;)) Now we have a dataset with the observed temperatures and the three approximations (triangular, idealized curve and empirical curve). To plot this effectively, let’s convert the Year, Month, Day and Hour columns into R’s date format (using ISOdate) and reorganize the data.frame a bit. Winters_temps[, &quot;DATE&quot;] &lt;- ISOdate(Winters_temps$Year, Winters_temps$Month, Winters_temps$Day, Winters_temps$Hour) Winters_temps_to_plot &lt;- Winters_temps[, c(&quot;DATE&quot;, &quot;Temp&quot;, &quot;Temp_empirical&quot;, &quot;Temp_triangular&quot;, &quot;Temp_ideal&quot;)] Winters_temps_to_plot &lt;- Winters_temps_to_plot[100:200, ] Winters_temps_to_plot &lt;- pivot_longer(Winters_temps_to_plot, cols=Temp:Temp_ideal) colnames(Winters_temps_to_plot) &lt;- c(&quot;DATE&quot;, &quot;Method&quot;, &quot;Temperature&quot;) ggplot(data = Winters_temps_to_plot, aes(DATE, Temperature, colour = Method)) + geom_line(lwd = 1.3) + ylab(&quot;Temperature (°C)&quot;) + xlab(&quot;Date&quot;) This plots shows that the triangular curve is quite far off the mark. Temp_empirical and Temp_ideal look pretty similar and are hard to distinguish. We can compare these curves a bit more thoroughly by computing, for example, the Root Mean Square Error, which is useful for quantifying the correspondence between predicted and observed values. chillR has a function for this: # here&#39;s the RMSE for the triangular method: RMSEP(Winters_temps$Temp_triangular, Winters_temps$Temp) ## [1] 4.695289 # here&#39;s the RMSE for the idealized-curve method: RMSEP(Winters_temps$Temp_ideal, Winters_temps$Temp) ## [1] 1.630714 # and here&#39;s the RMSE for the empirical-curve method: RMSEP(Winters_temps$Temp_empirical, Winters_temps$Temp) ## [1] 1.410625 As you see, we get an RMSE of 4.7 for the triangular method, an RMSE of 1.63 for the idealized-curve method, and an RMSE of 1.41 for the empirical-curve method. Since this metric should be low, we see that calibrating the prediction function with observed hourly data brought some advantages, in particular when compared with the triangular method. You may wonder if this makes much of a difference, when we want to model chill accumulation or something like that. Well, you may be able to test that already (spoiler alert: it often matters quite a bit)! Exercises on hourly temperatures Please document all results of the following assignments in your learning logbook. Choose a location of interest, find out its latitude and produce plots of daily sunrise, sunset and daylength Produce an hourly dataset, based on idealized daily curves, for the KA_weather dataset (included in chillR) Produce empirical temperature curve parameters for the Winters_hours_gaps dataset, and use them to predict hourly values from daily temperatures (this is very similar to the example above, but please make sure you understand what’s going on) References Almorox J, Hontoria C &amp; Benito M. (2005). Statistical validation of daylength definitions for estimation of global solar radiation in toledo, spain. Energy Conversion and Management, 46(9-10), 1465–1471. Baldocchi D &amp; Wong S. (2008). Accumulated winter chill is decreasing in the fruit growing regions of california. Climatic Change, 87(1), 153–166. doi: 10.1007/s10584-007-9367-8 Buerkert A, Fernandez E, Tietjen B &amp; Luedeling E. (2020). Revisiting climate change effects on winter chill in mountain oases of northern oman. Climatic Change, 162, 1399–1417. doi: 10.1007/s10584-020-02862-8 Crossa-Raynaud P. (1955). Effets des hivers doux sur le comportement des arbres fruitiers à feuilles caduques: Observations faites en tunisie à la suite de l’hiver 1954-1955. Impr. La Rapide. Linvill DE. (1990). Calculating chilling hours and chill units from daily maximum and minimum temperature observations. HortScience, 25(1), 14–16. doi: 10.21273/HORTSCI.25.1.14 Luedeling E, Gebauer J &amp; Buerkert A. (2009b). Climate change effects on winter chill for tree crops with chilling requirements on the Arabian Peninsula. Climatic Change, 96(1-2), 219–237. doi: 10.1007/s10584-009-9581-7 Spencer J. (1971). Fourier series reprensentation of the position of the sun. Search, 2(5), 172. "],["some-useful-tools-in-r.html", "Chapter 9 Some useful tools in R Learning goals for this lesson 9.1 An evolving language - and a lifelong learning process 9.2 The tidyverse 9.3 The ggplot2 package 9.4 The tibble package 9.5 The magrittr package - pipes 9.6 The tidyr package 9.7 Loops 9.8 apply functions Exercises on useful R tools", " Chapter 9 Some useful tools in R Learning goals for this lesson Get to know some neat tools in R that can make coding more elegant - and easier Get introduced to the tidyverse Learn about loops Get to know the apply function family 9.1 An evolving language - and a lifelong learning process The R universe is a very active space, with lots of improvements being made all the time in various places. Through these improvements, the language has evolved far beyond the relatively basic capabilities of base R. When I started learning R around 2010, I solved most of my problems with base R functions. This often resulted in convoluted code and ugly plots… I’d like to believe this was because the more advanced functions weren’t available yet, but the real reason is that my personal learning curve hadn’t caught up (and still hasn’t caught up) with the true state of the art in R programming. Over the years, I have gradually come around to adopting some of these more modern tools and more elegant programming styles. Since we’ll be using some of these throughout the remaining chapters, it’s now time for an introduction. For all the tools in this chapter, there are much better and more comprehensive instruction materials elsewhere on the web (I’ll provide pointers), but I’ll try to give you the basics you need in order to follow the materials in this book. 9.2 The tidyverse Many of the specific tools I want to introduce to you are part of the tidyverse, a set of packages developed by Hadley Wickham and his team. The whole collection is described here. I have only scratched the surface of this, but I encourage you to delve into this treasure chest to look for ways to improve your programming capabilities. Here, I’ll only highlight the functions that are used in this book. A nice feature of the tidyverse is that we only have to load a single package to access all the tidyverse capabilities: library(tidyverse) does the trick. 9.3 The ggplot2 package We’ve already encountered ggplot2, so I’m just listing this here for completeness. Initially released in 2007 by Hadley Wickham, ggplot2 has become one of the most popular R packages, because it greatly facilitates making attractive figures. You can read up on the history of the package here. A great introduction to ggplot2 and links to various tutorials etc. can be accessed here. 9.4 The tibble package A tibble is an advanced version of a data.frame, which includes several improvements. These are described here. The most relevant improvement in my view is that tibbles don’t follow the classic data.frame habit of converting strings to factors at times when you don’t expect it. I’m fairly new to tibbles myself, but I’ll try to use them throughout the remainder of this book. You can easily create a tibble from a normal data.frame (or a similar structure) by using the as_tibble command. library(tidyverse) dat &lt;- data.frame(a=c(1,2,3),b=c(4,5,6)) d &lt;- as_tibble(dat) d ## # A tibble: 3 × 2 ## a b ## &lt;dbl&gt; &lt;dbl&gt; ## 1 1 4 ## 2 2 5 ## 3 3 6 9.5 The magrittr package - pipes The main thing magrittr adds is a structure to organize workflows that are applied to the same dataset. A data structure such as a tibble can be subjected to one or multiple operations organized in a pipe. The notation for such a pipe is %&gt;%. For instance, we can calculate the sum of all numbers in the tibble d we created above by the following operation. d %&gt;% sum() ## [1] 21 Note that we didn’t have to pass the d to the sum command as an input. After a pipe, the following function always assumes that the first input to the function is the product received through the pipe. You can add more commands by adding another pipe after the first one. We’ll get to some more complex - and more useful - examples below. 9.6 The tidyr package tidyr provides useful functions for organizing your data. I’ll use the KA_weather dataset from chillR to demonstrate how some of these work. library(chillR) KAw&lt;-as_tibble(KA_weather[1:10,]) KAw ## # A tibble: 10 × 5 ## Year Month Day Tmax Tmin ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1998 1 1 8.2 5.1 ## 2 1998 1 2 9.1 5 ## 3 1998 1 3 10.4 3.3 ## 4 1998 1 4 8.4 4.5 ## 5 1998 1 5 7.7 4.5 ## 6 1998 1 6 8.1 4.4 ## 7 1998 1 7 12 6.9 ## 8 1998 1 8 11.2 8.6 ## 9 1998 1 9 13.9 8.5 ## 10 1998 1 10 14.5 3.6 9.6.1 pivot_longer We already encountered the pivot_longer function in the previous lesson. We can use this to transfer data from separate columns (e.g. Tmin and Tmax in this case) into distinct rows. In this example, we’ll have one row containing Tmin and one row for Tmax for each day of the record. We’ll often have to do this, for instance, when we want to use the ggplot2 package for plotting our data. Here’s how this works (with a pipe). KAwlong &lt;- KAw %&gt;% pivot_longer(cols=Tmax:Tmin) KAwlong ## # A tibble: 20 × 5 ## Year Month Day name value ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 1998 1 1 Tmax 8.2 ## 2 1998 1 1 Tmin 5.1 ## 3 1998 1 2 Tmax 9.1 ## 4 1998 1 2 Tmin 5 ## 5 1998 1 3 Tmax 10.4 ## 6 1998 1 3 Tmin 3.3 ## 7 1998 1 4 Tmax 8.4 ## 8 1998 1 4 Tmin 4.5 ## 9 1998 1 5 Tmax 7.7 ## 10 1998 1 5 Tmin 4.5 ## 11 1998 1 6 Tmax 8.1 ## 12 1998 1 6 Tmin 4.4 ## 13 1998 1 7 Tmax 12 ## 14 1998 1 7 Tmin 6.9 ## 15 1998 1 8 Tmax 11.2 ## 16 1998 1 8 Tmin 8.6 ## 17 1998 1 9 Tmax 13.9 ## 18 1998 1 9 Tmin 8.5 ## 19 1998 1 10 Tmax 14.5 ## 20 1998 1 10 Tmin 3.6 As you can see, we had to specify the columns that we wanted to stack up. Note that pivot_longer fulfills a similar function to the melt function of the reshape2 package, which I used until recently (and in earlier versions of this book). I find pivot_longer more intuitive, so I’ll be using this throughout the remaining chapters. 9.6.2 pivot_wider We can also do an opposite conversion to the one implemented by pivot_longer by using the pivot_wider command. KAwwide &lt;- KAwlong %&gt;% pivot_wider(names_from=name) KAwwide ## # A tibble: 10 × 5 ## Year Month Day Tmax Tmin ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1998 1 1 8.2 5.1 ## 2 1998 1 2 9.1 5 ## 3 1998 1 3 10.4 3.3 ## 4 1998 1 4 8.4 4.5 ## 5 1998 1 5 7.7 4.5 ## 6 1998 1 6 8.1 4.4 ## 7 1998 1 7 12 6.9 ## 8 1998 1 8 11.2 8.6 ## 9 1998 1 9 13.9 8.5 ## 10 1998 1 10 14.5 3.6 The names_from argument specified the column that contains the new column headers. In this example, the call would also have worked without this argument, but that may not always be the case. 9.6.3 select With the select function, we can pick out a subset of the columns of a data.frame or tibble. KAw %&gt;% select(c(Month, Day, Tmax)) ## # A tibble: 10 × 3 ## Month Day Tmax ## &lt;int&gt; &lt;int&gt; &lt;dbl&gt; ## 1 1 1 8.2 ## 2 1 2 9.1 ## 3 1 3 10.4 ## 4 1 4 8.4 ## 5 1 5 7.7 ## 6 1 6 8.1 ## 7 1 7 12 ## 8 1 8 11.2 ## 9 1 9 13.9 ## 10 1 10 14.5 9.6.4 filter The filter function reduces a data.frame or tibble to just the rows that fulfill certain conditions. KAw %&gt;% filter(Tmax&gt;10) ## # A tibble: 5 × 5 ## Year Month Day Tmax Tmin ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1998 1 3 10.4 3.3 ## 2 1998 1 7 12 6.9 ## 3 1998 1 8 11.2 8.6 ## 4 1998 1 9 13.9 8.5 ## 5 1998 1 10 14.5 3.6 9.6.5 mutate The mutate function is a work horse for creating, modifying, and deleting columns from a data.frame or tibble. Let’s first create new columns, e.g. two columns that contain Tmin and Tmax in Kelvin. KAw_K &lt;- KAw %&gt;% mutate(Tmax_K = Tmax + 273.15, Tmin_K = Tmin + 273.15) KAw_K ## # A tibble: 10 × 7 ## Year Month Day Tmax Tmin Tmax_K Tmin_K ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1998 1 1 8.2 5.1 281. 278. ## 2 1998 1 2 9.1 5 282. 278. ## 3 1998 1 3 10.4 3.3 284. 276. ## 4 1998 1 4 8.4 4.5 282. 278. ## 5 1998 1 5 7.7 4.5 281. 278. ## 6 1998 1 6 8.1 4.4 281. 278. ## 7 1998 1 7 12 6.9 285. 280. ## 8 1998 1 8 11.2 8.6 284. 282. ## 9 1998 1 9 13.9 8.5 287. 282. ## 10 1998 1 10 14.5 3.6 288. 277. Now we delete these columns again, by setting them to NULL. KAw_K %&gt;% mutate(Tmin_K = NULL, Tmax_K = NULL) ## # A tibble: 10 × 5 ## Year Month Day Tmax Tmin ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1998 1 1 8.2 5.1 ## 2 1998 1 2 9.1 5 ## 3 1998 1 3 10.4 3.3 ## 4 1998 1 4 8.4 4.5 ## 5 1998 1 5 7.7 4.5 ## 6 1998 1 6 8.1 4.4 ## 7 1998 1 7 12 6.9 ## 8 1998 1 8 11.2 8.6 ## 9 1998 1 9 13.9 8.5 ## 10 1998 1 10 14.5 3.6 Now I’ll replace the original temperature values directly with the Fahrenheit values. The following code modifies these columns accordingly. KAw %&gt;% mutate(Tmin = Tmin + 273.15, Tmax = Tmax + 273.15) ## # A tibble: 10 × 5 ## Year Month Day Tmax Tmin ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1998 1 1 281. 278. ## 2 1998 1 2 282. 278. ## 3 1998 1 3 284. 276. ## 4 1998 1 4 282. 278. ## 5 1998 1 5 281. 278. ## 6 1998 1 6 281. 278. ## 7 1998 1 7 285. 280. ## 8 1998 1 8 284. 282. ## 9 1998 1 9 287. 282. ## 10 1998 1 10 288. 277. There are many other interesting things you can do with mutate, so please check out the help file for more options. 9.6.6 arrange arrange is a function to sort data in data.frames or tibbles. KAw %&gt;% arrange(Tmax, Tmin) ## # A tibble: 10 × 5 ## Year Month Day Tmax Tmin ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1998 1 5 7.7 4.5 ## 2 1998 1 6 8.1 4.4 ## 3 1998 1 1 8.2 5.1 ## 4 1998 1 4 8.4 4.5 ## 5 1998 1 2 9.1 5 ## 6 1998 1 3 10.4 3.3 ## 7 1998 1 8 11.2 8.6 ## 8 1998 1 7 12 6.9 ## 9 1998 1 9 13.9 8.5 ## 10 1998 1 10 14.5 3.6 You can also sort in descending order. KAw %&gt;% arrange(desc(Tmax), Tmin) ## # A tibble: 10 × 5 ## Year Month Day Tmax Tmin ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1998 1 10 14.5 3.6 ## 2 1998 1 9 13.9 8.5 ## 3 1998 1 7 12 6.9 ## 4 1998 1 8 11.2 8.6 ## 5 1998 1 3 10.4 3.3 ## 6 1998 1 2 9.1 5 ## 7 1998 1 4 8.4 4.5 ## 8 1998 1 1 8.2 5.1 ## 9 1998 1 6 8.1 4.4 ## 10 1998 1 5 7.7 4.5 9.7 Loops In addition to the tidyverse functions, we have to talk about an important code structure that will allow us to get a lot of work done in an efficient manner: loops. A loop allows us to repeat the same operation many times without having to explicitly retype (or copy and paste) the code. More importantly, it allows us to run the same code while introducing certain modifications in every run. You can read detailed explanations on loops here, but I’ll give you the basics in this chapter. There are two basic types of loops: for loops and while loops. For both of them, we have to provide instructions that regulate the number of runs, as well as instructions on what to do in each of the runs. 9.7.1 For loops In a for loop, we provide explicit instructions on how many times the code within the loop should be run. This is usually specified by providing a vector or list of elements and instructing R to run the code for each of these elements. This means that the number of times the code is run equals the number of elements in the vector or list. We need a counter (often called i but can also be any other variable name) to keep track of which run we’re in. for (i in 1:3) print(&quot;Hello&quot;) ## [1] &quot;Hello&quot; ## [1] &quot;Hello&quot; ## [1] &quot;Hello&quot; This command ran the code three times, plotting the same output each time. We can make this structure more complex by providing multiple lines of code within winged brackets. addition &lt;- 1 for (i in 1:3) { addition &lt;- addition + 1 print(addition) } ## [1] 2 ## [1] 3 ## [1] 4 The code in this loop added 1 to the element addition (with an initial value of 1) in each iteration, and it printed the resulting value (note that you may have to explicitly instruct R to print such values, when the operation is embedded within a loop). We can add more flexibility to the operations by using the index i within the code block. addition &lt;- 1 for (i in 1:3) { addition &lt;- addition + i print(addition) } ## [1] 2 ## [1] 4 ## [1] 7 Now we added the respective value of i to the addition element in each of the runs. We can also use i in more creative ways. names &lt;- c(&quot;Paul&quot;, &quot;Mary&quot;, &quot;John&quot;) for (i in 1:3) { print(paste(&quot;Hello&quot;, names[i])) } ## [1] &quot;Hello Paul&quot; ## [1] &quot;Hello Mary&quot; ## [1] &quot;Hello John&quot; The counter doesn’t have to be numeric, but it can assume many other shapes, e.g. that of a string. We can therefore generate the same output as from the last code block by formulating this as follows: for (i in c(&quot;Paul&quot;, &quot;Mary&quot;, &quot;John&quot;)) { print(paste(&quot;Hello&quot;, i)) } ## [1] &quot;Hello Paul&quot; ## [1] &quot;Hello Mary&quot; ## [1] &quot;Hello John&quot; 9.7.2 While loops We can also specify the decision on whether to run a loop with a while statement. The code is then run, until the specified condition is no longer fulfilled. This only makes sense, of course, if the condition can change as a result of what happens inside the loop. cond &lt;- 5 while (cond&gt;0) { print(cond) cond &lt;- cond - 1 } ## [1] 5 ## [1] 4 ## [1] 3 ## [1] 2 ## [1] 1 As soon as cond reaches 0, the starting condition is no longer fulfilled, so that the code isn’t run again. Note that while loops can easily cause problems if the condition remains fulfilled regardless of what happens in the code block. Your code will then get hung up and needs to be cancelled manually. 9.8 apply functions In addition to loops, R has another elegant method for applying certain operations to multiple elements at the same time. Don’t ask me why, but this is often a much faster way of getting things done. Such operations are implemented by the functions from the apply family: apply, lapply and sapply. The two central arguments that need to be provided to these functions are the list of items to apply the operation to, and the operation itself. 9.8.1 sapply When you just want to apply an operation to a vector of elements, the easiest function to use is sapply. It only needs two arguments: the vector (X), and the function to be applied (FUN). To illustrate this, I’ll create a simple function, func, which just adds 1 to an object. func &lt;- function(x) x + 1 sapply(1:5, func) ## [1] 2 3 4 5 6 As you can see, the output is a vector of numbers that are 1 greater than the input vector. If we apply this function to a list of numbers, the output is a matrix (but the values are the same). sapply(list(1:5), func) ## [,1] ## [1,] 2 ## [2,] 3 ## [3,] 4 ## [4,] 5 ## [5,] 6 9.8.2 lapply If we want the output to be a list, we can use the lapply function. It interprets the input element X as a list and returns a list with as many elements as were provided in that list, with each one containing the output of applying FUN to the respective element. lapply(1:5, func) ## [[1]] ## [1] 2 ## ## [[2]] ## [1] 3 ## ## [[3]] ## [1] 4 ## ## [[4]] ## [1] 5 ## ## [[5]] ## [1] 6 Note that if the input element X is itself a list, this list is treated as one input element, with FUN applied to the entire list and the result returned as a single list element. It may be easier to look at an example to understand this. lapply(list(1:5), func) ## [[1]] ## [1] 2 3 4 5 6 9.8.3 apply The basic apply function is for applying functions to arrays, where we can operate either on the rows (MARGIN = 1) or on the columns (MARGIN = 1) of the array. We probably won’t use this much, so here are just some simple examples of what this function does. Feel free to look through the help file (or google - lots of helpful materials out there) to learn more about this. mat &lt;- matrix(c(1,1,1,2,2,2,3,3,3),c(3,3)) mat ## [,1] [,2] [,3] ## [1,] 1 2 3 ## [2,] 1 2 3 ## [3,] 1 2 3 apply(mat, MARGIN=1, sum) # adding up all the data in each row ## [1] 6 6 6 apply(mat, MARGIN=2, sum) # adding up all the data in each column ## [1] 3 6 9 Exercises on useful R tools Please document all results of the following assignments in your learning logbook. Based on the Winters_hours_gaps dataset, use magrittr pipes and functions of the tidyverse to accomplish the following: Convert the dataset into a tibble Select only the top 10 rows of the dataset Convert the tibble to a long format, with separate rows for Temp_gaps and Temp Use ggplot2 to plot Temp_gaps and Temp as facets (point or line plot) Convert the dataset back to the wide format Select only the following columns: Year, Month, Day and Temp Sort the dataset by the Temp column, in descending order For the Winter_hours_gaps dataset, write a for loop to convert all temperatures (Temp column) to degrees Fahrenheit Execute the same operation with a function from the apply family Now use the tidyverse function mutate to achieve the same outcome Voluntary: consider taking a look at the instruction materials on all these functions, which I linked above, as well as at other sources on the internet. There’s a lot more to discover here, with lots of potential for making your coding more elegant and easier - and possibly even more fun! "],["get_temp_data.html", "Chapter 10 Getting temperature data Learning goals for this lesson 10.1 Temperature data needs 10.2 The Global Summary of the Day database Exercises on getting temperature data", " Chapter 10 Getting temperature data Learning goals for this lesson Appreciate the need for daily temperature data Know how to get a list of promising weather stations contained in an international database Be able to download weather data using chillR functions Know how to convert downloaded data into chillR format 10.1 Temperature data needs Obviously, without temperature data we can’t do much phenology and chill modeling. This is a pretty critical input to all models we can make or may want to run. It also seems like an easy-to-find resource, doesn’t it? Well, you may be surprised by how difficult it is to get such data. While all countries in the world have official weather stations that record precisely the type of information we need, many are very protective of these data. Many national weather services sell such information (the collection of which was likely funded by taxpayer money) at rather high prices. If you only want to do a study on one location, you may be able to shell out that money, but this quickly becomes unrealistic, when you’re targeting a larger-scale analysis. On a personal note, I must say that I find it pretty outrageous that at a time where we should be making every effort to understand the impacts of climate change on our world and to find ways to adapt, weather services are putting up such access barriers. I really wonder how many climate-related studies that have been done turned out less useful than they could have been, had more data been easily and freely available. Well, back to the main story… To be clear, it’s of course preferable to have a high-quality dataset collected in the exact place that you want to analyze. If we don’t have such data, however, there are a few databases out there that we can draw on as an alternative option. chillR currently has the capability to access one global database, as well as one for California. There is certainly scope for expanding this capability, but let’s start working with what’s available now. 10.2 The Global Summary of the Day database An invaluable source of temperature data is the National Centers for Environmental Information (NCEI), formerly the National Climatic Data Center (NCDC) of the United States National Oceanic and Atmospheric Administration (NOAA), in particular their Global Summary of the Day (GSOD) database. That was a pretty long name, so let’s stick with the abbreviation GSOD. Check out the GSOD website to take a look at the interface: https://www.ncei.noaa.gov/access/search/data-search/global-summary-of-the-day. This interface used to be pretty confusing in the past - and I almost find it more confusing now. Fortunately, if you click on the Bulk downloads button, you can get to a place where you can directly access the weather data: https://www.ncei.noaa.gov/data/global-summary-of-the-day/access/. What we find here is, at first glance, even more inaccessible than the web interface, but at least we can recognize some structure now: All records are stored in separate files for each station and year, with the files named according to a code assigned to the weather stations. You could now download these records by hand, if you wanted to, but this would take a long time (if you want data for many years), and you’d first have to find out what station is of interest to you. Fortunately, I found a list of all the weather stations somewhere on NOAA’s website: ftp://ftp.ncdc.noaa.gov/pub/data/noaa/isd-history.csv, and I automated the tedious data download and assembling process in chillR. My attempt resulted in a reliable but fairly slow procedure, but a former participant of this module, Adrian Fülle, found a much more elegant - and much faster - way to achieve this. Let’s see how this works: There’s a single chillR function, handle_gsod(), that can take care of all data retrieval steps. Since there are multiple steps involved, we have to use the function’s action parameter to tell it what to do: 10.2.1 action=list_stations When used with this action, handle_gsod() retrieves the station list and sorts the stations based on their proximity to a set of coordinates we specify. Let’s look for stations around Bonn (Latitude= 50.73; Longitude= 7.10). I’ll also add a time interval of interest (1990-2020) to narrow the search. library(chillR) station_list&lt;-handle_gsod(action=&quot;list_stations&quot;, location=c(7.10,50.73), time_interval=c(1990,2020)) require(kableExtra) kable(station_list) %&gt;% kable_styling(&quot;striped&quot;, position = &quot;left&quot;, font_size = 8) chillR_code STATION.NAME CTRY Lat Long BEGIN END Distance Overlap_years Perc_interval_covered 10517099999 BONN/FRIESDORF(AUT) GM 50.700 7.150 19360102 19921231 4.86 3.00 10 10518099999 BONN-HARDTHOEHE GM 50.700 7.033 19750523 19971223 5.79 7.98 26 10519099999 BONN-ROLEBER GM 50.733 7.200 20010705 20081231 7.07 7.49 24 10513099999 KOLN BONN GM 50.866 7.143 19310101 20230729 15.43 31.00 100 10509099999 BUTZWEILERHOF(BAFB) GM 50.983 6.900 19780901 19950823 31.47 5.64 18 10502099999 NORVENICH GM 50.831 6.658 19730101 20230729 33.14 31.00 100 10514099999 MENDIG GM 50.366 7.315 19730102 19971231 43.26 8.00 26 10506099999 NUERBURG-BARWEILER GM 50.367 6.867 19950401 19971231 43.63 2.75 9 10508099999 BLANKENHEIM GM 50.450 6.650 19781002 19840504 44.56 0.00 0 10510099999 NUERBURG GM 50.333 6.950 19300901 19921231 45.42 3.00 10 10515099999 BENDORF GM 50.417 7.583 19310102 20030816 48.82 13.62 44 10504099999 EIFEL GM 50.650 6.283 20040501 20040501 58.41 0.00 0 10526099999 BAD MARIENBERG GM 50.667 7.967 19730101 20030816 61.65 13.62 44 10613099999 BUCHEL GM 50.174 7.063 19730101 20230729 61.90 31.00 100 10503099999 AACHEN/MERZBRUCK GM 50.817 6.183 19780901 19971212 65.40 7.95 26 10419099999 LUDENSCHEID &amp; GM 51.233 7.600 19270906 20030306 66.06 13.18 43 10400099999 DUSSELDORF GM 51.289 6.767 19310102 20230729 66.43 31.00 100 10616299999 SIEGERLAND GM 50.708 8.083 20040510 20230729 69.46 16.65 54 10418099999 LUEDENSCHEID GM 51.250 7.650 19940301 19971231 69.55 3.84 12 10437499999 MONCHENGLADBACH GM 51.230 6.504 19960715 20230729 69.61 24.47 79 10403099999 MOENCHENGLADBACH GM 51.233 6.500 19381001 19421031 70.05 0.00 0 10501099999 AACHEN GM 50.783 6.100 19280101 20030816 70.81 13.62 44 6496099999 ELSENBORN (MIL) BE 50.467 6.183 19840501 20230729 71.21 31.00 100 10409099999 ESSEN/MUELHEIM GM 51.400 6.967 19300414 19431231 75.12 0.00 0 10410099999 ESSEN/MULHEIM GM 51.400 6.967 19310101 20220408 75.12 31.00 100 This list contains the 25 closest stations to the location we entered, ordered by their distance to the target coordinates. This distance is shown in the distance column. The Overlap_years column shows the number of years that are available, and the Perc_interval_covered column the percentage of the target interval that is covered. Note that this is only based on the BEGIN and END dates in the table - it’s quite possible (and usually the case) that the dataset contains gaps, which sometimes cover almost the entire record. 10.2.2 action=\"download_weather\" When used with this option, the handle_gsod() function downloads the weather data for a particular station, based on a station-specific chillR_code (shown in the respective column of the table above). Rather than typing the code manually, we can refer to the code in the station_list. Let’s download the data for the 4th entry in the list, which looks like it covers most of the period we’re interested in. weather&lt;-handle_gsod(action=&quot;download_weather&quot;, location=station_list$chillR_code[4], time_interval=c(1990,2020)) The result of this operation is a list with two elements. Element 1 (weather[[1]]) is an indication of the database the data come from. Element 2 (weather[[2]]) is the actual dataset, which we can see here: weather[[1]][1:20,] X DATE Date Year Month Day Tmin Tmax Tmean Prec YEARMODA Tmin_source Tmax_source no_Tmin no_Tmax 1 1990-01-01 12:00:00 1990-01-01 12:00:00 1990 1 1 -1.000 1.000 0.000 0.000 19900101 original original FALSE FALSE 2 1990-01-02 12:00:00 1990-01-02 12:00:00 1990 1 2 0.000 2.000 1.000 0.000 19900102 original original FALSE FALSE 3 1990-01-03 12:00:00 1990-01-03 12:00:00 1990 1 3 -0.389 2.000 0.722 0.000 19900103 original original FALSE FALSE 4 1990-01-04 12:00:00 1990-01-04 12:00:00 1990 1 4 -1.111 2.000 -0.056 0.000 19900104 original original FALSE FALSE 5 1990-01-05 12:00:00 1990-01-05 12:00:00 1990 1 5 -1.111 3.111 1.556 0.000 19900105 original original FALSE FALSE 6 1990-01-06 12:00:00 1990-01-06 12:00:00 1990 1 6 0.000 2.389 1.333 0.000 19900106 original original FALSE FALSE 7 1990-01-07 12:00:00 1990-01-07 12:00:00 1990 1 7 -0.111 4.278 1.056 0.000 19900107 original original FALSE FALSE 8 1990-01-08 12:00:00 1990-01-08 12:00:00 1990 1 8 -0.111 7.000 3.278 0.000 19900108 original original FALSE FALSE 9 1990-01-09 12:00:00 1990-01-09 12:00:00 1990 1 9 3.778 8.000 5.333 0.508 19900109 original original FALSE FALSE 10 1990-01-10 12:00:00 1990-01-10 12:00:00 1990 1 10 3.000 6.000 4.556 1.016 19900110 original original FALSE FALSE 11 1990-01-11 12:00:00 1990-01-11 12:00:00 1990 1 11 3.278 7.000 5.167 0.254 19900111 original original FALSE FALSE 12 1990-01-12 12:00:00 1990-01-12 12:00:00 1990 1 12 -1.000 5.222 1.778 0.000 19900112 original original FALSE FALSE 13 1990-01-13 12:00:00 1990-01-13 12:00:00 1990 1 13 -1.278 4.000 1.389 0.000 19900113 original original FALSE FALSE 14 1990-01-14 12:00:00 1990-01-14 12:00:00 1990 1 14 -0.222 5.000 3.167 0.000 19900114 original original FALSE FALSE 15 1990-01-15 12:00:00 1990-01-15 12:00:00 1990 1 15 0.889 9.000 4.556 1.016 19900115 original original FALSE FALSE 16 1990-01-16 12:00:00 1990-01-16 12:00:00 1990 1 16 6.222 11.000 9.944 0.000 19900116 original original FALSE FALSE 17 1990-01-17 12:00:00 1990-01-17 12:00:00 1990 1 17 1.000 11.000 8.500 0.000 19900117 original original FALSE FALSE 18 1990-01-18 12:00:00 1990-01-18 12:00:00 1990 1 18 -1.000 7.000 2.722 0.254 19900118 original original FALSE FALSE 19 1990-01-19 12:00:00 1990-01-19 12:00:00 1990 1 19 2.000 7.111 4.611 0.000 19900119 original original FALSE FALSE 20 1990-01-20 12:00:00 1990-01-20 12:00:00 1990 1 20 4.000 8.500 6.056 2.286 19900120 original original FALSE FALSE This still looks pretty complicated, and it contains a lot of information we don’t need. chillR therefore contains a function to simplify this record. Note, however, that this removes a lot of variables you may be interested in. More importantly, this also removes quality flags, which may indicate that particular records aren’t reliable. I’ve generously ignored this so far, but there’s room for improvement here. 10.2.3 downloaded weather as action argument This way of calling handle_gsod() serves to clean the dataset and convert it into a format that chillR can easily handle cleaned_weather&lt;-handle_gsod(weather) cleaned_weather[[1]][1:20,] Date Year Month Day Tmin Tmax Tmean Prec 1990-01-01 12:00:00 1990 1 1 -1.000 1.000 0.000 0.000 1990-01-02 12:00:00 1990 1 2 0.000 2.000 1.000 0.000 1990-01-03 12:00:00 1990 1 3 -0.389 2.000 0.722 0.000 1990-01-04 12:00:00 1990 1 4 -1.111 2.000 -0.056 0.000 1990-01-05 12:00:00 1990 1 5 -1.111 3.111 1.556 0.000 1990-01-06 12:00:00 1990 1 6 0.000 2.389 1.333 0.000 1990-01-07 12:00:00 1990 1 7 -0.111 4.278 1.056 0.000 1990-01-08 12:00:00 1990 1 8 -0.111 7.000 3.278 0.000 1990-01-09 12:00:00 1990 1 9 3.778 8.000 5.333 0.508 1990-01-10 12:00:00 1990 1 10 3.000 6.000 4.556 1.016 1990-01-11 12:00:00 1990 1 11 3.278 7.000 5.167 0.254 1990-01-12 12:00:00 1990 1 12 -1.000 5.222 1.778 0.000 1990-01-13 12:00:00 1990 1 13 -1.278 4.000 1.389 0.000 1990-01-14 12:00:00 1990 1 14 -0.222 5.000 3.167 0.000 1990-01-15 12:00:00 1990 1 15 0.889 9.000 4.556 1.016 1990-01-16 12:00:00 1990 1 16 6.222 11.000 9.944 0.000 1990-01-17 12:00:00 1990 1 17 1.000 11.000 8.500 0.000 1990-01-18 12:00:00 1990 1 18 -1.000 7.000 2.722 0.254 1990-01-19 12:00:00 1990 1 19 2.000 7.111 4.611 0.000 1990-01-20 12:00:00 1990 1 20 4.000 8.500 6.056 2.286 Note that the reason for many of the strange numbers in these records is that the original database stores them in degrees Fahrenheit, so that they had to be converted to degrees Celsius. That often creates ugly numbers, but it’s not hard: \\(Temperature[°C]=(Temperature[°F]-32)\\cdot\\frac{5}{9}\\) We now have a temperature record in a format that we can easily work with in chillR. Upon closer inspection, however, you’ll notice that this dataset has pretty substantial gaps, including several entire years of missing data. How can we deal with this? Let’s find out in the lesson on Filling gaps in temperature records. Note that chillR has a pretty similar function to download data from the California Irrigation Management Information System (CIMIS). There’s surely room for improvement here. There’s a lot more data out there that chillR could have a download function for. Now let’s save the files we generated here, so that we can use them in the upcoming chapters: write.csv(station_list,&quot;data/station_list.csv&quot;,row.names=FALSE) write.csv(weather[[1]],&quot;data/Bonn_raw_weather.csv&quot;,row.names=FALSE) write.csv(cleaned_weather[[1]],&quot;data/Bonn_chillR_weather.csv&quot;,row.names=FALSE) Exercises on getting temperature data Please document all results of the following assignments in your learning logbook. Choose a location of interest and find the 25 closest weather stations using the handle_gsod function Download weather data for the most promising station on the list Convert the weather data into chillR format "],["filling-gaps-in-temperature-records.html", "Chapter 11 Filling gaps in temperature records Learning goals for this lesson 11.1 Gaps 11.2 Filling short gaps in daily records 11.3 Filling long gaps in daily records 11.4 Filling gaps in hourly records Exercises on filling gaps", " Chapter 11 Filling gaps in temperature records Learning goals for this lesson see why having gaps in records can be quite problematic learn about (too?) simple ways to fill gaps in daily temperature records learn how to use data from auxiliary weather stations to fill gaps in daily temperature records learn about a creative way to close gaps in hourly temperature records 11.1 Gaps There’s a lot of weather data out there, but most of it isn’t perfect. Lots of things can go wrong when recording temperature data, including malfunctioning equipment, flat batteries, power cuts or lack of maintenance. Data archiving, transmission and storage in a database presents the next hurdle. Many datasets therefore have gaps that can be very annoying when you’re trying to model agroclimatic conditions. Many scientific methods don’t deal very well with missing data. So we need ways of filling such gaps. 11.2 Filling short gaps in daily records Weather records may be largely complete, except for isolated incidences of missing daily minimum or maximum temperatures. In such cases, we may get away with simple linear interpolation. This means, we take the last recorded value before a gaps and the first after the gap and compute the average. We can use equivalent procedures for slightly longer gaps (e.g. 2-3 days), and possibly even a few more (even though we should now be starting to feel a bit uneasy about this). Obviously, the longer the gaps, the more dubious this practice becomes. In case gaps extend to several weeks or even months, linear interpolation, which simply connects the start and end points of the gap by a straight line, may miss important features of the local temperature dynamics. In the extreme case, where we’re missing an entire year of data, such linear interpolation would miss entire seasons, producing unacceptable errors. Yet chillR has a function to implement such simple interpolation - interpolate_gaps(). library(chillR) library(tidyverse) weather &lt;- KA_weather %&gt;% make_all_day_table() Tmin_int &lt;- interpolate_gaps(weather[,&quot;Tmin&quot;]) weather &lt;- weather %&gt;% mutate(Tmin = Tmin_int$interp, Tmin_interpolated = Tmin_int$missing) Tmax_int &lt;- interpolate_gaps(weather[,&quot;Tmax&quot;]) weather &lt;- weather %&gt;% mutate(Tmax = Tmax_int$interp, Tmax_interpolated = Tmax_int$missing) The fix_weather() function in chillR uses the same procedure. If you run this without any additional arguments (just fix_weather(weather)), this function assumes you’re trying to linearly interpolate all gaps in the Tmin and Tmax columns. If entire days are missing in the records, new lines are added for these days (using the make_all_day_table() function). You can also specify the range of years to apply this procedure for (by specifying start_year and end_year), the dates to work on (start_date and end_date - these are in Julian days, i.e. days of the year) and the names of columns you want to work on (needed if these are different from Tmin and Tmax) # add an extra day to the KA_weather dataset that is not connected to the days that are already there. # this creates a large gap, which we can then interpolate KA_weather_gap &lt;- rbind(KA_weather, c(Year = 2011, Month = 3, Day = 3, Tmax = 26, Tmin = 14)) # fill in the gaps between Julian date 300 (late October) and 100 (early April), only returning data between 2000 and 2011 fixed_winter_days &lt;- KA_weather_gap %&gt;% fix_weather(start_year = 2000, end_year = 2011, start_date = 300, end_date = 100) # fill in all gaps fixed_all_days &lt;- KA_weather_gap %&gt;% fix_weather() The fix_weather() function produces a list with two outputs: weather: a data.frame with the interpolated weather data, now including columns no_Tmin and no_Tmax, which contain TRUE for rows where the respective values were originally missing (FALSE otherwise). QC: a quality control object that summarizes how many values were interpolated for each season. Here’s how the QC elements look for the two interpolated datasets we just created: fixed_winter_days$QC Table 11.1: Table 11.2: Quality control summary produced by fix_weather(), with only winter days interpolated Season End_year Season_days Data_days Missing_Tmin Missing_Tmax Incomplete_days Perc_complete 1999/2000 2000 166 100 66 66 66 60.2 2000/2001 2001 167 167 0 0 0 100.0 2001/2002 2002 166 166 0 0 0 100.0 2002/2003 2003 166 166 0 0 0 100.0 2003/2004 2004 166 166 0 0 0 100.0 2004/2005 2005 167 167 0 0 0 100.0 2005/2006 2006 166 166 0 0 0 100.0 2006/2007 2007 166 166 0 0 0 100.0 2007/2008 2008 166 166 0 0 0 100.0 2008/2009 2009 167 167 0 0 0 100.0 2009/2010 2010 166 166 0 0 0 100.0 2010/2011 2011 166 128 165 165 165 0.6 fixed_all_days$QC Table 11.3: Table 11.4: Quality control summary produced by fix_weather(), with all days interpolated Season End_year Season_days Data_days Missing_Tmin Missing_Tmax Incomplete_days Perc_complete 1997/1998 1998 365 365 0 0 0 100.0 1998/1999 1999 365 365 0 0 0 100.0 1999/2000 2000 366 366 0 0 0 100.0 2000/2001 2001 365 365 0 0 0 100.0 2001/2002 2002 365 365 0 0 0 100.0 2002/2003 2003 365 365 0 0 0 100.0 2003/2004 2004 366 366 0 0 0 100.0 2004/2005 2005 365 365 0 0 0 100.0 2005/2006 2006 365 365 0 0 0 100.0 2006/2007 2007 365 365 0 0 0 100.0 2007/2008 2008 366 366 0 0 0 100.0 2008/2009 2009 365 365 0 0 0 100.0 2009/2010 2010 365 365 214 214 214 41.4 2010/2011 2011 365 62 364 364 364 0.3 As indicated above, linear interpolation is usually acceptable for short gaps in the records, but it gets increasingly less convincing, when the gaps are longer. Here’s a quick demonstration of this: gap_weather &lt;- KA_weather[200:305,] gap_weather[,&quot;Tmin_observed&quot;] &lt;- gap_weather$Tmin gap_weather$Tmin[c(2,4:5,7:9,11:14,16:20,22:27,29:35, 37:44,46:54,56:65,67:77,79:90,92:104)] &lt;- NA fixed_gaps &lt;- fix_weather(gap_weather)$weather ggplot(data=fixed_gaps, aes(DATE,Tmin_observed)) + geom_line(lwd=1.3) + xlab(&quot;Date&quot;) + ylab(&quot;Daily minimum temperature (°C)&quot;) + geom_line(data=fixed_gaps,aes(DATE,Tmin),col=&quot;red&quot;,lwd=1.3) The plot above shows the originally measured values in black and the interpolated values in red. To create gaps in the record for interpolation, I removed values from the original dataset, starting with gaps of length==1 on the left, and ending up with 13 missing values on the right. As you see, temperature dynamics are captured quite well on the left, but no longer very well on the right. Here’s how far off we are: fixed_gaps[,&quot;error&quot;] &lt;- abs(fixed_gaps$Tmin - fixed_gaps$Tmin_observed) ggplot(data=fixed_gaps, aes(DATE,error)) + geom_line(lwd=1.3) + xlab(&quot;Date&quot;) + ylab(&quot;Error introduced by interpolation (°C)&quot;) + geom_point(data=fixed_gaps[which(!fixed_gaps$no_Tmin),], aes(DATE,error),col=&quot;red&quot;,cex=3) How big the errors get obviously depends on the nature of the dataset - was there a lot of variation during the period of interest, or not? Yet we see a tendency here of errors getting bigger and bigger with increasing gap sizes. Of course for the non-gap points (shown in red in the plot), the error is zero, but especially in the middle of the larger gaps, we can be quite far off from what actually happened. For large gaps, we need a better procedure! 11.3 Filling long gaps in daily records Long gaps in temperature records are a problem - and we can’t make this go away entirely. To stress the obvious again: We can’t know exactly what the temperatures were in a given location at a particular time, if nobody measured them. But we can make pretty good guesses. For short gaps, linear interpolation may be enough. We could now also experiment with more complex interpolation algorithms, but this is not the direction I want to take here. Instead, let’s try to look for additional data that can help us deal with this challenge. We’ve already learned about one good source of temperature data, and of course there are lots of other records out there. Chances are that, unless we’re working way back in the past, or on a remote island, we can find another weather station that is close enough to be in a climatically comparable setting. Some researchers have identified such stations and then simply used the data from there to fill gaps for the site of interest. This (as far as I understand it) is the preferred way of dealing with gaps in records in the CIMIS network in California (at least this used to be the default option on their website). This may work ok, if the auxiliary station is in a very similar climatic setting, but it will already introduce an error if we’re dealing with some elevation differences, or with other landscape features that have climatic effects (e.g. lakes, sea, forest). Such features, as well as topography, can modulate temperatures at a particular place in a way that makes them poor proxies of temperatures in another location. chillR contains a function, patch_weather(), that can fill gaps in a weather record based on a list of weather datasets from auxiliary stations. This function can test for (some) biases, correct data for bias in mean temperatures, and use the result to fill gaps in the record for the location of interest. Let’s try to fill gaps in the dataset for Bonn that we downloaded in the Getting temperature data lesson. Bonn &lt;- read.csv(&quot;data/Bonn_chillR_weather.csv&quot;) Bonn_QC &lt;- fix_weather(Bonn)$QC Bonn_QC Table 11.5: Table 11.6: Quality control summary produced by fix_weather() Season End_year Season_days Data_days Missing_Tmin Missing_Tmax Incomplete_days Perc_complete 1989/1990 1990 365 365 0 0 0 100.0 1990/1991 1991 365 365 0 0 0 100.0 1991/1992 1992 366 366 0 0 0 100.0 1992/1993 1993 365 365 0 0 0 100.0 1993/1994 1994 365 365 0 0 0 100.0 1994/1995 1995 365 365 0 0 0 100.0 1995/1996 1996 366 366 0 0 0 100.0 1996/1997 1997 365 365 0 0 0 100.0 1997/1998 1998 365 365 4 4 4 98.9 1998/1999 1999 365 365 365 365 365 0.0 1999/2000 2000 366 366 366 366 366 0.0 2000/2001 2001 365 365 365 365 365 0.0 2001/2002 2002 365 365 365 365 365 0.0 2002/2003 2003 365 365 316 316 316 13.4 2003/2004 2004 366 366 366 366 366 0.0 2004/2005 2005 365 365 0 0 0 100.0 2005/2006 2006 365 365 0 0 0 100.0 2006/2007 2007 365 365 0 0 0 100.0 2007/2008 2008 366 366 0 0 0 100.0 2008/2009 2009 365 365 0 0 0 100.0 2009/2010 2010 365 365 0 0 0 100.0 2010/2011 2011 365 365 0 0 0 100.0 2011/2012 2012 366 366 0 0 0 100.0 2012/2013 2013 365 365 0 0 0 100.0 2013/2014 2014 365 365 0 0 0 100.0 2014/2015 2015 365 365 0 0 0 100.0 2015/2016 2016 366 366 0 0 0 100.0 2016/2017 2017 365 365 0 0 0 100.0 2017/2018 2018 365 365 0 0 0 100.0 2018/2019 2019 365 365 0 0 0 100.0 2019/2020 2020 366 366 0 0 0 100.0 As you see, this dataset has substantial gaps between 1998 and 2004 and in 2008 (almost all values missing), and some shorter gaps in 2015, 2018 and 2020. We’ll now need data from other weather stations in the neighborhood. To find them, we can again use the handle_gsod() function: station_list &lt;- handle_gsod(action=&quot;list_stations&quot;, location=c(7.10,50.73), time_interval=c(1990,2020)) station_list Table 11.7: Table 11.8: List of GSOD weather stations close to Bonn chillR_code STATION.NAME CTRY Lat Long BEGIN END Distance Overlap_years Perc_interval_covered 10517099999 BONN/FRIESDORF(AUT) GM 50.700 7.150 19360102 19921231 4.86 3.00 10 10518099999 BONN-HARDTHOEHE GM 50.700 7.033 19750523 19971223 5.79 7.98 26 10519099999 BONN-ROLEBER GM 50.733 7.200 20010705 20081231 7.07 7.49 24 10513099999 KOLN BONN GM 50.866 7.143 19310101 20230729 15.43 31.00 100 10509099999 BUTZWEILERHOF(BAFB) GM 50.983 6.900 19780901 19950823 31.47 5.64 18 10502099999 NORVENICH GM 50.831 6.658 19730101 20230729 33.14 31.00 100 10514099999 MENDIG GM 50.366 7.315 19730102 19971231 43.26 8.00 26 10506099999 NUERBURG-BARWEILER GM 50.367 6.867 19950401 19971231 43.63 2.75 9 10508099999 BLANKENHEIM GM 50.450 6.650 19781002 19840504 44.56 0.00 0 10510099999 NUERBURG GM 50.333 6.950 19300901 19921231 45.42 3.00 10 10515099999 BENDORF GM 50.417 7.583 19310102 20030816 48.82 13.62 44 10504099999 EIFEL GM 50.650 6.283 20040501 20040501 58.41 0.00 0 10526099999 BAD MARIENBERG GM 50.667 7.967 19730101 20030816 61.65 13.62 44 10613099999 BUCHEL GM 50.174 7.063 19730101 20230729 61.90 31.00 100 10503099999 AACHEN/MERZBRUCK GM 50.817 6.183 19780901 19971212 65.40 7.95 26 10419099999 LUDENSCHEID &amp; GM 51.233 7.600 19270906 20030306 66.06 13.18 43 10400099999 DUSSELDORF GM 51.289 6.767 19310102 20230729 66.43 31.00 100 10616299999 SIEGERLAND GM 50.708 8.083 20040510 20230729 69.46 16.65 54 10418099999 LUEDENSCHEID GM 51.250 7.650 19940301 19971231 69.55 3.84 12 10437499999 MONCHENGLADBACH GM 51.230 6.504 19960715 20230729 69.61 24.47 79 10403099999 MOENCHENGLADBACH GM 51.233 6.500 19381001 19421031 70.05 0.00 0 10501099999 AACHEN GM 50.783 6.100 19280101 20030816 70.81 13.62 44 6496099999 ELSENBORN (MIL) BE 50.467 6.183 19840501 20230729 71.21 31.00 100 10409099999 ESSEN/MUELHEIM GM 51.400 6.967 19300414 19431231 75.12 0.00 0 10410099999 ESSEN/MULHEIM GM 51.400 6.967 19310101 20220408 75.12 31.00 100 We can see that many of the listed stations aren’t very useful for us, because they only overlap with the record we already have for a few years, in some cases not at all. So it’s quite possible that none of these stations can help us fill all the gaps in the temperature data for Bonn. But maybe we can combine data from multiple auxiliary stations to close all the gaps. Stations that look promising are BONN-HARDTHOEHE, BONN-ROLEBER, and NORVENICH. So let’s download these and store them in a list. As of chillR version 0.74, the handle_gsod function can download multiple files at ones, returning a named list of station records. Let’s use this function to download the records for the stations of interest (positions 2, 3 and 6 in the station_list). patch_weather&lt;- handle_gsod(action = &quot;download_weather&quot;, location = as.character(station_list$chillR_code[c(2,3,6)]), time_interval = c(1990,2020)) %&gt;% handle_gsod() Now we have a list of weather records that are potentially useful for filling gaps in our record for Bonn. We can now use the patch_daily_temperatures() function to implement this. patched &lt;- patch_daily_temperatures(weather = Bonn, patch_weather = patch_weather) You can take a look at what happened by looking at the statistics element of the patched object (call patched$statistics): patched$statistics[[1]] Table 11.9: Table 11.10: Patch statistics for NORVENICH mean_bias stdev_bias filled gaps_remain Tmin -0.307 1.304 2146 1 Tmax 0.202 1.154 2146 1 patched$statistics[[2]] Table 11.11: Table 11.12: Patch statistics for BONN-HARDTHOEHE mean_bias stdev_bias filled gaps_remain Tmin -1.871 2.080 0 1 Tmax 1.466 1.427 0 1 patched$statistics[[3]] Table 11.13: Table 11.14: Patch statistics for BONN-ROLEBER mean_bias stdev_bias filled gaps_remain Tmin -0.546 1.186 0 1 Tmax 1.314 1.089 0 1 Here we see an analysis of how similar the temperature records (separately for Tmin and Tmax) were between each auxiliary station and our station of interest in Bonn, based on days for which both stations had data. Besides the number of days for which information was taken from each auxiliary station (filled) and the number of gaps that remained afterwards (gaps_remain), we see two quality statistics: the mean bias (mean_bias), i.e. the mean temperature difference. the standard deviation of the daily differences (stdev_bias). The mean_bias is easy to address by adding or subtracting the respective value, when we transfer daily temperature values from one station to the other. The patch_daily_temperatures() function does that for us automatically. We may still want to set some limit to how much we can accept here, but in principle, this can be addressed. What is more problematic is the stdev_bias metric. This basically indicates the extent of additional (possibly unsystematic) differences between stations. I don’t know if this can be adjusted (I haven’t figured it out yet), so for now we should treat this as an exclusion criterion (i.e. if stdev_bias is above a certain value, we reject the station). Let’s set some limits for both metrics, which we can pass as arguments to patch_daily_temperatures() (using the max_mean_bias and max_stdev_bias parameters). Let’s cap the mean_bias at 1 °C and the stdev_bias at 2°C, and then look at the statistics again. patched &lt;- patch_daily_temperatures(weather = Bonn, patch_weather = patch_weather, max_mean_bias = 1, max_stdev_bias = 2) patched$statistics[[1]] Table 11.15: Table 11.16: Patch statistics for NORVENICH mean_bias stdev_bias filled gaps_remain Tmin -0.307 1.304 2146 1 Tmax 0.202 1.154 2146 1 patched$statistics[[2]] Table 11.17: Table 11.18: Patch statistics for BONN-HARDTHOEHE mean_bias stdev_bias filled gaps_remain Tmin -1.871 2.080 0 1 Tmax 1.466 1.427 0 1 patched$statistics[[3]] Table 11.19: Table 11.20: Patch statistics for BONN-ROLEBER mean_bias stdev_bias filled gaps_remain Tmin -0.546 1.186 0 1 Tmax 1.314 1.089 0 1 We can see that all records from BONN-HARDTHOEHE, as well as the Tmax records from BONN-ROLEBER were rejected, because they didn’t pass our mean_bias filter. Still, since the data from NORVENICH are pretty good, we were able to fill 2146 gaps for Tmin and 2146 for Tmax. Only 1 and 1 gaps remain for Tmin and Tmax, respectively. Let’s use the fix_weather() function to take a look at where the remaining gaps are: post_patch_stats &lt;- fix_weather(patched)$QC post_patch_stats Table 11.21: Table 11.22: Data completeness table for the weather record from Bonn, after applying the patch procedure Season End_year Season_days Data_days Missing_Tmin Missing_Tmax Incomplete_days Perc_complete 1989/1990 1990 365 365 0 0 0 100.0 1990/1991 1991 365 365 0 0 0 100.0 1991/1992 1992 366 366 0 0 0 100.0 1992/1993 1993 365 365 0 0 0 100.0 1993/1994 1994 365 365 0 0 0 100.0 1994/1995 1995 365 365 0 0 0 100.0 1995/1996 1996 366 366 0 0 0 100.0 1996/1997 1997 365 365 0 0 0 100.0 1997/1998 1998 365 365 0 0 0 100.0 1998/1999 1999 365 365 1 1 1 99.7 1999/2000 2000 366 366 0 0 0 100.0 2000/2001 2001 365 365 0 0 0 100.0 2001/2002 2002 365 365 0 0 0 100.0 2002/2003 2003 365 365 0 0 0 100.0 2003/2004 2004 366 366 0 0 0 100.0 2004/2005 2005 365 365 0 0 0 100.0 2005/2006 2006 365 365 0 0 0 100.0 2006/2007 2007 365 365 0 0 0 100.0 2007/2008 2008 366 366 0 0 0 100.0 2008/2009 2009 365 365 0 0 0 100.0 2009/2010 2010 365 365 0 0 0 100.0 2010/2011 2011 365 365 0 0 0 100.0 2011/2012 2012 366 366 0 0 0 100.0 2012/2013 2013 365 365 0 0 0 100.0 2013/2014 2014 365 365 0 0 0 100.0 2014/2015 2015 365 365 0 0 0 100.0 2015/2016 2016 366 366 0 0 0 100.0 2016/2017 2017 365 365 0 0 0 100.0 2017/2018 2018 365 365 0 0 0 100.0 2018/2019 2019 365 365 0 0 0 100.0 2019/2020 2020 366 366 0 0 0 100.0 We can see that we managed to fill almost all gaps, with only data for 1 day missing after the patching. It seems safe to use linear interpolation for such a short gap. The fix_weather() function can do this for us. Bonn_weather&lt;-fix_weather(patched) 11.3.1 Bias-correction for shorter intervals In the patch_daily_temperatures function, the bias correction is based on the average difference between the temperatures of a pair of weather stations over the entire year. It is possible, however, that the between-station bias varies throughout the year. We may then find that a particular station is a useful data source for temperatures in certain seasons but not in others. If we allow for different bias corrections during different parts of the year, we may also find that we can get better approximations, i.e. smaller biases than if we look at the entire year. The patch_daily_temps (not ...temperatures) function allows us to do this. As a default, it evaluates temperature records on a monthly basis, i.e. it makes separate between-station comparisons for the temperatures of each calendar month. It can then take separate decisions on whether a potential auxiliary station is a useful proxy for temperatures in this monthly interval, and it can apply month-specific bias correction. patched_monthly &lt;- patch_daily_temps(weather = Bonn, patch_weather = patch_weather, max_mean_bias = 1, max_stdev_bias = 2, time_interval = &quot;month&quot;) Here’s the finding for minimum temperatures for the NORVENICH station. patched_monthly$statistics$Tmin$NORVENICH Table 11.23: Table 11.24: Bias analysis table for the first station in the proxy station list, showing biases on a monthly level Interval Total_days Overlap_days Mean_bias Stdev_bias Gaps_before Filled Gaps_remain 1 961 773 0.184 1.260 186 185 1 2 961 774 0.281 1.242 186 186 0 3 876 706 0.269 1.248 170 170 0 4 961 775 0.253 1.427 186 186 0 5 930 758 0.509 1.431 166 166 0 6 961 801 0.373 1.238 158 158 0 7 930 749 0.396 1.210 180 180 0 8 961 781 0.480 1.305 179 179 0 9 961 774 0.529 1.302 186 186 0 10 930 750 0.205 1.264 180 180 0 11 961 775 0.098 1.307 186 186 0 12 930 745 0.101 1.308 184 184 0 We now see that the mean bias really varies quite a bit, so that we probably benefit from a month-specific bias correction. The time_interval parameter of the patch_daily_temps function allows us to specify the interval we want to use. Intervals can be month or week but also multiples of these, such as 10 days or 2 weeks. Note that the function will start counting these intervals on 1st January in each year. This may lead to intervals at the end of the year that are smaller than the interval you selected (this generates warnings, as you can see below). Note also that the smaller these intervals get, the less data can be used for determining the bias. Especially for short time series, a very short interval may therefore not be desirable. patched_2weeks &lt;- patch_daily_temps(weather = Bonn, patch_weather = patch_weather, max_mean_bias = 1, max_stdev_bias = 2, time_interval = &quot;2 weeks&quot;) ## Warning in patch_daily_temps(weather = Bonn, patch_weather = patch_weather, : ## The number of days in the last interval is often a lot smaller than in other ## intervals. Consider changing the time interval. ## Warning in patch_daily_temps(weather = Bonn, patch_weather = patch_weather, : ## The number of days in the last interval is often a lot smaller than in other ## intervals. Consider changing the time interval. ## Warning in patch_daily_temps(weather = Bonn, patch_weather = patch_weather, : ## The number of days in the last interval is often a lot smaller than in other ## intervals. Consider changing the time interval. To illustrate the effects of this, let’s create 5000 gaps in the Bonn weather record and fill them with proxy data using annual, monthly and bi-weekly intervals for the bias evaluation. We can plot the resulting errors with ggplot2 using a violin plot. Gaps &lt;- sample(seq(1:nrow(Bonn)), size = 5000, replace = FALSE) Bonn_gaps &lt;- Bonn %&gt;% mutate(obs_Tmin=Tmin, obs_Tmax=Tmax) Bonn_gaps$Tmin[Gaps] &lt;- NA Bonn_gaps$Tmax[Gaps] &lt;- NA patch_annual &lt;- patch_daily_temps(weather = Bonn_gaps, patch_weather = patch_weather, max_mean_bias = 1, max_stdev_bias = 2, time_interval = &quot;year&quot;) patch_month &lt;- patch_daily_temps(weather = Bonn_gaps, patch_weather = patch_weather, max_mean_bias = 1, max_stdev_bias = 2, time_interval = &quot;month&quot;) patch_2weeks &lt;- patch_daily_temps(weather = Bonn_gaps, patch_weather = patch_weather, max_mean_bias = 1, max_stdev_bias = 2, time_interval = &quot;2 weeks&quot;) Bonn_gaps[,&quot;Tmin_annual&quot;] &lt;- Bonn_gaps$obs_Tmin - patch_annual$weather$Tmin Bonn_gaps[,&quot;Tmax_annual&quot;] &lt;- Bonn_gaps$obs_Tmax - patch_annual$weather$Tmax Bonn_gaps[,&quot;Tmin_month&quot;] &lt;- Bonn_gaps$obs_Tmin - patch_month$weather$Tmin Bonn_gaps[,&quot;Tmax_month&quot;] &lt;- Bonn_gaps$obs_Tmax - patch_month$weather$Tmax Bonn_gaps[,&quot;Tmin_2weeks&quot;] &lt;- Bonn_gaps$obs_Tmin - patch_2weeks$weather$Tmin Bonn_gaps[,&quot;Tmax_2weeks&quot;] &lt;- Bonn_gaps$obs_Tmax - patch_2weeks$weather$Tmax Interval_eval &lt;- Bonn_gaps %&gt;% filter(is.na(Tmin)) %&gt;% pivot_longer(Tmin_annual:Tmax_2weeks) %&gt;% mutate(Type=factor(name, levels = c(&quot;Tmin_annual&quot;, &quot;Tmin_month&quot;, &quot;Tmin_2weeks&quot;, &quot;Tmax_annual&quot;, &quot;Tmax_month&quot;, &quot;Tmax_2weeks&quot;)) ) ggplot(Interval_eval, aes(Type,value)) + geom_violin(draw_quantiles = c(0.25,0.5,0.75)) + xlab(&quot;Variable and bias evaluation interval&quot;) + ylab(&quot;Prediction error&quot;) We can also evaluate the mean daily error. error_eval &lt;- data.frame(Variable = c(rep(&quot;Tmin&quot;,3),rep(&quot;Tmax&quot;,3)), Interval = rep(c(&quot;Year&quot;,&quot;Month&quot;,&quot;Two weeks&quot;),2), Error = c( mean(abs(Bonn_gaps$Tmin_annual[is.na(Bonn_gaps$Tmin)]),na.rm=TRUE), mean(abs(Bonn_gaps$Tmin_month[is.na(Bonn_gaps$Tmin)]),na.rm=TRUE), mean(abs(Bonn_gaps$Tmin_2weeks[is.na(Bonn_gaps$Tmin)]),na.rm=TRUE), mean(abs(Bonn_gaps$Tmax_annual[is.na(Bonn_gaps$Tmin)]),na.rm=TRUE), mean(abs(Bonn_gaps$Tmax_month[is.na(Bonn_gaps$Tmin)]),na.rm=TRUE), mean(abs(Bonn_gaps$Tmax_2weeks[is.na(Bonn_gaps$Tmin)]),na.rm=TRUE)) ) error_eval Table 11.25: Table 11.26: Mean absolute prediction error for minimum and maximum temperature when using different time intervals as a basis for correcting for between-station biases Variable Interval Error Tmin Year 0.9892717 Tmin Month 0.9870765 Tmin Two weeks 0.9869664 Tmax Year 0.8178748 Tmax Month 0.8015675 Tmax Two weeks 0.8047342 As cou can see, the improvement wasn’t very impressive here, possibly because the stations we used are quite close to each other and the weather doesn’t differ much between them. 11.3.2 Saving the data for later Now we should make sure that we save one of these files for later. I’ll choose the dataset where we based the bias correction on monthly intervals. We still need to interpolate the one missing day, before we can save this. monthly_bias_fixed &lt;- fix_weather(patched_monthly) Now we have a fairly convincing long-term record (from 1990 to 2020) for Bonn, with no more gaps remaining. Let’s save this now. write.csv(monthly_bias_fixed$weather, &quot;data/Bonn_weather.csv&quot;) Note that I only saved the weather element. This is a data.frame that can easily be saved as a spreadsheet table (.csv file). We can also save lists (including the QC element in this case), but that’s a bit more complicated, so let’s save this for later. 11.4 Filling gaps in hourly records When it comes to gaps, hourly records are a lot harder to handle, because linear interpolation usually isn’t an option. This works for very short gaps only, but it’s probably quite obvious that for gaps that extend over multiple days, you can’t just connect the start and end points with a straight line. This makes it very hard to make use of hourly records, even when they are available. Since I’ve come across this problem a few times, I thought of a procedure that can do this (Luedeling, 2018). Sometimes we have actual records of hourly temperatures. While this is preferable, in principle, to deriving hourly data from daily records, it may cause problems when the record isn’t complete. An example of such a record is the Winters_hours_gaps dataset contained in chillR. Such situations arise quite often, because temperature loggers can temporarily fail for many reasons. Let’s first look at what happens if we simply use linear interpolation: In this interpolation, some daytime or nighttime cycles were missed entirely, which can lead to substantial errors when calculating agroclimatic metrics, such as chill or heat stress, that are of particular concern during the warmest and coolest parts of the day. chillR’s interpolate_gaps_hourly() function provides an algorithm that can produce credible and continuous hourly records from such a patchy dataset. It combines several of the elements described above, but also adds functionality to derive daily temperature extremes from hourly data that were recorded. Without going into too much detail, here is the rough mode of operation: Express temperatures for each hour as a function of daily temperature extremes using the functions of Linvill (1990). According to this idealized curve, all hourly temperatures can be expressed as a function of Tmin and Tmax on the previous, same or next day of the temperature record (depending on which hour is of interest). For a day with a complete record, 24 equations can be set up. For each daily temperature extreme, empirically solve the system of all equations that contain the respective Tmin or Tmax variable (this is only attempted, when a minimum of 5 equations are available, to avoid spurious results). Close gaps in the resulting dataset of daily Tmin and Tmax using data from proxy stations or, as a last resort, linear interpolation. Compute idealized temperature curves from the now continuous record of daily Tmin and Tmax values. Calculate the difference between recorded temperatures and this idealized curve. Linearly interpolate this difference and add then result to the idealized temperature curve. The following code calls this function for the Winters dataset, using daily data from a nearby station of the California Irrigation Management Information System (CIMIS) as a proxy. This is retrieved with the handle_cimis() function, which works similarly to the handle_gsod() function described above. Note that the CIMIS database seems to have occasional connectivity problems, and they’ve at least once made changes to their data storage system that required changes to the handle_cimis function. So it’s possible that the process times out or returns an error. stations &lt;- handle_cimis(&quot;list_stations&quot;, location = c(-122,38.5)) downloaded_winters &lt;- handle_cimis(&quot;download_weather&quot;, stations$chillR_code[2], time_interval = c(2008,2008)) winters_daily &lt;- handle_cimis(downloaded_winters)$weather Here’s what the dataset looks like: Year Month Day Tmin Tmax Tmean Prec 2008 1 1 NA NA NA NA 2008 1 2 -1.7 13.6 5.0 0.0 2008 1 3 1.5 12.2 6.9 12.0 2008 1 4 8.0 11.0 9.2 132.8 2008 1 5 5.3 9.5 7.2 10.3 And here is the call of the interpolate_gaps_hourly() function: to_interp &lt;- Winters_hours_gaps to_interp[,&quot;Temp_recorded&quot;] &lt;- to_interp[,&quot;Temp&quot;] to_interp[,&quot;Temp&quot;] &lt;- to_interp[,&quot;Temp_gaps&quot;] interp &lt;- interpolate_gaps_hourly(hourtemps = to_interp, latitude = 38.5, daily_temps = list(Winters=winters_daily)) The resulting dataset has two elements: $weather and daily_patch_report. Let’s first look at the daily_patch_report element: Var Proxy mean_bias stdev_bias filled gaps_remain Tmin solved NA NA 193 61 Tmin Winters 0.282 1.908 61 0 Tmin interpolated NA NA 0 0 Tmax solved NA NA 204 50 Tmax Winters -1.835 2.393 50 0 Tmax interpolated NA NA 0 0 This table contains information on how many gaps in the daily record were filled by solving the system of hourly equations (‘solved’), how many Tmin and Tmax values were derived from proxy stations (listed by name, if names were provided in the call to interpolate_gaps_hourly; otherwise as station_x), and how many were filled by linear interpolation (this option can be turned off using the interpolate_remaining parameter). For proxy stations, it also provides the bias in mean Tmin and Tmax, which has been corrected, as well as the bias in the standard deviation of Tmin and Tmax (which was not corrected). The $weather element of the interpolation result contains the table of interpolated temperatures. Year Month Day Hour interpolated Tmax_source 2008 3 4 15 21.86700 NA 2008 3 4 16 21.60400 NA 2008 3 4 17 20.07900 NA 2008 3 4 18 17.34400 NA 2008 3 4 19 13.93000 NA 2008 3 4 20 11.92900 NA 2008 3 4 21 11.84718 solved 2008 3 4 22 11.76536 solved 2008 3 4 23 11.68355 solved 2008 3 5 0 11.60173 solved 2008 3 5 1 11.51991 solved 2008 3 5 2 11.43809 solved 2008 3 5 3 11.35627 solved 2008 3 5 4 11.27445 solved 2008 3 5 5 11.19264 solved 2008 3 5 6 11.11082 solved Here’s a plot of part of the data: This illustration shows that the interpolate_gaps_hourly() function produced a pretty good approximation (red lines) to the actual temperatures (gray line). 11.4.1 Accuracy assessment Since the actual hourly temperatures are known, we can evaluate the accuracy of the predictions produced by the various interpolation methods. A common measure for validating predictions is the Root Mean Square Error of the Prediction (RMSEP): \\[RMSEP=\\sqrt{\\frac{\\sum_{i=1}^n(\\hat{y}_i-y_i)^2}{n}}\\], with \\(\\hat{y}_i\\) being the observed values, \\(y_i\\) the predicted values, and \\(n\\) the number of values. The RMSEP provides an indication of how far each predicted value deviates, on average, from the actual values. It is, however, quite difficult to interpret RMSEP values alone, because whether they indicate a good or poor model fit depends on how variable the actual values are. For instance, an RMSEP of 5 days for a phenology model (which is close to, but not quite the same as a mean error of 5 days), could indicate a very good model, if observed dates vary by several weeks or months (e.g. for bloom dates of deciduous trees), but a terrible model, if the phenological stage of interest occurs on the same day every year (e.g. the ‘phenological’ event of candles lighting up on ‘festive indoor conifers’). This is why it makes sense to include in such accuracy assessment the variation in observed values. This can be achieved by dividing the standard deviation of the observed data by the RMSEP to calculate the Residual Prediction Deviation (RPD): \\[RPD=\\frac{sd_y}{RMSEP}\\] This equation contains the RMSEP as computed above as well as the standard deviation of the observed values from their mean, defined as \\[sd_y=\\sqrt{\\frac{\\sum_{i=1}^n(y_i-\\bar{y})^2}{n-1}}\\] , with \\(\\bar{y}\\) being the mean over all observations. The RPD is more useful than the RMSEP, but its use of the standard deviation can be a problem, when actual values of \\(y\\) aren’t normally distributed (then the standard deviation can be a poor measure of variation). A more robust approach is use the interquartile range instead of the standard deviation. This metric is called the Ratio of Performance to InterQuartile distance (RPIQ): \\[RPIQ=\\frac{IQ}{RMSEP}\\] IQ is calculated by subtracting the 75th percentile of the distribution of all \\(y\\) from the 25th percentile. require(stats) y &lt;- rnorm(100) IQ &lt;- quantile(y)[4] - quantile(y)[2] The RPIQ score is a bit harder to evaluate than the RMSEP, with different quality thresholds in use and a very high context dependency. Quite commonly, values above 2 are considered ‘good’ or even ‘excellent’, though some studies use substantially higher thresholds (up to 8 for excellence). Since the RPIQ makes no assumption about the distribution of \\(y\\), let’s use this for assessing the accuracy of the various interpolation methods. We have a total of four methods to evaluate: idealized temperature curves from daily records of Tmin and Tmax, based on records from a nearby weather station idealized temperature curves from daily records of Tmin and Tmax, based on records from the same location linear interpolation of hourly temperatures interpolation of hourly temperatures with interpolate_gaps_hourly For option 2, we first have to generate a dataset of daily minimum and maximum temperatures from the hourly records. We can do this with the make_all_day_table() function (see documentation for this function for details). inter &lt;- interp$weather inter[,&quot;DATE&quot;] &lt;- ISOdate(inter$Year, inter$Month, inter$Day, inter$Hour) orchard_extremes &lt;- make_all_day_table(inter, timestep = &quot;day&quot;, input_timestep = &quot;hour&quot;) Let’s first look at the performance of the four methods for the periods that were missing in the hourly temperature record: winters_hours &lt;- stack_hourly_temps(fix_weather(winters_daily), latitude = 38)$hourtemps start_hour_winters &lt;- which(winters_hours$Year == head(inter$Year,1)&amp; winters_hours$Month == head(inter$Month,1)&amp; winters_hours$Day == head(inter$Day,1)&amp; winters_hours$Hour == head(inter$Hour,1)) end_hour_winters &lt;- which(winters_hours$Year == tail(inter$Year,1)&amp; winters_hours$Month == tail(inter$Month,1)&amp; winters_hours$Day == tail(inter$Day,1)&amp; winters_hours$Hour == tail(inter$Hour,1)) orchard_hours &lt;- stack_hourly_temps(orchard_extremes, latitude = 38)$hourtemps start_hour_orchard &lt;- which(orchard_hours$Year == head(inter$Year,1)&amp; orchard_hours$Month == head(inter$Month,1)&amp; orchard_hours$Day == head(inter$Day,1)&amp; orchard_hours$Hour == head(inter$Hour,1)) end_hour_orchard &lt;- which(orchard_hours$Year == tail(inter$Year,1)&amp; orchard_hours$Month == tail(inter$Month,1)&amp; orchard_hours$Day == tail(inter$Day,1)&amp; orchard_hours$Hour == tail(inter$Hour,1)) observed &lt;- inter$Temp_recorded option1 &lt;- winters_hours$Temp[start_hour_winters:end_hour_winters] option2 &lt;- orchard_hours$Temp[start_hour_orchard:end_hour_orchard] option3 &lt;- interpolate_gaps(inter$Temp_gaps)$interp option4 &lt;- inter$Temp eval_table &lt;- eval_table_gaps &lt;- data.frame(Option = 1:4, Input_data = c(&quot;daily&quot;,&quot;daily&quot;,&quot;hourly&quot;,&quot;hourly&quot;), Interpolation_method = c(&quot;from proxy&quot;,&quot;local extremes&quot;, &quot;linear&quot;,&quot;hourly interpolation&quot;), RMSEP = NA, RPIQ = NA) observed_gaps &lt;- observed[which(is.na(inter$Temp_gaps))] option1_gaps &lt;- option1[which(is.na(inter$Temp_gaps))] option2_gaps &lt;- option2[which(is.na(inter$Temp_gaps))] option3_gaps &lt;- option3[which(is.na(inter$Temp_gaps))] option4_gaps &lt;- option4[which(is.na(inter$Temp_gaps))] eval_table_gaps[,&quot;RMSEP&quot;] &lt;- round(c(RMSEP(option1_gaps, observed_gaps), RMSEP(option2_gaps, observed_gaps), RMSEP(option3_gaps, observed_gaps), RMSEP(option4_gaps, observed_gaps)), 1) eval_table_gaps[,&quot;RPIQ&quot;] &lt;- round(c(RPIQ(option1_gaps, observed_gaps), RPIQ(option2_gaps, observed_gaps), RPIQ(option3_gaps, observed_gaps), RPIQ(option4_gaps, observed_gaps)), 1) eval_table_gaps Option Input_data Interpolation_method RMSEP RPIQ 1 daily from proxy 2.6 4.1 2 daily local extremes 2.1 5.0 3 hourly linear 5.3 2.0 4 hourly hourly interpolation 2.0 5.4 This table shows that the interpolate_gaps_hourly function produced the best results, with an RMSEP of 2 and an RPIQ of 5.4. It’s interesting to note that option 3, where hourly records collected in the orchard were interpolated linearly, produced the worst fit. This highlights that, at least in this case, using an idealized temperature curve to close gaps in daily temperatures from the orchard (option 2) and even from the proxy station (option 1) produced more accurate results. Naturally, the quality of the latter approach will depend on the similarity between weather at the proxy station and in the orchard (in this case, this should be quite similar). Restricting the comparison to only the gaps in the record is a bit unfair, because of course records produced by option 3 (linear interpolation of hourly records from the orchard) are completely accurate for hours, when temperatures were recorded. So let’s also compare the relative performance of the four methods across all hours of the record. eval_table &lt;- data.frame(Option = 1:4, Input_data = c(&quot;daily&quot;,&quot;daily&quot;,&quot;hourly&quot;,&quot;hourly&quot;), Interpolation_method = c(&quot;from proxy&quot;,&quot;local extremes&quot;, &quot;linear&quot;,&quot;hourly interpolation&quot;), RMSEP = NA, RPIQ = NA) eval_table[,&quot;RMSEP&quot;] &lt;- round(c(RMSEP(option1, observed), RMSEP(option2, observed), RMSEP(option3, observed), RMSEP(option4, observed)), 1) eval_table[,&quot;RPIQ&quot;] &lt;- round(c(RPIQ(option1, observed), RPIQ(option2, observed), RPIQ(option3, observed), RPIQ(option4, observed)), 1) eval_table Option Input_data Interpolation_method RMSEP RPIQ 1 daily from proxy 2.5 4.2 2 daily local extremes 1.9 5.7 3 hourly linear 3.9 2.7 4 hourly hourly interpolation 1.5 7.2 The relative performance of the methods on the whole dataset is quite similar to the previous assessment. The quality of the proxy-based idealized temperature curves went down slightly, while all other approaches saw improvements in quality (lower RMSEP and higher RPIQ). The RPIQ values for the two interpolations that were based on local data (options 2 and 4) are very high, especially for option 4, which used the interpolate_gaps_hourly function. The RPIQ score for this option almost exceeds the ‘excellence’ threshold for the most conservative RPIQ evaluation scheme that I’ve come across (8). I find this quite remarkable, given the variable nature of daily temperature fluctuations and the fact that about half of the actually recorded values were removed before running the interpolation. In conclusion, the interpolate_gaps_hourly function provided a very good approximation of hourly temperatures for times when no values were recorded. 11.4.2 Computing agroclimatic metrics Finally, let’s look at the implication of the choice of interpolation method on chill and heat estimates. If we’re interested in using the Dynamic Model for winter chill or the Growing Degree Hours model for heat, we can simply calculate this using the Dynamic_Model and GDH() functions in chillR. For more functionality, see the chilling() and particularly the tempResponse() functions. Let’s first look at the implications of method choice on chill accumulation: all_chill &lt;- data.frame(DATE = inter$DATE, &quot;Obs&quot; = Dynamic_Model(observed), &quot;Opt1&quot; = Dynamic_Model(option1), &quot;Opt2&quot; = Dynamic_Model(option2), &quot;Opt3&quot; = Dynamic_Model(option3), &quot;Opt4&quot; = Dynamic_Model(option4)) all_chill &lt;- pivot_longer(all_chill, Obs:Opt4) all_chill[which(all_chill$name == &quot;Obs&quot;),&quot;Method&quot;] &lt;- &quot;Observed temperatures&quot; all_chill[which(all_chill$name == &quot;Opt1&quot;),&quot;Method&quot;] &lt;- &quot;Option 1 - idealized record from proxy data&quot; all_chill[which(all_chill$name == &quot;Opt2&quot;),&quot;Method&quot;] &lt;- &quot;Option 2 - idealized record from daily orchard data&quot; all_chill[which(all_chill$name == &quot;Opt3&quot;),&quot;Method&quot;] &lt;- &quot;Option 3 - linear interpolation of hourly data&quot; all_chill[which(all_chill$name == &quot;Opt4&quot;),&quot;Method&quot;] &lt;- &quot;Option 4 - use of interpolate_gaps_hourly&quot; ## Warning: A numeric `legend.position` argument in `theme()` was deprecated in ggplot2 ## 3.5.0. ## ℹ Please use the `legend.position.inside` argument of `theme()` instead. ## This warning is displayed once every 8 hours. ## Call `lifecycle::last_lifecycle_warnings()` to see where this warning was ## generated. This figure shows that chill accumulation differed substantially between the options. Both the use of proxy data and the use of linear interpolation of hourly temperatures led to considerable overestimation of chill accumulation. Here is the same assessment for heat: all_heat &lt;- data.frame(DATE = inter$DATE, &quot;Obs&quot; = GDH(observed), &quot;Opt1&quot; = GDH(option1), &quot;Opt2&quot; = GDH(option2), &quot;Opt3&quot; = GDH(option3), &quot;Opt4&quot; = GDH(option4)) all_heat &lt;- pivot_longer(all_heat, Obs:Opt4) all_heat[which(all_heat$name == &quot;Obs&quot;),&quot;Method&quot;] &lt;- &quot;Observed temperatures&quot; all_heat[which(all_heat$name == &quot;Opt1&quot;),&quot;Method&quot;] &lt;- &quot;Option 1 - idealized record from proxy data&quot; all_heat[which(all_heat$name == &quot;Opt2&quot;),&quot;Method&quot;] &lt;- &quot;Option 2 - idealized record from daily orchard data&quot; all_heat[which(all_heat$name == &quot;Opt3&quot;),&quot;Method&quot;] &lt;- &quot;Option 3 - linear interpolation of hourly data&quot; all_heat[which(all_heat$name == &quot;Opt4&quot;),&quot;Method&quot;] &lt;- &quot;Option 4 - use of interpolate_gaps_hourly&quot; This comparison doesn’t look quite as bad as for chill accumulation, but also here, option 4 clearly provided the most accurate estimate (it almost coincides with the black line, making the difference hard to see). This dataset didn’t cover the winter season, so the chill numbers aren’t too meaningful, but it is nevertheless instructive to compare the total accumulation of chill and heat over the whole temperature record: Option Input_data Interpolation_method Chill Portions Growing Degree Hours 0 observed none 12.2 72925 1 daily from proxy 20.1 64813 2 daily local extremes 13.8 70974 3 hourly linear 23.1 78256 4 hourly hourly interpolation 13.6 72610 This comparison shows that the choice of interpolation method can have substantial impact on our impression of accumulated chill and heat. The interpolate_gaps_hourly() function in chillR outperformed all other methods evaluated here. Exercises on filling gaps Please document all results of the following assignments in your learning logbook. You already downloaded some weather data in the exercises for the Getting temperatures lesson. You can keep working with this. Use chillR functions to find out how many gaps you have in this dataset (even if you have none, please still follow all further steps) Create a list of the 25 closest weather stations using the handle_gsod function Identify suitable weather stations for patching gaps Download weather data for promising stations, convert them to chillR format and compile them in a list Use the patch_daily_temperatures function to fill gaps Investigate the results - have all gaps been filled? If necessary, repeat until you have a dataset you can work with in further analyses References Linvill DE. (1990). Calculating chilling hours and chill units from daily maximum and minimum temperature observations. HortScience, 25(1), 14–16. doi: 10.21273/HORTSCI.25.1.14 Luedeling E. (2018). Interpolating hourly temperatures for computing agroclimatic metrics. International Journal of Biometeorology, 62(10), 1799–1807. doi: 10.1007/s00484-018-1582-7 "],["generating-temperature-scenarios.html", "Chapter 12 Generating temperature scenarios Learning goals for this lesson 12.1 Chill scenarios 12.2 Risk assessment in orchard planning 12.3 Weather generators 12.4 Weather generation in chillR Exercises on temperature generation", " Chapter 12 Generating temperature scenarios Learning goals for this lesson Understand what a weather generator is, (roughly) how it works and why it is useful for planning Learn how to run the temperature_generation function included in chillR Be able to produce chill profiles for a place of interest using histograms and cumulative distributions Understand what Safe Winter Chill is and be able to calculate it 12.1 Chill scenarios A big part of the rationale for what we’ve been doing so far has been to develop a feeling of the chill availability (or other agroclimatic conditions) at a given site. This information is crucial for orchard managers selecting tree species and cultivars for their orchards. Looking at the historic record has already given us a lot of useful information, but this isn’t yet exactly the information that a grower making planting decisions needs. What is really needed is a site-specific agroclimatic characterization that provides an impression of the range of conditions that we can reasonably expect at this location. In other words, we may want to have information on how likely it is for the orchard to experience certain levels of chill, heat or whatever other metric we are interested in. 12.2 Risk assessment in orchard planning Since trees live and are (hopefully) productive for many years, they experience many different temperature dynamics during their productive lifetime. For optimal production, trees should fulfill their climatic needs in all of these years. This is why, when we select trees for planting, we need information on the plausible range of ‘weathers’ we can expect. Based on this, we would be able to select trees that safely fulfill their chilling requirements in all plausible weather situations, or we could choose trees that strike a balance between early flowering and the risk of spring frost. All such decisions require information on how likely it is for our orchard to experience certain conditions. The plausible range of ‘weathers’ we can expect is defined by the local climate, which is the long-term average of the annually observed weather. We can interpret this ‘climate’ as a virtual collection of all possible weather situations for a given location, from which we receive one random draw each year. Annual weather can be interpreted as a random draw from the plausible distribution of all possible ‘weathers’. For planning purposes, it would be much more useful to know this virtual distribution of possible ‘weathers’ than just looking at the random samples that happened to be drawn. So far, we’ve only been able to get these samples - that was the historic analysis of observed chill. In this lesson, we’ll try to get to the actual climate, and from there to ways to use this knowledge for producing temperature profiles for locations of interest that facilitate orchard planning. 12.3 Weather generators Our best source of information for characterizing the climate of a given location consists in long-term weather records collected there. Based on such records, we can easily calculate means of monthly temperatures, rainfall extremes, the frequency of frost events and various other metrics. Of course there are varying levels of detail we can choose in characterizing the local climate, and a certain level of sophistication is needed if we want to produce realistic weather records. Weather generators vary widely in the way they characterize climatic settings. I haven’t really reviewed this much, but there would clearly be benefits to understanding in more detail how exactly these weather generators work, in order to make a good decision on which generator to choose. For the purposes of chillR, we depend on the weather generator of choice being implemented in R and being compatible with chillR’s overall structure. So far, I’ve only identified one weather generator that meets these requirements, from the RMAWGEN package, so I haven’t had the luxury or being able to choose. However, I looked at other weather generators before moving the whole framework to R and used the LARS-WG tool in some of my earlier analyses (Luedeling et al., 2011a, 2011b) (Link and Link). That generator uses both temperature and rainfall data, identifying the typical length of dry and wet spells and producing distinct temperature profiles for each of these weather situations. The tool chillR currently uses doesn’t do that - it doesn’t even need precipitation data - but it also seems to be doing a good job. Having said this, it is somewhat difficult to assess the performance of these tools, so there is probably still room for improvement here. 12.4 Weather generation in chillR So chillR uses the RMAWGEN weather generator. This is the only R-based weather generator I’ve found so far, so this is what we’ll use. It seems pretty reliable, and, after an initial struggle to set it up, I haven’t encountered any major problems. I should first mention that chillR currently can’t generate weather in a comprehensive way, but only focuses on temperature. Expanding the capabilities here is a development need (which Lars Caspersen has started addressing)! The temperature_generation function in chillR first needs to be calibrated with observed weather data, in our case long-term temperature data provided in the chillR format. Based on this, it internally calculates parameters that characterize the local climate. These are then used to simulate a user-specified number or years of synthetic temperature data. As usual, we’ll start working with our Klein-Altendorf dataset (KA_weather). Besides the temperature data, for which all years have to be complete, the temperature_generation function needs a bit of additional information: years: a vector specifying the years within the observed record that we want to use for climate characterization sim_years: the years we want to simulate. Note that we’re not really simulating weather for the specific years we indicate here - this is just for the way years are labeled in the output dataset there are a few optional elements, but I only want to highlight one here: temperature_scenario. We’ll need this later. For now, we use the default value, which consists of a lot of zeros. In the first example, this will just generate a warning message - you’ll learn later what this is about. So here’s how to use the weather generator (just the first line of the code chunk), and to get an impression of how the generated data compare with the observed records. Temp &lt;- KA_weather %&gt;% temperature_generation(years=c(1998,2005), sim_years = c(2001,2100)) Temperatures &lt;- KA_weather %&gt;% filter(Year %in% 1998:2005) %&gt;% cbind(Data_source=&quot;observed&quot;) %&gt;% rbind( Temp[[1]] %&gt;% select(c(Year,Month,Day,Tmin,Tmax)) %&gt;% cbind(Data_source=&quot;simulated&quot;) ) %&gt;% mutate(Date=as.Date(ISOdate(2000,Month,Day))) ggplot(data=Temperatures, aes(Date,Tmin)) + geom_smooth(aes(colour = factor(Year))) + facet_wrap(vars(Data_source)) + theme_bw(base_size = 20) + theme(legend.position = &quot;none&quot;) + scale_x_date(date_labels = &quot;%b&quot;) ggplot(data=Temperatures, aes(Date,Tmax)) + geom_smooth(aes(colour = factor(Year))) + facet_wrap(vars(Data_source)) + theme_bw(base_size = 20) + theme(legend.position = &quot;none&quot;) + scale_x_date(date_labels = &quot;%b&quot;) Note that the previous plot was produced with the geom_smooth function of ggplot, rather than geom_line. This removed much of the noise in the dataset, which would otherwise have made this figure hard to read. As we can see here, the overall temperature dynamics were represented quite well, though it is certainly possible that some nuances of the local weather were missed. In the simulated dataset, we now have 100 years of data, even though we only used 8 years for calibration. The major advantage in this is that based on these 100 years, we can now get a pretty good idea of the frequency of particular temperature-related events. Let’s look at the distribution of winter chill for Klein-Altendorf based on this analysis: chill_observed &lt;- Temperatures %&gt;% filter(Data_source == &quot;observed&quot;) %&gt;% stack_hourly_temps(latitude = 50.4) %&gt;% chilling(Start_JDay = 305, End_JDay = 59) chill_simulated &lt;- Temperatures %&gt;% filter(Data_source == &quot;simulated&quot;) %&gt;% stack_hourly_temps(latitude = 50.4) %&gt;% chilling(Start_JDay = 305, End_JDay = 59) chill_comparison &lt;- cbind(chill_observed, Data_source = &quot;observed&quot;) %&gt;% rbind(cbind(chill_simulated, Data_source = &quot;simulated&quot;)) chill_comparison_full_seasons &lt;- chill_comparison %&gt;% filter(Perc_complete == 100) Now we can easily plot the data with ggplot: ggplot(chill_comparison_full_seasons, aes(x=Chill_portions)) + geom_histogram(binwidth = 1, aes(fill = factor(Data_source))) + theme_bw(base_size = 20) + labs(fill = &quot;Data source&quot;) + xlab(&quot;Chill accumulation (Chill Portions)&quot;) + ylab(&quot;Frequency&quot;) Note that in the code chunk above, we had to manually remove all incomplete winter seasons. Now we have a histogram showing the distribution of chill that it would have been reasonable to expect in Klein-Altendorf betwen 1998 and 2005. These distributions get better with more observations of course. We can also plot these data as a cumulative distribution function, which makes it easy to extract the risk of falling below a particular level of chill accumulation. We can also directly compute this using the quantile function. chill_simulations &lt;- chill_comparison_full_seasons %&gt;% filter(Data_source == &quot;simulated&quot;) ggplot(chill_simulations, aes(x = Chill_portions)) + stat_ecdf(geom = &quot;step&quot;, lwd = 1.5, col = &quot;blue&quot;) + ylab(&quot;Cumulative probability&quot;) + xlab(&quot;Chill accumulation (in Chill Portions)&quot;) + theme_bw(base_size = 20) # Here&#39;s the amount of chill that is exceeded in 90% of all years. quantile(chill_simulations$Chill_portions,0.1) ## 10% ## 77.28649 # and here&#39;s the 50% confidence interval (25th to 75th percentile) quantile(chill_simulations$Chill_portions, c(0.25,0.75)) ## 25% 75% ## 79.76791 84.23847 Note that the 10% quantile calculated above is equivalent to what I named ‘Safe Winter Chill’. The concept is illustrated in the following figure: Illustration of the concept of Safe Winter Chill, which is defined as the 10% quantile of the typical distribution of chill at a particular location. This is best calculated using a weather generator (Luedeling et al., 2009d) You should now be able to understand how the data for this figure were generated (using different tools at the time, but the process was basically the same). The idea behind Safe Winter Chill is that a grower might be able to tolerate a small risk of not meeting a tree’s chilling requirement. If we grow a tree with a chilling requirement that corresponds exactly to the Safe Winter Chill of the site, we should expect chill-related problems in about one out of ten years. Whether this is ok will of course depend on the grower’s risk tolerance, but it seems a reasonable threshold to use. You can probably see already how we could calculate a similar metric for a grower with a different level of risk tolerance. Exercises on temperature generation Please document all results of the following assignments in your learning logbook. For the location you chose for your earlier analyses, use chillR’s weather generator to produce 100 years of synthetic temperature data. Calculate winter chill (in Chill Portions) for your synthetic weather, and illustrate your results as histograms and cumulative distributions. Produce similar plots for the number of freezing hours (&lt;0°C) in April (or October, if your site is in the Southern Hemisphere) for your location of interest. References Luedeling E &amp; Brown PH. (2011a). A global analysis of the comparability of winter chill models for fruit and nut trees. International Journal of Biometeorology, 55(3), 411–421. doi: 10.1007/s00484-010-0352-y Luedeling E, Girvetz EH, Semenov MA &amp; Brown PH. (2011b). Climate change affects winter chill for temperate fruit and nut trees. PloS One, 6(5), e20155. Retrieved from https://journals.plos.org/plosone/article?id=10.1371/journal.pone.0020155 "],["saving-and-loading-data-and-hiding-this-in-markdown.html", "Chapter 13 Saving and loading data (and hiding this in markdown) 13.1 Learning Goals for this lesson: 13.2 Saving and loading data 13.3 Hiding all this from the readers of our markdown file Exercises on saving and loading data", " Chapter 13 Saving and loading data (and hiding this in markdown) 13.1 Learning Goals for this lesson: Learn how to write and read tables Learn how to save and load lists of (not-too-complicated) objects Learn how to hide such writing and saving from the readers of your markdown document By now you may have noticed that your learning logbook is starting to take a bit longer to knit, as you add more code chunks to the file. You may also have noticed that some of the data processing steps we’ve done took a noticeable length of time. This is because we’re now handling quite a bit of data already. In the last lesson we generated 100 years of synthetic hourly weather data. This dataset consisted of approximately 876,000 hours. To get to each hourly temperature, we computed sunrise and sunset times and daylength, we applied the daily temperature curve function, and we computed various chill metrics, including the somewhat complicated Dynamic Model function. All of this adds up! Maybe up to now we’ve been patient enough to wait for these results to be calculated each time we knit our learning logbook. We may lose our patience, however, when we venture into climate change scenarios, which means that we have to process many times as much data. Calculations can then easily take an hour or so, and we probably won’t want to repeat this too many times. So let’s now look at how we can save our results and reload them later. 13.2 Saving and loading data R has functions called save and load, which can (probably, I haven’t really tried this) help you save and load data. I don’t use these, however, because I prefer really simple data formats that allow me to manually open the file for inspection outside R. For simple data.frames saving can simply be done using the write.csv function. Here’s an example for the Temperatures dataset that we generated in the last lesson: head(Temperatures) Year Month Day Tmax Tmin Data_source Date 1998 1 1 8.2 5.1 observed 2000-01-01 1998 1 2 9.1 5.0 observed 2000-01-02 1998 1 3 10.4 3.3 observed 2000-01-03 1998 1 4 8.4 4.5 observed 2000-01-04 1998 1 5 7.7 4.5 observed 2000-01-05 1998 1 6 8.1 4.4 observed 2000-01-06 write.csv(Temperatures, file=&quot;data/Temperatures.csv&quot;, row.names = FALSE) I set row.names=FALSE, because I don’t want the rows to be numbered. We can load this dataset again by typing the following: Temperatures &lt;- read_tab(&quot;data/Temperatures.csv&quot;) head(Temperatures) Year Month Day Tmax Tmin Data_source Date 1998 1 1 8.2 5.1 observed 2000-01-01 1998 1 2 9.1 5.0 observed 2000-01-02 1998 1 3 10.4 3.3 observed 2000-01-03 1998 1 4 8.4 4.5 observed 2000-01-04 1998 1 5 7.7 4.5 observed 2000-01-05 1998 1 6 8.1 4.4 observed 2000-01-06 Note that in this last call, I didn’t use R’s inbuilt read.csv function, but a chillR function called read_tab. Most likely it did the same thing that read.csv would have done, which is read the comma-separated-values file we just saved. There’s a little problem, however, that can easily arise with the .csv format, which uses a comma to separate the values stored in the file. Using .csv files is easy and safe, when you’re in an English-typing environment, where people use the . as the decimal symbol. Unfortunately, some of my collaborations involved colleagues from French or Spanish-speaking countries, and even some from Germany, where most local computers use the comma as a decimal symbol. This regularly caused trouble, because on such computers, values in .csv files are - contrary to the name - not separated by commas but by semicolons. R can deal with this, but problems can easily arise when you transfer files between computers with different language settings. The read_tab function recognizes this (based on the frequency of commas and semicolons in the file), so it should be able to correctly read files from different language regions. Still, this was relatively easy. Things get a bit more complicated when we want to save objects that are more complex than simple data.frames. We’ll be dealing a bit with lists of multiple data.frames soon, so it would be nice to have an option to save such objects. To handle this task, chillR includes functions for writing and reading lists that consist of numbers, character strings and/or data.frames. Let’s make a simple list and save it in our data folder: test_list &lt;- list(Number = 1, String = &quot;Thanks for using chillR!&quot;, DataFrame = data.frame(a = c(1,2,3), b = c(3,2,1), c = c(5,4,3))) save_temperature_scenarios(test_list, path = &quot;data&quot;, prefix = &quot;test_list&quot;) In our data folder, we now have three new files: test_list_1_Number.csv test_list_2_String.csv test_list_3_DataFrame.csv Each file contains one of the list elements. We can easily retrieve this information using another chillR function: test_list &lt;- load_temperature_scenarios(path = &quot;data&quot;, prefix = &quot;test_list&quot;) You may have noticed that the name of this function contains ‘temperature_scenarios’. This is because the main motivation for writing this function was to not have to repeat the generation of temperature scenarios, which is one of the most time-consuming steps in various chillR workflows. The functions work with other lists as well (except that they currently convert elements consisting of single strings and numbers into mini-data.frames - needs to be fixed). 13.3 Hiding all this from the readers of our markdown file After all the lessons we’ve been through, the calculations in this document already add up to quite a bit of processing time, and we’re only getting started with the real calculations. We wouldn’t want to re-run all this every time we build the document. So in many cases I only ran the code that you’re seeing once and saved the results. When the document is knitted, I simply load the saved files. So why is the code still visible, and why don’t you see the instructions for loading data? The answer is that you can have code in a markdown document that is invisible in the end product but runs anyway. Similarly, you can have code appear in the end product that isn’t actually run. You can specify this by using certain options that are added to the header line of a code chunk. Normal code chunks start with ” ```{r} “. Options can be added after the r, separated by a comma. I’ll only talk about two of them here, but there are a few more that may also become useful at some point. option “echo=FALSE” means that our code block will be run, but we don’t see the code or the output in the final document. We’ll still see ‘side effects’, such as figures that are produced option “eval=FALSE” means that the code will be shown in the final document, but it will not be run So when you’ve saved your results and don’t want to run your code again, you can do the following: . ```{r, echo=FALSE} . load the datasets you want, load packages that you don’t want people to know about etc. . ``` . ```{r, eval=FALSE} . run all kinds of complicated operations that allegedly produced the dataset you just loaded. . ``` Never mind the leading dots here. They are needed to prevent R from recognizing these as code chunks - then I wouldn’t be able to show this to you here. Note that of course when you apply this saving and loading strategy, you have to make sure that all required inputs for later code chunks are actually available. Exercises on saving and loading data We don’t have to do any exercises on this, but make sure you apply this in your learning logbook. Otherwise the lessons of the next few sessions will make it very difficult to work with the markdown file. "],["historic-temperature-scenarios.html", "Chapter 14 Historic temperature scenarios Learning goals for this lesson 14.1 Climate change scenarios 14.2 Making historic temperature scenarios Exercises on generating historic temperature scenarios", " Chapter 14 Historic temperature scenarios Learning goals for this lesson Understand how we can include temperature scenarios while generating synthetic weather Be able to produce temperature scenarios with arbitrary change scenarios imposed Understand the difference between absolute and relative temperature scenarios and the importance of baselines (for relative scenarios) Learn how to produce temperature scenarios that represent past points in time from historic temperature records Learn how to produce synthetic temperature scenarios for past points in time and efficiently compute agroclimatic metrics for them 14.1 Climate change scenarios We recently learned how to use a weather generator accessed by chillR to produce agroclimatic profiles for a given location. We calibrated the weather generator with historically observed temperature data, and the profile we produced was representative of climatic conditions during the period used for calibration. As you may already have guessed, the weather generator can also produce scenarios that represent different climatic conditions. Specifically, the temperature_generation function contains a parameter called temperature_scenario, which we can use to send the necessary instructions to the weather generator. The temperature_scenario parameter requires a data.frame with columns Tmin and Tmax. Each of these columns should have 12 values that specify changes to the mean minimum and maximum temperatures, respectively, for each month of the year. If we don’t specify this parameter, the function uses the default object - a data.frame with zeros for all changes. Let’s see how this works in practice. Our first climate change scenario will be simple. We’ll just add arbitrary numbers to all the monthly \\(T_{min}\\) and \\(T_{max}\\) values. # Here&#39;s the call from the earlier lesson. We don&#39;t have to run this again. Temp &lt;- temperature_generation(KA_weather, years = c(1998,2005), sim_years = c(2001,2100)) # Now we make a temperature scenario that raises all temperatures by 2°C change_scenario &lt;- data.frame(Tmin = rep(2,12), Tmax = rep(2,12)) change_scenario Tmin Tmax 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 Temp_2 &lt;- temperature_generation(KA_weather, years = c(1998,2005), sim_years = c(2001,2100), temperature_scenario = change_scenario) # As before, we&#39;ll make a data.frame that contains all # our data, so we can take a look at it. Temperature_scenarios &lt;- KA_weather %&gt;% filter(Year %in% 1998:2005) %&gt;% cbind(Data_source = &quot;observed&quot;) %&gt;% rbind(Temp[[1]] %&gt;% select(c(Year, Month, Day, Tmin, Tmax)) %&gt;% cbind(Data_source = &quot;simulated&quot;) ) %&gt;% rbind(Temp_2[[1]] %&gt;% select(c(Year, Month, Day, Tmin, Tmax)) %&gt;% cbind(Data_source = &quot;Warming_2C&quot;) ) %&gt;% mutate(Date = as.Date(ISOdate(2000, Month, Day))) Since the structure of this dataset is the same as we had in the earlier lesson, we can use identical code to illustrate it (just have to replace the data.frame name. ggplot(data = Temperature_scenarios, aes(Date,Tmin)) + geom_smooth(aes(colour = factor(Year))) + facet_wrap(vars(Data_source)) + theme_bw(base_size = 20) + theme(legend.position = &quot;none&quot;) + scale_x_date(date_labels = &quot;%b&quot;) ggplot(data = Temperature_scenarios, aes(Date,Tmax)) + geom_smooth(aes(colour = factor(Year))) + facet_wrap(vars(Data_source)) + theme_bw(base_size = 20) + theme(legend.position = &quot;none&quot;) + scale_x_date(date_labels = &quot;%b&quot;) This was an arbitrary climate scenario. Nobody expects future changes to be so uniformly distributed across all months, and this certainly hasn’t happened in the past. This is, however, pretty similar to my first attempt at climate change scenario modeling. Here’s the corresponding figure from my first chilling paper. Chill scenarios for a mountain oasis in Oman according (Luedeling et al., 2009b) But let’s try to make scenarios that are a bit more realistic. For this, we start with scenarios that represent particular years from the historic record. As we discussed already, we could of course simply look at temperatures recorded during a particular year. We may, however, also be interested in what temperature conditions should have been considered normal at the time, rather than what actually happened. Such a perspective can make it much easier to identify historic trends, because we can now try to evaluate the gradual shift in climate (the collection of plausible weather) rather than just looking at the random weathers we’ve been dealt in the past, where trends are often obscured by interannual variation and possibly by some freaky outliers that distort our trend analysis. 14.2 Making historic temperature scenarios To make this a meaningful exercise, we’ll need a long-term dataset. We’ve already seen how to get this and prepare it for use in chillR. # download weather station list for the vicinity of Bonn station_list &lt;- handle_gsod(action = &quot;list_stations&quot;, location=c(7.1,50.8)) # download weather data for Cologne/Bonn airport and convert it to chillR format Bonn_weather &lt;- handle_gsod(action = &quot;download_weather&quot;, location = station_list$chillR_code[1], time_interval = c(1973,2019)) %&gt;% handle_gsod() # check record for missing data fix_weather(Bonn_weather$`KOLN BONN`)$QC # (incidentally almost all gaps are for years covered by the KA_weather dataset) Bonn_patched &lt;- patch_daily_temperatures( weather = Bonn_weather$`KOLN BONN`, patch_weather = list(KA_weather)) fix_weather(Bonn_patched)$QC # There are still 4 days missing here, out of 47 years - # let&#39;s simply interpolate these gaps now Bonn&lt;-fix_weather(Bonn_patched) Bonn_temps&lt;-Bonn$weather We could now easily run the weather generator to produce weather scenarios that correspond to the normal climate between 1973 and 2019. Since temperatures have been gradually rising over this period, the best guess for the year that would best represent this scenario would be the median of the time period, which is 1996. But let’s say we’re not interested in 1996, but in scenarios representing 1980, 1990, 2000 and 2010. How can we make such scenarios? The way to address this challenge is to examine the historic temperature record to determine the changes that happened between the year we’re interested in and the year our temperature data represent. Let’s call this representative year the baseline of our observed temperature data, and the years we want to make simulations for the simulation years. chillR has a function that helps us make temperature scenarios from temperature records, which is called temperature_scenario_from_records. Here’s how we can use it: scenario_1980 &lt;- temperature_scenario_from_records(weather = Bonn_temps, year = 1980) This scenario contains several elements: data: a data.frame specifying \\(T_{min}\\) and \\(T_{max}\\) values that are representative of the year of interest scenario_year: the year we’re interested in reference_year: for scenarios that describe temperature changes (which is not the case here), this would specify relative to what year these changes are expressed (NA in this case) scenario_type: specifies whether this scenario contains absolute temperatures for the year of interest (true in this case), or whether it expressed changes relative to another year labels: contains additional information we can attach to scenarios. In this case, this says “running mean scenario”. See below for what this means. Here’s just the data element: scenario_1980$&#39;1980&#39;$data Tmin Tmax -1.6792115 4.374074 -2.3167944 5.580546 0.8537634 9.763560 2.8043210 13.474444 6.8980884 18.016248 10.4950617 21.370494 12.3964158 23.175627 11.8548387 23.186141 9.2693827 19.827531 5.8487455 14.443608 2.2375309 9.076790 0.1126643 6.024134 Now it’s time to refresh your memory on a warning message we received when we first started running our weather generator. This contained the following information: scenario doesn’t contain named elements - consider using the following element names: ‘data’, ‘reference_year’,‘scenario_type’,‘labels’ setting scenario_type to ‘relative’ Reference year missing - can’t check if relative temperature scenario is valid Maybe we can understand now what this meant. Our input for the scenario at that time was simply a data.frame, but we’ve just seen that scenarios can contain more information. The temperature_generation recognized this and decided to warn us. This is because all this information has a purpose, and if it’s not provided, temperature_generation has to make some assumptions on what it’s supposed to do with the information. The second element of the warning indicates that the scenario_type was automatically set to ‘relative’. The function contains some decision rules for deciding whether a temperature scenario specifies absolute or relative temperatures, and here we are informed about what the outcome of that decision was. Finally, we are informed that the reference year is missing. This means that we’ve specified a relative temperature scenario, but we didn’t specify relative to what. In our case, this was simply the year that the historic record represented (e.g. the median year of the observed record), but this isn’t always clear, as we’ll see when we start talking about future projections. Well, in the scenario we just built here, we shouldn’t get such warning messages, because now we have a comprehensive list that contains all the information the temperature_generation function needs. Let’s try to run it with our new scenario: temps_1980 &lt;- temperature_generation(weather = Bonn_temps, years = c(1973,2019), sim_years = c(2001,2100), temperature_scenario = scenario_1980) We still got a warning message: “Absolute temperature scenario specified - calibration weather record only used for simulating temperature variation, but not for the means” This means that the weather generator evaluated the calibration dataset with respect to variation of temperatures around the mean temperatures. It then generated a dataset with means (for \\(T_{min}\\) and \\(T_{max}\\) of each month) that correspond to the (absolute) temperature scenario we provided, and variation similar to that in the observed record. This is what we wanted, so we’re good. If we want to convert this absolute temperature scenario into a relative scenario, we have to specify a baseline scenario to compare it with. In our case, 1996 is a good choice, because that is the median year of our observed record. So let’s make a scenario for that year: scenario_1996 &lt;- temperature_scenario_from_records(weather = Bonn_temps, year = 1996) This is now also an absolute temperature scenario. We can produce a relative change scenario by applying the temperature_scenario_baseline_adjustment function: relative_scenario &lt;- temperature_scenario_baseline_adjustment( baseline = scenario_1996, temperature_scenario = scenario_1980) Now we have a relative change scenario - a list with the following elements: data: again a data.frame with \\(T_{min}\\) and \\(T_{max}\\) columns, but now containing relative changes between 1996 and 1980 (all negative values, because 1980 was cooler than 1996) scenario_year: still 1980 reference_year: now 1996 scenario_type: now ‘relative’ labels: still ‘running mean scenario’ We can now try to apply this scenario in a similar way to what we did earlier: temps_1980&lt;-temperature_generation(weather = Bonn_temps, years = c(1973,2019), sim_years = c(2001,2100), temperature_scenario = relative_scenario) This time we got away without a warning message, because we provided the temperature_generation function with everything it needed to know. So let’s now make all the scenarios we had in mind. This is facilitated by most of the functions also accepting vectors and lists, rather than just single numbers and data.frames. all_past_scenarios &lt;- temperature_scenario_from_records( weather = Bonn_temps, year = c(1980, 1990, 2000, 2010)) adjusted_scenarios &lt;- temperature_scenario_baseline_adjustment( baseline = scenario_1996, temperature_scenario = all_past_scenarios) all_past_scenario_temps &lt;- temperature_generation( weather = Bonn_temps, years = c(1973,2019), sim_years = c(2001,2100), temperature_scenario = adjusted_scenarios) save_temperature_scenarios(all_past_scenario_temps, &quot;data&quot;, &quot;Bonn_hist_scenarios&quot;) The all_past_scenario_temps object is a list that now contains 100 years of synthetic weather for all the past scenarios we had in mind. Let’s say we now want to calculate chill accumulation again. We could go back and find all the functions we used before and apply them to each of the four temperature scenarios we just generated. However, we can also apply a chillR function, tempResponse_daily_list that has already automated all this. I’ll also make a simple frost model and select only the Dynamic Model and GDH Model for the evaluation. frost_model &lt;- function(x) step_model(x, data.frame( lower=c(-1000,0), upper=c(0,1000), weight=c(1,0))) models &lt;- list(Chill_Portions = Dynamic_Model, GDH = GDH, Frost_H = frost_model) chill_hist_scenario_list &lt;- tempResponse_daily_list(all_past_scenario_temps, latitude = 50.9, Start_JDay = 305, End_JDay = 59, models = models) Let’s make sure to save these scenarios, because we’ll need them again in the lessons on [Making CMPI6 scenarios] and Making CMIP5 scenarios with the ClimateWizard. To make sure I remember later what this was about, I’ll make sure that the place name and the start and end dates of the considered period are included in the file name. Before I save the file, I’ll remove all the incomplete winters from the record. chill_hist_scenario_list &lt;- lapply(chill_hist_scenario_list, function(x) x %&gt;% filter(Perc_complete == 100)) save_temperature_scenarios(chill_hist_scenario_list, &quot;data&quot;,&quot;Bonn_hist_chill_305_59&quot;) scenarios &lt;- names(chill_hist_scenario_list)[1:4] all_scenarios &lt;- chill_hist_scenario_list[[scenarios[1]]] %&gt;% mutate(scenario = as.numeric(scenarios[1])) for (sc in scenarios[2:4]) all_scenarios &lt;- all_scenarios %&gt;% rbind(chill_hist_scenario_list[[sc]] %&gt;% cbind( scenario=as.numeric(sc)) ) %&gt;% filter(Perc_complete == 100) # Let&#39;s compute the actual &#39;observed&#39; chill for comparison actual_chill &lt;- tempResponse_daily_list(Bonn_temps, latitude=50.9, Start_JDay = 305, End_JDay = 59, models)[[1]] %&gt;% filter(Perc_complete == 100) ggplot(data = all_scenarios, aes(scenario, Chill_Portions, fill = factor(scenario))) + geom_violin() + ylab(&quot;Chill accumulation (Chill Portions)&quot;) + xlab(&quot;Scenario year&quot;) + theme_bw(base_size = 15) + ylim(c(0,90)) + geom_point(data = actual_chill, aes(End_year, Chill_Portions, fill = &quot;blue&quot;), col = &quot;blue&quot;, show.legend = FALSE) + scale_fill_discrete(name = &quot;Scenario&quot;, breaks = unique(all_scenarios$scenario)) We should also save the observed chill data, so we can use it in in the lessons on [Making CMPI6 scenarios] and Making CMIP5 scenarios with the ClimateWizard. write.csv(actual_chill,&quot;data/Bonn_observed_chill_305_59.csv&quot;, row.names = FALSE) Now we have chill distribution scenarios representing the years 1980, 1990, 2000 and 2010. We don’t see too much change here, which means we probably won’t have to worry about chill deficiencies in Bonn any time soon. Note that all the annual scenarios so far were based on running means of \\(T_{min}\\) and \\(T_{max}\\). This seems appropriate because in times of accelerating climate change, estimating temperatures at any given time via clean mathematical equations seems rather challenging. However, chillR also contains the option of using linear regression to determine these representative temperatures for a particular historic scenario. Let’s quickly look at what kind of difference this makes in this case. temperature_means &lt;- data.frame(Year = min(Bonn_temps$Year):max(Bonn_temps$Year), Tmin = aggregate(Bonn_temps$Tmin, FUN = &quot;mean&quot;, by = list(Bonn_temps$Year))[,2], Tmax=aggregate(Bonn_temps$Tmax, FUN = &quot;mean&quot;, by = list(Bonn_temps$Year))[,2]) %&gt;% mutate(runn_mean_Tmin = runn_mean(Tmin,15), runn_mean_Tmax = runn_mean(Tmax,15)) Tmin_regression &lt;- lm(Tmin~Year, temperature_means) Tmax_regression &lt;- lm(Tmax~Year, temperature_means) temperature_means &lt;- temperature_means %&gt;% mutate(regression_Tmin = Tmin_regression$coefficients[1]+ Tmin_regression$coefficients[2]*temperature_means$Year, regression_Tmax = Tmax_regression$coefficients[1]+ Tmax_regression$coefficients[2]*temperature_means$Year ) ggplot(temperature_means, aes(Year, Tmin)) + geom_point() + geom_line(data = temperature_means, aes(Year, runn_mean_Tmin), lwd = 2, col = &quot;blue&quot;) + geom_line(data = temperature_means, aes(Year, regression_Tmin), lwd = 2, col = &quot;red&quot;) + theme_bw(base_size = 15) + ylab(&quot;Mean monthly minimum temperature (°C)&quot;) ggplot(temperature_means, aes(Year, Tmax)) + geom_point() + geom_line(data = temperature_means, aes(Year, runn_mean_Tmax), lwd = 2, col = &quot;blue&quot;) + geom_line(data = temperature_means, aes(Year, regression_Tmax), lwd = 2, col = &quot;red&quot;) + theme_bw(base_size = 15) + ylab(&quot;Mean monthly maximum temperature (°C)&quot;) We can see that there’s a bit of a difference between the running mean function (blue) and the linear regression line (red). Sometimes this can be important, and we should expect the difference to become more pronounced as climate change progresses. Exercises on generating historic temperature scenarios Please document all results of the following assignments in your learning logbook. For the location you chose for previous exercises, produce historic temperature scenarios representing several years of the historic record (your choice). Produce chill distributions for these scenarios and plot them. "],["future-temperature-scenarios.html", "Chapter 15 Future temperature scenarios Learning goals for this lesson 15.1 Impacts of future climate change 15.2 Future climate scenarios Exercises on future temperature scenarios", " Chapter 15 Future temperature scenarios Learning goals for this lesson Acquire background knowledge on some important concepts in climate change analysis Understand how future climate projections are generated Learn about the “generations” of climate models and greenhouse gas concentration scenarios Appreciate that it’s important to use up-to-date scenarios when you’re working in this space 15.1 Impacts of future climate change There is no doubt that man-made climate change has already affected our climate, and rising temperatures (and other changes) have left noticeable marks on the world’s ecological and agricultural systems. Such impacts have been reported in many studies, with lots of solid evidence backing up the conclusions of these reports. There is of course no credible reason to believe that climate change has already ended. In fact, we’re expecting future impacts to be more dramatic than what we’ve seen so far. This is mainly because atmospheric greenhouse gas concentrations are now higher than they’ve ever been, since our species appeared on the planet (and in fact many millions of years before). Despite some efforts to mitigate climate change, the world’s factories, cars etc. are also still emitting carbon dioxide on the order of 40 Gt CO2-eq per year - at or at least close to the all-time peak, with only weak signs of significant slowdown over the coming decades. We also know that near-global ecosystem degradation is gradually chipping away at the buffers, checks and balances that have managed to maintain stable ecosystems to date. To anticipate the future impacts of climate change, we have to keep all these dynamics in mind. It then becomes pretty obvious that we cannot predict with certainty what is going to happen in the future. We don’t know to what extent global efforts to curb carbon dioxide emissions or sequester carbon from the atmosphere will be successful. We also don’t know how much change the Earth’s marine and terrestrial ecosystems will be able to absorb before irreversible and possibly self-reinforcing degradation will set in. We can’t address all uncertainties with chillR of course, but we can accommodate - to some extent - our uncertainty about future climatic conditions. In climate change adaptation research, the challenge is often conceptualized using the concept of exposure, sensitivity and adaptive capacity: Conceptual framework for evaluating vulnerability and adaptation to climate change (Luedeling, 2020) In this concept, exposure describes the future conditions we expect, and sensitivity is the way the system responds to change. By combining exposure and sensitivity, we can determine the potential impact of expected conditions on the system of interest. These aren’t necessarily the actual impacts, however, because the system may be able to adapt to some extent. This system attribute is often referred to as adaptive capacity. Adaptation actions usually either aim to reduce system sensitivity (e.g. by choosing different tree cultivars) or to raise adaptive capacity (e.g. by establishing management options that allow dealing with chill shortfalls). What exact aspects of this concept we’re working on depends a bit on our interpretation of these terms. For the most part, we’re looking at exposure, because we’re producing scenarios of conditions that orchards will be confronted with in the future. However, our chill models consider - to some extent - the biological response of trees, which we could argue comes close to the concept of sensitivity. Yet we’re not fully capturing this sensitivity, so I would place the analyses we’re currently doing mostly within the exposure category. 15.2 Future climate scenarios We’ve already learned about future climate scenarios in the introductory materials on climate change. In the last lesson, we looked at how we can make historic chill scenarios, including some technical details that we’ll need in this lesson. What is still missing now is a source of information on conditions that climate models predict for the place we’re interested in. Running climate models is pretty complicated, and we certainly won’t do that here. This is a science of its own, and getting everything right, from GCM setup, to RCM implementation and downscaling is pretty tricky. In fact, there is probably no agreement on what is right. In principle, all the chillR functions work just as well with great future scenarios as they do with deeply flawed ones… so if you happen to be collaborating with a world-class climate modeling group, or you have access to state-of-the-art climate scenarios for your region, it may be a good idea to use those data. chillR can’t keep track of all downscaling efforts that are going on, or be aware of all regional initiatives. It does, however, includes functions that allows us easy access to useful databases of climate information. 15.2.1 Some background on climate models and warming pathways Until November 2023, the best source of climate data that chillR had to offer was the ClimateWizard database, maintained by the Center for Tropical Agriculture (CIAT). Compared to most other sources of climate information, the ClimateWizard database has a major advantage: It facilitates easy access to point-specific data for climate scenarios produced by multiple climate models. Other data sources may contain more credible models, more models, more scenarios etc., but many only contain gridded climate data. This may mean that you first have to download climate data for a whole region, country, continent or planet, only to then extract information for just that one point you’re interested in. Given that we need such datasets for \\(T_{min}\\) and \\(T_{max}\\) for each month of the year and probably for multiple climate models, climate change trajectories and downscaling methods, data transfer needs quickly become a major bottlenecks. Depending on the data source you select, the hard drive of the computer you’re currently using may not be able to store all the information you’d need to download. ClimateWizard does this selection for us, and it only returns information for the coordinates we specified. The original ClimateWizard tool, developed by Dr. Evan Girvetz is actually a website with a proper user interface, where you can check out future climate scenarios. Rather than using this web interface, we can access the same information via an API. This stands for Application Programming Interface, which is a tool that provides direct access to the information in a database, without the need to click through various pages on a website. The API is described in a github repository, where you can find detailed descriptions. A caveat to this data source is that (to the best of my knowledge) it has not been updated to include the latest climate scenarios. Climate science evolves rapidly and models get better and better. More importantly, the type of warming scenarios that are recommended by the IPCC get updated with every major report they issue. These scenarios are produced by the Coupled Model Intercomparison Project (CMIP), a major effort to assemble the best that climate science has to offer in terms of future projections. CMIP is structured in phases. Phase 5 (CMIP5) went from 2010 to 2014 and it included a certain set of climate models. The following CMIP6 includes has a slightly different array of climate models, which (at the time of writing) represents the state of the art of climate science, as endorsed by the IPCC. Another feature of these future projections that gets updated occasionally are the warming scenarios. Over the years, these have evolved from the scenarios contained in the Special Report on Emission Scenarios (SRES) via the Representative Concentration Pathways (RCPs) to the currently recommended Shared Socioeconomic Pathways (SSPs). Feel free to follow the links for more information in these scenarios. The SSPs are the latest generation of scenarios, which was published in 2021. If you want to produce state-of-the-art projections, these are the scenarios you should be using, and you should be using the outputs of the CMIP6 set of climate models. Unfortunately, ClimateWizard only includes RCP scenarios, and it even only has two of these, which don’t really bracket the full array of future climates that climate scientists consider plausible. We used these RCP scenarios for quite a while after the release of the SSPs, but it is becoming increasingly difficult to publish results that are based on these outdated visions of our climatic future. In the chapter on Making CMIP5 scenarios with the ClimateWizard, I’ll still provide instructions here on how to use it, but I’d encourage you to upgrade to the CMIP6 information. Exercises on future temperature scenarios Please document all results of the following assignments in your learning logbook. Briefly describe the differences between the RCPs and the SSPs (you may have to follow some of the links provided above). "],["making-cmip6-scenarios.html", "Chapter 16 Making CMIP6 scenarios Learning goals for this lesson 16.1 Accessing gridded climate data from the Copernicus climate data store Exercises on generating CMIP6 temperature scenarios", " Chapter 16 Making CMIP6 scenarios Note that running this code requires chillR version &gt;=0.76. You should be able to find it on CRAN. Please refrain from trying to produce CMIP6 projections with earlier chillR versions. Learning goals for this lesson Learn how to download future temperature projections for a CMIP6 ensemble from the Copernicus database Be able to produce synthetic temperature scenarios for an ensemble of future climate scenarios Transfer knowledge you gained earlier to compute temperature-based agroclimatic metrics for all the historic temperature records, as well as for past and future temperature scenarios Learn how to plot all your results in a concise manner 16.1 Accessing gridded climate data from the Copernicus climate data store As outlined in the chapter on Future temperature scenarios, most future climate data come in the form of grids. This means that if we want to obtain information on a particular climatic metric for a particular place, we may have to download a sometimes fairly large file that contains data for a lot of other places as well. For the CMPI5 scenarios, we were able to use the ClimateWizard API (see Making CMIP5 scenarios with the ClimateWizard), which provided access to only specific point locations. Unfortunately, I haven’t been able to find a similar tool for the CMIP6 scenarios, which (at the time of writing) represent the state of the art. So we may have to look again into downloading gridded data, but let’s try to find an efficient way to do this. While the procedure described below is a little more cumbersome than the ClimateWizard solution (especially if we only want to work with a single station), we are now gaining access to a very reliable and competently curated source of future climate - the Copernicus Climate Data Store, which is maintained by the European Centre for Medium-Range Weather Forecasts (which, by the way, has one of its three offices in Bonn). Copernicus, under whose umbrella this data store is run, is the Earth Observation component of the European Union’s space program. To make use of the data provided by the Copernicus Climate Data Store via their Application Programming Interface (API), we need a user ID and a key (called Access Token on their site). To get this, we have to create a free account here (registration button is in the top right corner). If you want to make use of these chillR functions, please do this now and come back. Once you’ve set up your account, navigate to your user profile on the Copernicus Climate Data Store website. On this page, you’ll find your User ID and your Personal Access Token (both are long, cryptic strings of symbols). You’ll need these to download data. In the code below, I’ll just put the placeholders write user id here and write key here in the places where these should go. After registering, you also have to read and accept the Terms of Use for Data Access. After this is done, the following code should work. 16.1.1 Downloading future climate data Now we can start downloading data using the download_cmip6_ecmwfr function. Keep in mind that we can only download data for grids with this function. To achieve this, we need to specify the extent of the download area. In choosing your download extent, note that we’ll actually download the data to our computer. Note also that we can keep the data there, so that we don’t have to download them again. For subsequent steps, we can access these data and extract whatever we need. This means that if we really only want to analyze data for a single station, we can choose a small extent around this station. If we want to evaluate multiple stations, however, especially when these are located close to each other, it may be advisable to choose an extent that includes all these stations. For this example, I’ll only evaluate data for Bonn, which is located at approximately 7.1°E and 50.8°N. So I’ll choose a small extent around this, which I specify in the form of a vector structured as follows: c(maximum latitude, minimum longitude, minimum latitude, maximum longitude). location = c(7.1, 50.8) area &lt;- c(52, 6, 50, 8) Now we can download the data. The download_cmip6_ecmwfr contains a default set of models, which I’ll use here. I’ll start by only using data for SSP1 (ssp126). download_cmip6_ecmwfr( scenarios = &#39;ssp126&#39;, area = area, user = &#39;write user id here&#39;, key = &#39;write key here&#39;, model = &#39;default&#39;, frequency = &#39;monthly&#39;, variable = c(&#39;Tmin&#39;, &#39;Tmax&#39;), year_start = 2015, year_end = 2100) This function took a while to run, and it generated a bunch of files in a subfolder of our working directory. We could change the name of this folder (using the path_download parameter), but since we didn’t do this, the data should be stored in the cmip6_downloaded folder. We also received a message about Dropped models. These are climate models, for which the database contained no data with the specifications we provided. For these models, the function attempted to download data but didn’t find anything in the database. These models are then blacklisted, i.e. the function leaves a note in the download folder to prevent the function from trying to download these data again. Assuming that this worked well, we should now expand the download to additional SSP scenarios. We can simply provide a vector of such scenarios as the scenarios parameter. I’ll use the scenarios SSP126, SSP245, SSP370 and SSP585. These are the standard scenarios of CMIP6 (and currently the only ones that this function can download). Note that we can add “ssp126” here again, because the function is able to detect whether the respective data have already been downloaded. It automatically skips all files that are already present. download_cmip6_ecmwfr( scenarios = c(&quot;ssp126&quot;, &quot;ssp245&quot;, &quot;ssp370&quot;, &quot;ssp585&quot;), area = area, user = &#39;write user id here&#39; key = &#39;write key here&#39;, model = &#39;default&#39;, frequency = &#39;monthly&#39;, variable = c(&#39;Tmin&#39;, &#39;Tmax&#39;), year_start = 2015, year_end = 2100) 16.1.2 Generating change scenarios We should now have downloaded a lot of data to a folder called cmip6_downloaded/52_6_50_8. Unfortunately, we still need more. What we have now are future scenarios. The simulated records start in 2015, and earlier data aren’t available for the SSP scenarios. Our first instinct may be to think that this is exactly what we wanted, since we’re interested in projections for the future… but not so fast! These data come out of very coarse-resolution climate models. The pixels of such models often include entire landscapes, with rivers and mountains, coastal areas and inland regions. The values we downloaded represent an average of all of these, so it may be quite unlikely that they are a good approximation of the temperature conditions of our place of interest. Are these projections useless for site-specific analyses then? Well, the coarse resolution is certainly a problem, and for rainfall patterns or hydrological applications, landscape-scale features may be so important that we may have to wait for someone to apply spatial downscaling to these coarse datasets. In (dynamic) downscaling, the coarse GCM outputs are inserted into a finer-scale climate model that actually represents all the crucial landscape features. After such downscaling, we may have a chance to get accurate information on rainfall patterns etc. Fortunately, we’re really only interested in temperature here. While landscape features also influence temperature dynamics, the effect isn’t nearly as dramatic as for precipitation. Still, we should not use temperature data from our GCM projections directly. What I consider quite useful, however, is the temperature change projected by these models. If, for instance, a GCM projects January temperatures that are 2°C warmer than today for some future scenario, then we could add these 2°C to what we observe today (ideally as a scenario for a weather generator). This may seem easy, but there’s one word that I casually used in the previous paragraph that we may need to get more specific about: today. When we talk about climate change, we often refer to warming by a certain number of degrees, e.g. in the prerogative to limit warming to 1.5°C that the international community agreed on in the Paris Agreement, but such talk only makes sense if we know the baseline that this change is relative to. Quite obviously, in a warming world, a 2°C change on top of conditions in, say, 1850 takes us to a cooler scenario than if we apply the same warming to today’s much warmer climate. We therefore should be very much aware of the reference conditions that apply to our warming scenario. In the chillR workflow for the CMIP6 data, we can control this to some extent, but we’ve also chosen a useful default for you: the 29-year period from 1986 to 2014. We’re recommending this period because data for this interval are available for the historical model runs in the Copernicus database, because the median year of this interval is a nice round number (2000), and because 29 years is pretty close to the 30 years that climate scientists generally recommend as the basis for a robust climatology. To create change scenarios from our climate data, we have to subtract conditions during the baseline period from the future projections. For this, it is important that the baseline and the future data are generated with the same tool, i.e. the same climate model. Fortunately, for every climate model contained in the CMIP6 ensemble, we can also retrieve historical information from the Copernicus database. We can get this done with the download_baseline_cmip6_ecmwfr function. download_baseline_cmip6_ecmwfr( area = area, user = &#39;write user id here&#39; key = &#39;write key here&#39;, model = &#39;match_downloaded&#39;, frequency = &#39;monthly&#39;, variable = c(&#39;Tmin&#39;, &#39;Tmax&#39;), year_start = 1986, year_end = 2014, month = 1:12) Note that if we specify models = match_downloaded here, the function will automatically look into the download folder, determine what models were used and download all respective baseline data. 16.1.3 Extracting data from the grids These data are still gridded, so we have to extract the data for the point of interest. To do this, we’ll create a small data.frame that contains the station name and the coordinates for Bonn. We could also add more station locations to this data.frame but for this lesson I’m only interested in data for Bonn. We’ll then use the extract_cmip6_data function to extract the point location data. station &lt;- data.frame( station_name = c(&quot;Bonn&quot;), longitude = c(7.1), latitude = c(50.8)) extracted &lt;- extract_cmip6_data(stations = station) Let’s look at some of the data for one of the climate models. head(extracted$`ssp126_AWI-CM-1-1-MR`) Date Year Month Day lat lon location model ssp Tmin Tmax 2015-01-16 2015 1 16 50.9608 7.5 Bonn AWI-CM-1-1-MR ssp126 -13.6960 10.8620 2015-02-15 2015 2 15 50.9608 7.5 Bonn AWI-CM-1-1-MR ssp126 -3.2364 12.8374 2015-03-16 2015 3 16 50.9608 7.5 Bonn AWI-CM-1-1-MR ssp126 -2.8993 13.5311 2015-04-16 2015 4 16 50.9608 7.5 Bonn AWI-CM-1-1-MR ssp126 0.0531 21.7272 2015-05-16 2015 5 16 50.9608 7.5 Bonn AWI-CM-1-1-MR ssp126 3.9305 22.6927 2015-06-16 2015 6 16 50.9608 7.5 Bonn AWI-CM-1-1-MR ssp126 7.7302 24.7364 Since we have stored the baseline data in the same folder, we can now use a very compact call to generate change scenarios for all the climate projections in the folder. change_scenarios &lt;- gen_rel_change_scenario(extracted) head(change_scenarios) location Month Tmax Tmin scenario start_year end_year scenario_year reference_year scenario_type labels Bonn 1 1.826612 1.803455 ssp126 2035 2065 2050 2000 relative ACCESS-CM2 Bonn 2 2.765976 2.179606 ssp126 2035 2065 2050 2000 relative ACCESS-CM2 Bonn 3 1.485612 1.170670 ssp126 2035 2065 2050 2000 relative ACCESS-CM2 Bonn 4 1.501575 1.264827 ssp126 2035 2065 2050 2000 relative ACCESS-CM2 Bonn 5 1.733385 1.485717 ssp126 2035 2065 2050 2000 relative ACCESS-CM2 Bonn 6 1.808780 1.506125 ssp126 2035 2065 2050 2000 relative ACCESS-CM2 As you can see, all the data are stored in one long data.frame. This is a format that we can easily save as a csv file. We can’t directly use this with our weather generator, but fortunately, chillR has a conversion function called convert_scen_information that can extract the relevant information and produce scenarios that are compatible with the temperature_generation function. write.csv(change_scenarios, &quot;data/all_change_scenarios.csv&quot;, row.names = FALSE) scen_list &lt;- convert_scen_information(change_scenarios) By the way, we can use the same convert_scen_information function to convert this list back to the data.frame format. scen_frame &lt;- convert_scen_information(scen_list) Let’s look at one of the elements in the scenario lists. scen_list$Bonn$ssp126$`ACCESS-CM2`$&#39;2050&#39; ## $data ## Tmin Tmax ## 1 1.803455 1.826612 ## 2 2.179606 2.765976 ## 3 1.170670 1.485612 ## 4 1.264827 1.501575 ## 5 1.485717 1.733385 ## 6 1.506125 1.808780 ## 7 2.047910 2.668619 ## 8 1.654944 2.754484 ## 9 2.388600 3.323390 ## 10 2.540916 2.722248 ## 11 2.322483 2.434944 ## 12 2.737679 2.713174 ## ## $scenario ## [1] &quot;ssp126&quot; ## ## $start_year ## [1] 2035 ## ## $end_year ## [1] 2065 ## ## $scenario_year ## [1] 2050 ## ## $reference_year ## [1] 2000 ## ## $scenario_type ## [1] &quot;relative&quot; ## ## $labels ## [1] &quot;ACCESS-CM2&quot; As you see, this scenario contains changes for the mean daily minimum and mean daily maximum temperature of every month, as well as several pieces of information that define the scenario: scenario specifies the SSP scenario, scenario_type says that this is a relative scenario, and labels contains the name of the GCM. Then we have four attributes that contain years. start_year, end_year and scenario_year describe the time slice that this scenario is for. We see that this corresponds to a 31-year window (2035-2065), with the median of this range (2050) serving as the scenario_year, i.e. the year that this scenario should be considered most typical for. The final parameter, reference_year, is also quite important. This identifies the year that the specified change is relative to, i.e. the temperature changes given in this scenario describe the warming relative to conditions in 2000. 16.1.4 Baseline adjustment We want to produce scenarios for the future, but we also want to use the observed data from Bonn to inform the weather generator and to ensure that we actually simulate temperatures for Bonn rather than the average conditions of some GCM pixel. In principle, the weather generator can do this, so let’s first try with one of the scenarios. Bonn_temps&lt;-read_tab(&quot;data/Bonn_temps.csv&quot;) temperature_generation(Bonn_temps, years = c(1973, 2019), sim_years = c(2001, 2100), scen_list$Bonn$ssp126$`ACCESS-CM2`) This didn’t work! Instead, we got an error message alerting us that the reference year of the scenario must correspond to the reference year of the future scenario. The reference year of the weather station data is 1996, the median year of the record, which runs from 1973 to 2019. We could decide now to use fewer data. If we only use observations from 1981, the median year of the observations becomes 2000 and it matches the reference year of the future projections. But maybe we really want to use the old data as well. For that case, chillR offers a tool to adjust the reference year based on an analysis of the temperature trends within the observed dataset. If we want to adjust the baseline of the observed weather, we can conduct a baseline adjustment. For this, we first need to find out how much warming (or cooling) has occurred in Bonn between 1996 and 2000. To do this we first determine typical temperature conditions in both years using the temperature_scenario_from_records function. temps_1996 &lt;- temperature_scenario_from_records(Bonn_temps, 1996) temps_2000 &lt;- temperature_scenario_from_records(Bonn_temps, 2000) temps_1996 ## $`1996` ## $`1996`$data ## Tmin Tmax ## 1 0.05087445 5.973100 ## 2 0.30170112 7.765459 ## 3 2.64824602 11.830710 ## 4 4.11729341 14.859979 ## 5 7.96049940 20.258237 ## 6 10.70938251 22.305362 ## 7 12.69130456 24.902204 ## 8 12.59129027 25.055860 ## 9 9.55433044 19.936424 ## 10 6.40652559 14.743805 ## 11 2.82050328 9.284547 ## 12 0.59125128 6.078879 ## ## $`1996`$scenario_year ## [1] 1996 ## ## $`1996`$reference_year ## [1] NA ## ## $`1996`$scenario_type ## [1] &quot;absolute&quot; ## ## $`1996`$labels ## [1] &quot;running mean scenario&quot; temps_2000 ## $`2000` ## $`2000`$data ## Tmin Tmax ## 1 0.09988805 5.858946 ## 2 0.49252884 7.160050 ## 3 2.28318554 11.177201 ## 4 4.71233727 15.734978 ## 5 8.47214144 20.026544 ## 6 11.06516711 22.910953 ## 7 13.05248064 25.056007 ## 8 12.50039945 24.317309 ## 9 10.00297925 20.234706 ## 10 6.84385460 15.212160 ## 11 3.12932493 9.289817 ## 12 0.75027682 6.006636 ## ## $`2000`$scenario_year ## [1] 2000 ## ## $`2000`$reference_year ## [1] NA ## ## $`2000`$scenario_type ## [1] &quot;absolute&quot; ## ## $`2000`$labels ## [1] &quot;running mean scenario&quot; These are both absolute temperature scenarios, i.e. they describe typical conditions in 1996 and 2000. From these, we can now compute a relative change scenario that describes the changes that occurred over this period with the temperature_scenario_baseline_adjustment function. base &lt;- temperature_scenario_baseline_adjustment(temps_1996, temps_2000) base ## $`2000` ## $`2000`$data ## Tmin Tmax ## 1 0.04901360 -0.114154209 ## 2 0.19082773 -0.605409513 ## 3 -0.36506047 -0.653509047 ## 4 0.59504387 0.874998320 ## 5 0.51164203 -0.231693038 ## 6 0.35578461 0.605590913 ## 7 0.36117608 0.153802780 ## 8 -0.09089082 -0.738550863 ## 9 0.44864880 0.298282271 ## 10 0.43732901 0.468354752 ## 11 0.30882164 0.005269925 ## 12 0.15902555 -0.072242620 ## ## $`2000`$scenario_year ## [1] 2000 ## ## $`2000`$reference_year ## [1] 1996 ## ## $`2000`$scenario_type ## [1] &quot;relative&quot; ## ## $`2000`$labels ## [1] &quot;running mean scenario&quot; We can now apply this baseline correction to our climate scenarios. For now, this only works with an unstructured list of scenarios, so we’ll have to convert the scenarios again using the give_structure = FALSE option. scen_list &lt;- convert_scen_information(change_scenarios, give_structure = FALSE) adjusted_list &lt;- temperature_scenario_baseline_adjustment( base, scen_list, temperature_check_args = list( scenario_check_thresholds = c(-5, 15))) Now we can start the temperature generation process. Note that, since we have many scenarios, this can take hours. Maybe this seems long, but keep in mind that we’re doing a lot of operations here and imagine you’d have to do them all manually. Since the computer is doing this for us, you can do something else (get a good night’s sleep?) in the meantime. It’s worth noting that there are different ways of running such big jobs. In the case of the temperature_generation function, we can enter the whole list of scenarios into the function and execute the process as one command. This can take a very long time though, and it’s sometimes hard to know if your computer is really still running or if it got stuck somehow. More importantly, you won’t get any results until the function has finished running, and if you abandon the process half-way through (or your computer crashes), you’re left with nothing. This is why sometimes it’s a better idea to program things in a less compact way. For instance, you can code this as a loop that processes one scenario at a time, saving the result after each run. You can even check if certain scenarios have already been processed and only work on the remaining ones. And you can output status messages that allow you to track the progress. I’m showing you both options here, but I’m commenting out the one that processes the whole list at once. # temps &lt;- temperature_generation( # Bonn_temps, # years = c(1973, 2019), # sim_years = c(2001, 2100), # adjusted_list, # temperature_check_args = # list( scenario_check_thresholds = c(-5, 15))) # save_temperature_scenarios(temps, # &quot;data/future_climate&quot;, # &quot;Bonn_futuretemps&quot;) for(scen in 1:length(adjusted_list)) { if(!file.exists(paste0(&quot;data/future_climate/Bonn_futuretemps_&quot;, scen,&quot;_&quot;, names(adjusted_list)[scen],&quot;.csv&quot;)) ) {temp_temp &lt;- temperature_generation(Bonn_temps, years = c(1973, 2019), sim_years = c(2001, 2100), adjusted_list[scen], temperature_check_args = list( scenario_check_thresholds = c(-5, 15))) write.csv(temp_temp[[1]],paste0(&quot;data/future_climate2/Bonn_futuretemps_&quot;,scen,&quot;_&quot;,names(adjusted_list)[scen],&quot;.csv&quot;), row.names=FALSE) print(paste(&quot;Processed object&quot;,scen,&quot;of&quot;, length(adjusted_list))) } } Definitely make sure to save the data now! We don’t want to have to wait for this again. Now we can calculate temperature responses based on these records. We can do this efficiently with the tempResponse_daily_list function. The models I’ll select for the calculation are the Dynamic Model for chill accumulation, the GDH model for heat accumulation and a simple model to compute frost hours. frost_model &lt;- function(x) step_model(x, data.frame( lower = c(-1000, 0), upper = c(0, 1000), weight = c(1, 0))) models &lt;- list(Chill_Portions = Dynamic_Model, GDH = GDH, Frost_H = frost_model) chill_future_scenario_list &lt;- tempResponse_daily_list(temps, latitude = 50.8, Start_JDay = 305, End_JDay = 59, models = models) chill_future_scenario_list &lt;- lapply(chill_future_scenario_list, function(x) x %&gt;% filter(Perc_complete == 100)) save_temperature_scenarios(chill_future_scenario_list, &quot;data/future_climate&quot;, &quot;Bonn_futurechill_305_59&quot;) We’ll later want to plot all our data. In chillR, this is most conveniently done by producing climate scenarios with the make_climate_scenario function. The plotting function we’ll be using later then simply processes a list of such climate scenarios. Let’s start with a historical scenario that contains both the distributions for historic years and the historically observed chill. We already produced these records and (hopefully) saved them in lesson Historic temperature scenarios, so I’ll just load them now. chill_hist_scenario_list&lt;-load_temperature_scenarios(&quot;data&quot;, &quot;Bonn_hist_chill_305_59&quot;) observed_chill &lt;- read_tab(&quot;data/Bonn_observed_chill_305_59.csv&quot;) chills &lt;- make_climate_scenario( chill_hist_scenario_list, caption = &quot;Historical&quot;, historic_data = observed_chill, time_series = TRUE) plot_climate_scenarios( climate_scenario_list = chills, metric = &quot;Chill_Portions&quot;, metric_label = &quot;Chill (Chill Portions)&quot;) ## [[1]] ## [1] &quot;time series labels&quot; As you can see, this function had two effects. It produced a plot and it returned a short list containing the message “time series labels”. This message isn’t too interesting now, but it will later contain more content. If we want to just store this information rather than immediately displaying it in our output, we can assign the plotting command to a new object (as in info &lt;- plot_climate_scenarios(...)). The function will then just produce its side effect, which is the plot itself. Now we run through the same process for all the future climate scenarios. For each one, we add the climate scenario to the chills object (make_climate_scenario has an argument add_to, where we can specify that). As a preparatory step, we’ll have to identify the data that belong to specific combinations of SSP and Time. SSPs &lt;- c(&quot;ssp126&quot;, &quot;ssp245&quot;, &quot;ssp370&quot;, &quot;ssp585&quot;) Times &lt;- c(2050, 2085) list_ssp &lt;- strsplit(names(chill_future_scenario_list), &#39;\\\\.&#39;) %&gt;% map(2) %&gt;% unlist() list_gcm &lt;- strsplit(names(chill_future_scenario_list), &#39;\\\\.&#39;) %&gt;% map(3) %&gt;% unlist() list_time &lt;- strsplit(names(chill_future_scenario_list), &#39;\\\\.&#39;) %&gt;% map(4) %&gt;% unlist() for(SSP in SSPs) for(Time in Times) { # find all scenarios for the ssp and time chill &lt;- chill_future_scenario_list[list_ssp == SSP &amp; list_time == Time] names(chill) &lt;- list_gcm[list_ssp == SSP &amp; list_time == Time] if(SSP == &quot;ssp126&quot;) SSPcaption &lt;- &quot;SSP1&quot; if(SSP == &quot;ssp245&quot;) SSPcaption &lt;- &quot;SSP2&quot; if(SSP == &quot;ssp370&quot;) SSPcaption &lt;- &quot;SSP3&quot; if(SSP == &quot;ssp585&quot;) SSPcaption &lt;- &quot;SSP5&quot; if(Time == &quot;2050&quot;) Time_caption &lt;- &quot;2050&quot; if(Time == &quot;2085&quot;) Time_caption &lt;- &quot;2085&quot; chills &lt;- chill %&gt;% make_climate_scenario( caption = c(SSPcaption, Time_caption), add_to = chills) } Now we have everything we need to plot the results of our climate change analysis: info_chill &lt;- plot_climate_scenarios( climate_scenario_list = chills, metric = &quot;Chill_Portions&quot;, metric_label = &quot;Chill (Chill Portions)&quot;, texcex = 1.5) info_heat &lt;- plot_climate_scenarios( climate_scenario_list = chills, metric = &quot;GDH&quot;, metric_label = &quot;Heat (Growing Degree Hours)&quot;, texcex = 1.5) info_frost &lt;- plot_climate_scenarios( climate_scenario_list=chills, metric=&quot;Frost_H&quot;, metric_label=&quot;Frost hours&quot;, texcex=1.5) Now we can see the trends in chill and heat accumulation, as well as in frost hours for Klein-Altendorf. As we saw earlier, the function didn’t only return the plot, but also some supplementary information, which we stored in the info... objects in the latest code chunk. If you inspect these objects, you’ll see that they contain the names of the climate models for each of the subplots (in addition to the time series labels for the historic plot). Since we used the same models each time, all information is listed multiple times. Let’s only look at this once, and only for one of the plots: info_chill[[2]] code Label 1 ACCESS-CM2 2 CMCC-ESM2 3 CNRM-CM6-1-HR 4 CNRM-ESM2-1 5 EC-Earth3-Veg-LR 6 FGOALS-g3 7 FIO-ESM-2-0 8 GFDL-ESM4 9 INM-CM4-8 10 INM-CM5-0 11 IPSL-CM6A-LR 12 AWI-CM-1-1-MR 13 MIROC6 14 MPI-ESM1-2-LR 15 MRI-ESM2-0 16 NESM3 These labels aren’t provided directly in the plot, because they would take up quite a bit of space. Instead, each model is specified by a number, with the key to these number codes given in this table. If you don’t like the design of this figure, don’t worry. We’ll be making our own version soon (and there’s also a more modern version in chillR now that we’ll get to know later). Exercises on generating CMIP6 temperature scenarios Please document all results of the following assignments in your learning logbook. Analyze the historic and future impact of climate change on two agroclimatic metrics of your choice, for the location you’ve chosen for your earlier analyses. "],["making-cmip5-scenarios-with-the-climatewizard.html", "Chapter 17 Making CMIP5 scenarios with the ClimateWizard Learning goals for this lesson 17.1 Using the ClimateWizard Exercises on generating CMIP5 temperature scenarios", " Chapter 17 Making CMIP5 scenarios with the ClimateWizard Note that this chapter only deals with CMIP5 climate scenarios. For methods to produce CMIP6 scenarios refer to the chapter on Making CMIP6 scenarios Learning goals for this lesson Learn how to download future temperature projections from the ClimateWizard database Be able to produce synthetic temperature scenarios for an ensemble of future climate scenarios Transfer knowledge you gained earlier to compute temperature-based agroclimatic metrics for all the historic temperature records, as well as for past and future temperature scenarios Learn how to plot all your results in a concise manner 17.1 Using the ClimateWizard Here we’ll use the ClimateWizard tool to download some future data, produced by the CMIP5 models for the RCPs 4.5 and 8.5 (these are the only scenarios that are available there). I should note here that the ClimateWizard service has been down from time to time, so the following code doesn’t always work. We’ll first look at a small example to familiarize ourselves with the way this function works: getClimateWizardData(coordinates = c(longitude = 10.61, latitude = 34.93), scenario = &quot;rcp45&quot;, start_year = 2020, end_year = 2050, metric = c(&quot;CD18&quot;, &quot;R02&quot;), GCMs = c(&quot;bcc-csm1-1&quot;, &quot;BNU-ESM&quot;)) This code only downloaded data for two GCMs and one RCP scenario. We’re accessing two climate metrics: “CD18” - cooling degree days (&gt;18°C) “R02” - the annual number of wet days &gt; 0.2 mm/day We’ll get mean values of all years from 2020 to 2050 for a position with longitude=10.61 and latitude=34.93 (somewhere in Tunisia). These metrics aren’t of interest to us, and we’d rather use data from Bonn than Tunisia. Also we’d like to have data for all the climate models in the dataset and for both RCPs (there are only two in the database unfortunately). Finally, since we want to use these data for producing temperature scenarios for our weather generator, we’d like to get information on expected future \\(T_{min}\\) and \\(T_{max}\\) values. Since the latter is a pretty standard objective in the context of chillR, the default option for the metric parameter is actually the string monthly_min_max_temps, which instructs the function to download all the information we need for the weather generator. There is no automated function for downloading multiple RCPs or multiple points in time, but we can easily implement this using for loops. We still have to decide what baseline period we want to use for our analysis. The weather record from Bonn goes from 1973 to 2019. Unfortunately, the ClimateWizard database requires the baseline period to be a 20-year interval between 1950 and 2005. Since climate has been changing over the 71-year span we have data for, we may want to choose an interval towards the end of this period. Let’s therefore select the 31-year interval between 1975 and 2005 (I’m using 31 years, because then the median year is an integer - this isn’t necessary, but somehow more aesthetically pleasing than some .5 business). The median year is now 1990. We’ll save the temperature scenarios after download to make sure we don’t have to download them again (this takes quite a while). RCPs &lt;- c(&quot;rcp45&quot;, &quot;rcp85&quot;) Times &lt;- c(2050, 2085) for(RCP in RCPs) for(Time in Times) {start_year &lt;- Time - 15 end_year &lt;- Time + 15 clim_scen &lt;- getClimateWizardData( c(longitude = 7.143, latitude = 50.866), RCP, start_year, end_year, temperature_generation_scenarios = TRUE, baseline =c(1975, 2005), metric = &quot;monthly_min_max_temps&quot;, GCMs = &quot;all&quot;) save_temperature_scenarios(clim_scen, &quot;data/ClimateWizard&quot;, paste0(&quot;Bonn_futures_&quot;,Time,&quot;_&quot;,RCP))} So we selected a period from 1975 to 2005 as the baseline for the future climate data. We could now also restrict the observed weather data used for calibrating the weather generator to the same interval. That would make some sense, but let’s say we want to use all of our observed data, which ranges from 1973 to 2019. The median of this period is 1996, which is different from 1990. So we need a baseline adjustment: scenario_1990 &lt;- Bonn_temps %&gt;% temperature_scenario_from_records(1990) scenario_1996 &lt;- Bonn_temps %&gt;% temperature_scenario_from_records(1996) adjustment_scenario &lt;- temperature_scenario_baseline_adjustment(scenario_1996, scenario_1990) print(adjustment_scenario) ## $`1990` ## $`1990`$data ## Tmin Tmax ## 1 -0.99579679 -0.6210091 ## 2 -1.86677592 -1.5459190 ## 3 -1.20033682 -1.1873413 ## 4 -0.68914526 -0.3104731 ## 5 -0.68845639 -1.2664810 ## 6 -0.37827139 -1.0444977 ## 7 -0.02404052 -0.4298024 ## 8 -0.43250891 -0.7725862 ## 9 -0.46704649 -0.6377817 ## 10 -0.10234398 0.4300303 ## 11 -0.52482427 -0.1198558 ## 12 -0.10439345 0.4106072 ## ## $`1990`$scenario_year ## [1] 1990 ## ## $`1990`$reference_year ## [1] 1996 ## ## $`1990`$scenario_type ## [1] &quot;relative&quot; ## ## $`1990`$labels ## [1] &quot;running mean scenario&quot; We see that the reference year is now 1996. This is correct, because this scenario will be used for temperature generation, where we’ll use the whole observed record for calibration. This adjustment scenario will have to be applied to all downloaded weather scenarios. We first need to select the RCPs and scenario years for our analysis: RCPs &lt;- c(&quot;rcp45&quot;, &quot;rcp85&quot;) Times &lt;- c(2050, 2085) Now we load the saved scenarios again. Saving and loading wouldn’t be absolutely necessary of course, but it really comes in handy when our computer crashes, we accidentally close RStudio etc. The load_ClimateWizard_scenarios function was specifically written to load such scenarios. We’ll also add the baseline adjustment and the temperature generation step here, and then save the generated weather: for(RCP in RCPs) for(Time in Times) { clim_scen &lt;- load_ClimateWizard_scenarios( &quot;data/climateWizard&quot;, paste0(&quot;Bonn_futures_&quot;, Time, &quot;_&quot;, RCP)) clim_scen_adjusted &lt;- temperature_scenario_baseline_adjustment( baseline_temperature_scenario = adjustment_scenario, temperature_scenario = clim_scen) Temps &lt;- temperature_generation( weather = Bonn_temps, years = c(1973, 2019), sim_years = c(2001, 2101), temperature_scenario = clim_scen_adjusted) save_temperature_scenarios( Temps, &quot;data/Weather_ClimateWizard&quot;, paste0(&quot;Bonn_&quot;, Time, &quot;_&quot;, RCP)) } This took quite a while, but now we have all the future temperature data we need for our scenario analysis, and all of this is saved to disk. So we don’t have to run this code again. Let’s add some historic scenarios though. This is similar to what we’ve done before. I’ll make scenarios corresponding to 1980, 1990, 2000 and 2010. all_past_scenarios &lt;- temperature_scenario_from_records( weather = Bonn_temps, year = c(1980, 1990, 2000, 2010)) adjusted_scenarios &lt;- temperature_scenario_baseline_adjustment( baseline = scenario_1996, temperature_scenario = all_past_scenarios) all_past_scenario_temps &lt;- temperature_generation( weather = Bonn_temps, years = c(1973, 2019), sim_years = c(2001, 2101), temperature_scenario = adjusted_scenarios) save_temperature_scenarios( all_past_scenario_temps, &quot;data/Weather_ClimateWizard&quot;, &quot;Bonn_historic&quot;) Now all we have to do is follow the steps we used to make our historic scenarios. The tempResponse_daily_list function makes this reasonably easy. Let’s first make a list of models we want to apply - I’m choosing the Dynamic Model for chill, the Growing Degree Hours model for heat, and a frost model here: frost_model &lt;- function(x) step_model(x, data.frame( lower=c(-1000,0), upper=c(0,1000), weight=c(1,0))) models &lt;- list(Chill_Portions = Dynamic_Model, GDH = GDH, Frost_H = frost_model) Now let’s first apply these models to the historic data, both the scenarios and the observed temperatures: Temps &lt;- load_temperature_scenarios(&quot;data/Weather_ClimateWizard&quot;, &quot;Bonn_historic&quot;) chill_past_scenarios &lt;- Temps %&gt;% tempResponse_daily_list( latitude = 50.866, Start_JDay = 305, End_JDay = 59, models = models, misstolerance = 10) chill_observed &lt;- Bonn_temps %&gt;% tempResponse_daily_list( latitude = 50.866, Start_JDay = 305, End_JDay = 59, models = models, misstolerance = 10) save_temperature_scenarios(chill_past_scenarios, &quot;data/chill_ClimateWizard&quot;, &quot;Bonn_historic&quot;) save_temperature_scenarios(chill_observed, &quot;data/chill_ClimateWizard&quot;, &quot;Bonn_observed&quot;) We’ll later want to plot all our data. In chillR, this is most conveniently done by producing climate scenarios with the make_climate_scenario function. The plotting function we’ll be using later then simply processes a list of such climate scenarios. Let’s start with a historic scenario that contains both the distributions for historic years and the historically observed chill. chill_past_scenarios &lt;- load_temperature_scenarios( &quot;data/chill_ClimateWizard&quot;, &quot;Bonn_historic&quot;) chill_observed &lt;- load_temperature_scenarios( &quot;data/chill_ClimateWizard&quot;, &quot;Bonn_observed&quot;) chills &lt;- make_climate_scenario( chill_past_scenarios, caption = &quot;Historic&quot;, historic_data = chill_observed, time_series = TRUE) plot_climate_scenarios( climate_scenario_list = chills, metric = &quot;Chill_Portions&quot;, metric_label = &quot;Chill (Chill Portions)&quot;) ## [[1]] ## [1] &quot;time series labels&quot; As you can see, this function had two effects. It produced a plot and it returned a short list containing the message “time series labels”. This message isn’t too interesting now, but it will later contain more content. If we want to just store this information rather than immediately displaying it in our output, we can assign the plotting command to a new object (as in info &lt;- plot_climate_scenarios(...). The function will then just produce its side effect, which is the plot itself. Now we run through the same process for all the future climate scenarios. For each one, we add the climate scenario to the chills object (make_climate_scenario has an argument add_to, where we can specify that): for(RCP in RCPs) for(Time in Times) { Temps &lt;- load_temperature_scenarios( &quot;data/Weather_ClimateWizard&quot;, paste0(&quot;Bonn_&quot;, Time, &quot;_&quot;, RCP)) chill &lt;- Temps %&gt;% tempResponse_daily_list( latitude = 50.866, Start_JDay = 305, End_JDay = 59, models = models, misstolerance = 10) save_temperature_scenarios( chill, &quot;data/chill_ClimateWizard&quot;, paste0(&quot;Bonn_&quot;, Time, &quot;_&quot;, RCP)) } We now load this again, make climate scenario the same way we did for the historic data, and add them to our chills list so that we can easily plot them: for(RCP in RCPs) for(Time in Times) { chill &lt;- load_temperature_scenarios( &quot;data/chill_ClimateWizard&quot;, paste0(&quot;Bonn_&quot;, Time, &quot;_&quot;, RCP)) if(RCP == &quot;rcp45&quot;) RCPcaption &lt;- &quot;RCP4.5&quot; if(RCP == &quot;rcp85&quot;) RCPcaption &lt;- &quot;RCP8.5&quot; if(Time == &quot;2050&quot;) Time_caption &lt;- &quot;2050&quot; if(Time == &quot;2085&quot;) Time_caption &lt;- &quot;2085&quot; chills &lt;- chill %&gt;% make_climate_scenario( caption = c(RCPcaption, Time_caption), add_to = chills) } Now we have everything we need to plot the results of our climate change analysis: info_chill &lt;- plot_climate_scenarios( climate_scenario_list = chills, metric = &quot;Chill_Portions&quot;, metric_label = &quot;Chill (Chill Portions)&quot;, texcex = 1.5) info_heat &lt;- plot_climate_scenarios( climate_scenario_list = chills, metric = &quot;GDH&quot;, metric_label = &quot;Heat (Growing Degree Hours)&quot;, texcex = 1.5) info_frost &lt;- plot_climate_scenarios( climate_scenario_list=chills, metric=&quot;Frost_H&quot;, metric_label=&quot;Frost hours&quot;, texcex=1.5) Now we can see the trends in chill and heat accumulation, as well as in frost hours for Klein-Altendorf. As we saw earlier, the function didn’t only return the plot, but also some supplementary information, which we stored in the the info... objects in the latest code chunk. If you inspect these objects, you’ll see that they contain the names of the climate models for each of the subplots (in addition to the time series labels for the historic plot). Since we used the same models each time, all information is listed multiple times. Let’s only look at this once, and only for one of the plots: info_chill[[2]] code Label 1 bcc-csm1-1 2 BNU-ESM 3 CanESM2 4 CESM1-BGC 5 MIROC-ESM 6 CNRM-CM5 7 ACCESS1-0 8 CSIRO-Mk3-6-0 9 GFDL-CM3 10 GFDL-ESM2G 11 GFDL-ESM2M 12 inmcm4 13 IPSL-CM5A-LR 14 IPSL-CM5A-MR 15 CCSM4 These labels aren’t provided directly in the plot, because they would take up quite a bit of space. Instead, each model is specified by a number, with the key to these number codes given in this table. If you don’t like the design of this figure, don’t worry. We’ll be making our own version soon (and there’s also a more modern version in chillR now that we’ll get to know later). Exercises on generating CMIP5 temperature scenarios Please document all results of the following assignments in your learning logbook. Analyze the historic and future impact of climate change on three agroclimatic metrics of your choice, for the location you’ve chosen for your earlier analyses. "],["plot_future.html", "Chapter 18 Plotting future scenarios Learning goals for this lesson 18.1 Making attractive plots 18.2 The results Exercises on plotting future projections", " Chapter 18 Plotting future scenarios Learning goals for this lesson Learn how we can use the ggplot2 package to make an appealing illustration of the chill projection results 18.1 Making attractive plots The default function in chillR can produce plots of the output of climate impact projections, but you may not like their design. With the current version of the plot_climate_scenarios function, there’s not much you can do to change the appearance of the plot. This is mainly because this function was written a while ago, before I became familiar with the ggplot2 functions. Today we want to try and reproduce a similar figure using ggplot. In fact, Eduardo Fernandez has already produced a function for this, which is included in chillR. We’ll still build this up gradually in this chapter because this provides a nice opportunity for demonstrating how we can build up complex plots using ggplot. I edited Eduardo’s code a bit to make this easier to follow, but the basic ideas are from him. Let’s first (install and) load all needed packages. New ones we’re using here are ggpmisc and patchwork. We’ll be building on our previous work, so we’ll have to load the outputs we produced in chapters Historic temperature scenarios and Making CMIP6 scenarios now. library(kableExtra) library(chillR) library(tidyverse) library(ggpmisc) library(patchwork) chill_hist_scenario_list &lt;- load_temperature_scenarios(&quot;data&quot;, &quot;Bonn_hist_chill_305_59&quot;) actual_chill &lt;- read_tab(&quot;data/Bonn_observed_chill_305_59.csv&quot;) chill_future_scenario_list &lt;- load_temperature_scenarios(&quot;data/future_climate&quot;,&quot;Bonn_futurechill_305_59&quot;) chills &lt;- make_climate_scenario( chill_hist_scenario_list, caption = &quot;Historic&quot;, historic_data = actual_chill, time_series = TRUE) SSPs &lt;- c(&quot;ssp126&quot;, &quot;ssp245&quot;, &quot;ssp370&quot;, &quot;ssp585&quot;) Times &lt;- c(2050, 2085) list_ssp &lt;- strsplit(names(chill_future_scenario_list), &#39;\\\\.&#39;) %&gt;% map(2) %&gt;% unlist() list_gcm &lt;- strsplit(names(chill_future_scenario_list), &#39;\\\\.&#39;) %&gt;% map(3) %&gt;% unlist() list_time &lt;- strsplit(names(chill_future_scenario_list), &#39;\\\\.&#39;) %&gt;% map(4) %&gt;% unlist() for(SSP in SSPs) for(Time in Times) { # find all scenarios for the ssp and time chill &lt;- chill_future_scenario_list[list_ssp == SSP &amp; list_time == Time] names(chill) &lt;- list_gcm[list_ssp == SSP &amp; list_time == Time] if(SSP == &quot;ssp126&quot;) SSPcaption &lt;- &quot;SSP1&quot; if(SSP == &quot;ssp245&quot;) SSPcaption &lt;- &quot;SSP2&quot; if(SSP == &quot;ssp370&quot;) SSPcaption &lt;- &quot;SSP3&quot; if(SSP == &quot;ssp585&quot;) SSPcaption &lt;- &quot;SSP5&quot; if(Time == &quot;2050&quot;) Time_caption &lt;- &quot;2050&quot; if(Time == &quot;2085&quot;) Time_caption &lt;- &quot;2085&quot; chills &lt;- chill %&gt;% make_climate_scenario( caption = c(SSPcaption, Time_caption), add_to = chills) } As you may know by now, ggplot works best with all data arranged in a single data.frame rather than the kind of list we’ve stored our projection data in. Each row of this data.frame should contain information about the GCM, the SSP and the Year. This is most easily done by looping through the elements of our chill projection list, extracting the needed information and assembling it in a new, long data.frame. # We&#39;ll first process the past scenarios (element 1 of the chills list). # Within the data element, we have a list of multiple data.frames for # the various past scenarios. # Using a &#39;for&#39; loop, we cycle through all these data.frames. for(nam in names(chills[[1]]$data)) { # Extract the data frame. ch &lt;- chills[[1]]$data[[nam]] # Add columns for the new information we have to add and fill them. ch[,&quot;GCM&quot;] &lt;- &quot;none&quot; ch[,&quot;SSP&quot;] &lt;- &quot;none&quot; ch[,&quot;Year&quot;] &lt;- as.numeric(nam) # Now check if this is the first time we&#39;ve gone through this loop. # If this is the first time, the ch data.frame becomes the output # object (past_simulated). # If it is not the first time (&#39;else&#39;), we add the current data.frame # to the &#39;past_simulated&#39; object if(nam == names(chills[[1]]$data)[1]) past_simulated &lt;- ch else past_simulated &lt;- rbind(past_simulated, ch) } # We add another column called &#39;Scenario&#39; and label all rows as &#39;Historical&#39; past_simulated[&quot;Scenario&quot;] &lt;- &quot;Historical&quot; kable(head(past_simulated)) %&gt;% kable_styling(&quot;striped&quot;, position = &quot;left&quot;,font_size = 8) Season End_year Season_days Data_days Perc_complete Chill_Portions GDH Frost_H GCM SSP Year Scenario 2001/2002 2002 120 120 100 83.24774 3092.197 724 none none 1980 Historical 2002/2003 2003 120 120 100 78.11408 2625.598 747 none none 1980 Historical 2003/2004 2004 120 120 100 76.80742 1157.748 1039 none none 1980 Historical 2004/2005 2005 121 121 100 83.04621 1722.581 735 none none 1980 Historical 2005/2006 2006 120 120 100 85.16369 2679.577 547 none none 1980 Historical 2006/2007 2007 120 120 100 80.75687 2277.176 725 none none 1980 Historical # We&#39;ll want to add the historic observation too, so let&#39;s simplify the # pointer to this information for easier use later past_observed &lt;- chills[[1]][[&quot;historic_data&quot;]] head(past_observed) Season End_year Season_days Data_days Interpolated_days Perc_complete Chill_Portions GDH Frost_H 1973/1974 1974 120 120 0 100 85.34065 2166.376 498 1975/1976 1976 120 120 0 100 81.50011 1831.580 711 1976/1977 1977 121 121 0 100 83.37374 1892.026 741 1977/1978 1978 120 120 0 100 78.15125 2653.059 830 1978/1979 1979 120 120 0 100 67.29434 1428.630 1376 1979/1980 1980 120 120 0 100 82.00353 2356.143 702 Now we do the same thing for the future data: # Extract future data for(i in 2:length(chills)) for(nam in names(chills[[i]]$data)) {ch &lt;- chills[[i]]$data[[nam]] ch[,&quot;GCM&quot;] &lt;- nam ch[,&quot;SSP&quot;] &lt;- chills[[i]]$caption[1] ch[,&quot;Year&quot;] &lt;- chills[[i]]$caption[2] if(i == 2 &amp; nam == names(chills[[i]]$data)[1]) future_data &lt;- ch else future_data &lt;- rbind(future_data,ch) } head(future_data) Season End_year Season_days Data_days Perc_complete Chill_Portions GDH Frost_H GCM SSP Year 2001/2002 2002 120 120 100 80.97028 8259.938 269 ACCESS-CM2 SSP1 2050 2002/2003 2003 120 120 100 82.90012 7212.620 326 ACCESS-CM2 SSP1 2050 2003/2004 2004 120 120 100 85.66957 4313.888 469 ACCESS-CM2 SSP1 2050 2004/2005 2005 121 121 100 89.61488 5410.175 200 ACCESS-CM2 SSP1 2050 2005/2006 2006 120 120 100 87.91998 7665.567 88 ACCESS-CM2 SSP1 2050 2006/2007 2007 120 120 100 84.45896 6356.550 319 ACCESS-CM2 SSP1 2050 Now our data are in a format that ggplot should be able to work with. We have three metrics in our dataset: Chill_Portions, GDH and Frost_H. We’re not going to write an actual function now (though we probably should), but the code should be flexible enough to allow plotting all three metrics without major adjustments. So I’m defining a variable metric, and a variable axis_label that we can easily adjust later. The complex plot we’re going to produce is difficult (or even impossible) to make as a single ggplot plot, but this is no problem, because we can assemble multiple plots into a compound figure later. Here we’ll do this with the plot_layout function of the patchwork package. One problem that arises when we combine figures from multiple plots and we want to use common axes (the y-axis in this case) is that these axes may not be similar. The data in the various plots may span different ranges, so that the automatic selection of reasonable axis settings may lead to different results. Here, we’ll use the range function to identify reasonable axis extents that work across all plots. metric &lt;- &quot;GDH&quot; axis_label &lt;- &quot;Heat (in GDH)&quot; # get extreme values for the axis scale rng &lt;- range(past_observed[[metric]], past_simulated[[metric]], future_data[[metric]]) rng ## [1] 739.4306 20977.6554 Now we’re ready for our first plot. We’ll start with the past scenarios: past_plot &lt;- ggplot() + geom_boxplot(data = past_simulated, aes_string(&quot;as.numeric(Year)&quot;, metric,group=&quot;Year&quot;), fill = &quot;skyblue&quot;) ## Warning: `aes_string()` was deprecated in ggplot2 3.0.0. ## ℹ Please use tidy evaluation idioms with `aes()`. ## ℹ See also `vignette(&quot;ggplot2-in-packages&quot;)` for more information. ## This warning is displayed once every 8 hours. ## Call `lifecycle::last_lifecycle_warnings()` to see where this warning was ## generated. past_plot The general layout of this command should be familiar to you by now, but there’s one little detail I had to change here. You’ll have noticed that in many places in ggplot commands, we can simply write the names of the variables we want to use (as in group=Year). This is a bit unusual, because normally in R we have to place such strings in quotation marks. Otherwise, R thinks these are variable names and - if no such variable is defined - we get an error message. I don’t know how the designers of ggplot2, led by Hadley Wickham, a hero of the R community, managed to make this requirement go away here, but it sure makes life easier - until you’re trying to use actual variable names in a ggplot2 call. Then we’d actually like to have the distinction between strings and variable names back. Well, we can get it back by using the aes_string command instead of aes, as you can see in the call above. As I said earlier, we need to make sure that the y-axis can accommodate not only the data in this plot, but also all future scenarios. We can use the rng range we produced before. I’ll also adjust the axis labels (including for the y axis the customized axis_label we made above): past_plot &lt;- past_plot + scale_y_continuous( limits = c(0, round(rng[2] + rng[2]/10))) + labs(x = &quot;Year&quot;, y = axis_label) past_plot Now we already have a fine plot of the past scenarios, but to make sure it is formatted in a similar way as the future data, we still need some adjustments. Here we only have one plot, but for the future scenarios, we’ll produce multiple plots, once again using the facet_wrap function. This will automatically add some design elements to our plot. To ensure we have a consistent layout for the whole figure, we therefore also make this single plot into a facet. We’ll also choose our black and white theme again: past_plot &lt;- past_plot + facet_grid(~ Scenario) + theme_bw(base_size = 15) past_plot Finally, some finishing touches, related to the facet title (make background disappear and text bold) and the x-axis text (place at an angle, so that all year labels can be displayed properly, even when we change the text size). past_plot &lt;- past_plot + theme(strip.background = element_blank(), strip.text = element_text(face = &quot;bold&quot;), axis.text.x = element_text(angle=45, hjust=1)) past_plot This is our plot of past scenarios. Now let’s add the actual observations. I’ll make them blue, so that they can be distinguished from the outliers in the box_plots. That one is fairly straightforward: # add historic data past_plot &lt;- past_plot + geom_point(data = past_observed, aes_string(&quot;End_year&quot;, metric), col = &quot;blue&quot;) past_plot Now we have what we needed for the past. The plots for the future an be produced in a largely similar way. To organize things properly, we’ll produce one plot for the two scenarios for 2050 first, and then another one for 2085. Then we can display them as two groups of two plots each. I’ll save these two plots in a list. This wouldn’t really be necessary here, but such a structure would allow us to later add more scenarios, should that seem desirable. Before making the plots in such a list structure, let’s first see one being assembled. We’ll start with the year (y) 2050 y &lt;- 2050 future_2050 &lt;- ggplot(data= future_data[which(future_data$Year==y),]) + geom_boxplot(aes_string(&quot;GCM&quot;, metric, fill = &quot;GCM&quot;)) future_2050 So far, we have all SSPs mixed together here. We also can’t read anything on the y-axis. That’s no big deal, because the same information is contained in the color scheme, but it sure looks ugly. We’ll also add a bit of padding on the side of the plots (with the expand parameter), to ensure that the plot doesn’t look too crowded: future_2050 &lt;- future_2050 + facet_wrap(vars(SSP), nrow = 1) + scale_x_discrete(labels = NULL, expand = expansion(add = 1)) Also here, we need to adjust the axis limits, so that the future plots can use the same axis as the past plots. I’ll also add the scenario year to the plots. For this, I’m using the geom_text_npc function from the ggpmisc package: future_2050 &lt;- future_2050 + scale_y_continuous(limits = c(0, round(round(1.1*rng[2])))) + geom_text_npc(aes(npcx = &quot;center&quot;, npcy = &quot;top&quot;, label = Year), size = 5) future_2050 Finally, some cosmetics: we again choose the black and white theme, and we’ll remove all axis text and titles (they don’t add much, and they make the figure look crowded). We’ll also remove the y-axis ticks. We then want the legend at the bottom and format the facet title the same way as for the past plot. future_2050 &lt;- future_2050 + theme_bw(base_size = 15) + theme(axis.ticks.y = element_blank(), axis.text = element_blank(), axis.title = element_blank(), legend.position = &quot;bottom&quot;, legend.margin = margin(0, 0, 0, 0, &quot;cm&quot;), legend.background = element_rect(), strip.background = element_blank(), strip.text = element_text(face = &quot;bold&quot;), legend.box.spacing = unit(0, &quot;cm&quot;), plot.subtitle = element_text(hjust = 0.5, vjust = -1, size = 15 * 1.05, face = &quot;bold&quot;)) future_2050 The legend is still too large, but we’ll adjust that later. Now let’s implement the same procedure in a loop, where we make a list of two plots - one for 2050 and one for 2085: future_plot_list &lt;- list() time_points &lt;- c(2050, 2085) for(y in time_points) { future_plot_list[[which(y == time_points)]] &lt;- ggplot(data = future_data[which(future_data$Year==y),]) + geom_boxplot(aes_string(&quot;GCM&quot;, metric, fill=&quot;GCM&quot;)) + facet_wrap(vars(SSP), nrow = 1) + scale_x_discrete(labels = NULL, expand = expansion(add = 1)) + scale_y_continuous(limits = c(0, round(round(1.1*rng[2])))) + geom_text_npc(aes(npcx = &quot;center&quot;, npcy = &quot;top&quot;, label = Year), size = 5) + theme_bw(base_size = 15) + theme(axis.ticks.y = element_blank(), axis.text = element_blank(), axis.title = element_blank(), legend.position = &quot;bottom&quot;, legend.margin = margin(0, 0, 0, 0, &quot;cm&quot;), legend.background = element_rect(), strip.background = element_blank(), strip.text = element_text(face = &quot;bold&quot;), legend.box.spacing = unit(0, &quot;cm&quot;), plot.subtitle = element_text( hjust = 0.5, vjust = -1, size = 15 * 1.05, face = &quot;bold&quot;)) } future_plot_list ## [[1]] ## ## [[2]] Putting the plots together now is surprisingly easy. We just use the + sign. both_plots &lt;- past_plot + future_plot_list both_plots All the basics are there, but we need a few adjustments, mainly to the legend. For this, we use the plot_layout function of the patchwork package. This supports the production of such patchwork figures, e.g. by collecting all legends and removing duplicates. This is handy, because we only want one version of the legend drawn. We can also specify the width of the various plots. I’m making a vector c(1,1.8,1.8) (using a slightly more flexible formulation) to specify that the width of each set of future plots should be 1.8 times the width of the past scenario plot. plot &lt;- both_plots + plot_layout(guides = &quot;collect&quot;, widths = c(1,rep(2,length(future_plot_list)))) Now we can’t really see the plot any more, so let’s place the legend at the bottom. For some reason that probably has to do with the patchwork package, we have to add the corresponding theme call after an &amp; symbol. plot &lt;- plot &amp; theme(legend.position = &quot;bottom&quot;, legend.text = element_text(size=8), legend.title = element_text(size=10), axis.title.x = element_blank()) After doing this we get… 18.2 The results Now we have some fairly nice ggplot figures showing a heat analysis for Bonn: plot That’s it. Now we can try the same thing again for the other metrics. If we did everything right, we should be able to do this by just changing the metric and axis_label variables and running the whole code again. I’ll do that now, but I won’t show you the whole code: Finally, a quick demonstration about functions. If we wanted to make a generally applicable function that does all the processing we just set up, we’d still have to put a bit of effort in. We’d have to make sure that the function produces warnings or errors when it’s fed with inappropriate inputs, and we’d really have to ensure that it’s flexible enough to deal with various types of inputs. But let’s assume we only want to use it with data that has the same structure as what we’ve used so far. Then we can just take all the commands so far and wrap them in a function call: plot_scenarios_gg &lt;- function(past_observed, past_simulated, future_data, metric, axis_label, time_points) { rng &lt;- range(past_observed[[metric]], past_simulated[[metric]], future_data[[metric]]) past_plot &lt;- ggplot() + geom_boxplot(data = past_simulated, aes_string(&quot;as.numeric(Year)&quot;, metric, group=&quot;Year&quot;), fill=&quot;skyblue&quot;) + scale_y_continuous(limits = c(0, round(round(1.1*rng[2])))) + labs(x = &quot;Year&quot;, y = axis_label) + facet_grid(~ Scenario) + theme_bw(base_size = 15) + theme(strip.background = element_blank(), strip.text = element_text(face = &quot;bold&quot;), axis.text.x = element_text(angle=45, hjust=1)) + geom_point(data = past_observed, aes_string(&quot;End_year&quot;, metric), col=&quot;blue&quot;) future_plot_list &lt;- list() for(y in time_points) { future_plot_list[[which(y == time_points)]] &lt;- ggplot(data = future_data[which(future_data$Year==y),]) + geom_boxplot(aes_string(&quot;GCM&quot;, metric, fill=&quot;GCM&quot;)) + facet_wrap(vars(SSP), nrow = 1) + scale_x_discrete(labels = NULL, expand = expansion(add = 1)) + scale_y_continuous(limits = c(0, round(round(1.1*rng[2])))) + geom_text_npc(aes(npcx = &quot;center&quot;, npcy = &quot;top&quot;, label = Year), size = 5) + theme_bw(base_size = 15) + theme(axis.ticks.y = element_blank(), axis.text = element_blank(), axis.title = element_blank(), legend.position = &quot;bottom&quot;, legend.margin = margin(0, 0, 0, 0, &quot;cm&quot;), legend.background = element_rect(), strip.background = element_blank(), strip.text = element_text(face = &quot;bold&quot;), legend.box.spacing = unit(0, &quot;cm&quot;), plot.subtitle = element_text(hjust = 0.5, vjust = -1, size = 15 * 1.05, face = &quot;bold&quot;)) } plot &lt;- (past_plot + future_plot_list + plot_layout(guides = &quot;collect&quot;, widths = c(1,rep(2,length(future_plot_list)))) ) &amp; theme(legend.position = &quot;bottom&quot;, legend.text = element_text(size = 8), legend.title = element_text(size = 10), axis.title.x=element_blank()) plot } Now we can produce the same outputs a bit more quickly: plot_scenarios_gg(past_observed = past_observed, past_simulated = past_simulated, future_data = future_data, metric = &quot;GDH&quot;, axis_label = &quot;Heat (in Growing Degree Hours)&quot;, time_points = c(2050, 2085)) plot_scenarios_gg(past_observed = past_observed, past_simulated = past_simulated, future_data = future_data, metric = &quot;Chill_Portions&quot;, axis_label = &quot;Chill (in Chill Portions)&quot;, time_points = c(2050, 2085)) plot_scenarios_gg(past_observed = past_observed, past_simulated = past_simulated, future_data = future_data, metric = &quot;Frost_H&quot;, axis_label = &quot;Frost duration (in hours)&quot;, time_points = c(2050, 2085)) Exercises on plotting future projections Please document all results of the following assignments in your learning logbook. Produce similar plots for the weather station you selected for earlier exercises. "],["chill_model_comparison.html", "Chapter 19 Chill model comparison Learning goals for this lesson 19.1 Safe Winter Chill 19.2 Chill metrics 19.3 An animated plot of relative changes in Safe Winter Chill Exercises on chill model comparison", " Chapter 19 Chill model comparison Learning goals for this lesson Understand and apply the concept of Safe Winter Chill Learn how to assess past and future changes in Safe Winter Chill using multiple chill models Learn how to illustrate results of such an assessment in a heat map Apply lessons learned earlier to plot changes of Safe Winter Chill over time Understand how such a plot can be animated using the gganimate package 19.1 Safe Winter Chill I already mentioned the concept of Safe Winter Chill, which is defined as the 10% quantile of the kind of chill distributions we’ve generated in the previous lessons. For growers, this measure corresponds to the amount of chill that is likely to be exceeded in 90% of all years. A specific tree cultivar with a chilling requirement that corresponds to Safe Winter Chill can be expected to meet this requirement about 90% of the time. Besides practical usefulness, Safe Winter Chill also offers an opportunity for reducing the complexity of our simulation results by computing the 10% quantiles of each of the distributions we generated. While such a reduction always involves a loss of information, it gives us the opportunity to present our data in different, possibly more attractive, formats. An example of such a format is a heat map, which we’ll use here to illustrate differences in the behavior of the various chill models that have been used in the literature (and sometimes in practice). 19.2 Chill metrics A list of 13 chill metrics has recently been compiled and published by Eduardo Fernandez, whose recent paper (Fernandez et al., 2020b) provides the blueprint for the present analysis. Eduardo has compiled these models in the dormancyR package, which he has made available via GitHub. Using the devtools package, we can install this directly from github. We also need chillR, because Eduardo did not include in this package the chill models that are already contained in chillR. Let’s install the dormancyR package, load dormancyR and chillR and check what models are available there. We’ll also design nicer names for them that we’ll use for the plots later. library(chillR) library(devtools) install_github(&quot;EduardoFernandezC/dormancyR&quot;) library(dormancyR) hourly_models &lt;- list(Chilling_units = chilling_units, Low_chill = low_chill_model, Modified_Utah = modified_utah_model, North_Carolina = north_carolina_model, Positive_Utah = positive_utah_model, Chilling_Hours = Chilling_Hours, Utah_Chill_Units = Utah_Model, Chill_Portions = Dynamic_Model) daily_models &lt;- list(Rate_of_Chill = rate_of_chill, Chill_Days = chill_days, Exponential_Chill = exponential_chill, # Triangular_Chill_Haninnen = triangular_chill_1, Triangular_Chill_Legave = triangular_chill_2) metrics &lt;- c(names(daily_models), names(hourly_models)) model_labels = c(&quot;Rate of Chill&quot;, &quot;Chill Days&quot;, &quot;Exponential Chill&quot;, # &quot;Triangular Chill (Häninnen)&quot;, &quot;Triangular Chill (Legave)&quot;, &quot;Chilling Units&quot;, &quot;Low-Chill Chill Units&quot;, &quot;Modified Utah Chill Units&quot;, &quot;North Carolina Chill Units&quot;, &quot;Positive Utah Chill Units&quot;, &quot;Chilling Hours&quot;, &quot;Utah Chill Units&quot;, &quot;Chill Portions&quot;) data.frame(Metric = model_labels, &#39;Function name&#39; = metrics) Metric Function.name Rate of Chill Rate_of_Chill Chill Days Chill_Days Exponential Chill Exponential_Chill Triangular Chill (Legave) Triangular_Chill_Legave Chilling Units Chilling_units Low-Chill Chill Units Low_chill Modified Utah Chill Units Modified_Utah North Carolina Chill Units North_Carolina Positive Utah Chill Units Positive_Utah Chilling Hours Chilling_Hours Utah Chill Units Utah_Chill_Units Chill Portions Chill_Portions Now we want to apply all these chill models to our observed temperature record, as well as to the past and future temperature scenarios for Bonn. Fortunately, we saved the temperature data, so that we don’t have to run the time-consuming weather generation (and climate data download) again. We can simply load these data. Here’s how we do this for the past data (we’ll load the future scenarios in a loop later): Bonn_temps &lt;- read_tab(&quot;data/Bonn_temps.csv&quot;) Temps &lt;- load_temperature_scenarios(&quot;data&quot;, &quot;Bonn_hist_scenarios&quot;) Now we can apply the chill models. We’ve already seen how we can use models that use hourly temperature data as input. However, some of the models on the list require daily temperature only, so Eduardo wrote the tempResponse_list_daily function, which applies similar procedures to daily data. Unlike the tempResponse_daily_list function from chillR, this function doesn’t include a misstolerance parameter, so we have to manually remove all years with incomplete winter seasons. We save all results in the data/chill folder, using the prefix Bonn_multichill: Start_JDay &lt;- 305 End_JDay &lt;- 59 daily_models_past_scenarios &lt;- tempResponse_list_daily(Temps, Start_JDay = Start_JDay, End_JDay = End_JDay, models=daily_models) daily_models_past_scenarios &lt;- lapply( daily_models_past_scenarios, function(x) x[which(x$Perc_complete&gt;90),]) hourly_models_past_scenarios&lt;- tempResponse_daily_list(Temps, latitude = 50.866, Start_JDay = Start_JDay, End_JDay = End_JDay, models = hourly_models, misstolerance = 10) past_scenarios &lt;- daily_models_past_scenarios past_scenarios &lt;- lapply( names(past_scenarios), function(x) cbind(past_scenarios[[x]], hourly_models_past_scenarios[[x]][,names(hourly_models)])) names(past_scenarios) &lt;- names(daily_models_past_scenarios) daily_models_observed &lt;- tempResponse_daily(Bonn_temps, Start_JDay = Start_JDay, End_JDay = End_JDay, models = daily_models) daily_models_observed &lt;- daily_models_observed[which(daily_models_observed$Perc_complete&gt;90),] hourly_models_observed &lt;- tempResponse_daily_list(Bonn_temps, latitude=50.866, Start_JDay = Start_JDay, End_JDay = End_JDay, models = hourly_models, misstolerance = 10) past_observed &lt;- cbind( daily_models_observed, hourly_models_observed[[1]][,names(hourly_models)]) save_temperature_scenarios(past_scenarios, &quot;data/future_climate&quot;, &quot;Bonn_multichill_305_59_historic&quot;) write.csv(past_observed, &quot;data/future_climate/Bonn_multichill_305_59_observed.csv&quot;, row.names=FALSE) Now we apply similar procedures to the future data. Since we have eight scenarios again here, it makes sense to design this as a loop: SSPs &lt;- c(&quot;ssp126&quot;, &quot;ssp245&quot;,&quot;ssp370&quot;, &quot;ssp585&quot;) Times &lt;- c(2050, 2085) list_ssp &lt;- strsplit(names(chill_future_scenario_list), &#39;\\\\.&#39;) %&gt;% map(2) %&gt;% unlist() list_gcm &lt;- strsplit(names(chill_future_scenario_list), &#39;\\\\.&#39;) %&gt;% map(3) %&gt;% unlist() list_time &lt;- strsplit(names(chill_future_scenario_list), &#39;\\\\.&#39;) %&gt;% map(4) %&gt;% unlist() future_temps &lt;- load_temperature_scenarios(&quot;data/future_climate&quot;,&quot;Bonn_futuretemps&quot;) for(SSP in SSPs) for(Time in Times) { Temps &lt;- future_temps[list_ssp == SSP &amp; list_time == Time] names(Temps) &lt;- list_gcm[list_ssp == SSP &amp; list_time == Time] daily_models_future_scenarios &lt;- tempResponse_list_daily( Temps, Start_JDay = Start_JDay, End_JDay = End_JDay, models = daily_models) daily_models_future_scenarios&lt;-lapply( daily_models_future_scenarios, function(x) x[which(x$Perc_complete&gt;90),]) hourly_models_future_scenarios&lt;- tempResponse_daily_list( Temps, latitude = 50.866, Start_JDay = Start_JDay, End_JDay = End_JDay, models=hourly_models, misstolerance = 10) future_scenarios &lt;- daily_models_future_scenarios future_scenarios &lt;- lapply( names(future_scenarios), function(x) cbind(future_scenarios[[x]], hourly_models_future_scenarios[[x]][,names(hourly_models)])) names(future_scenarios)&lt;-names(daily_models_future_scenarios) chill&lt;-future_scenarios save_temperature_scenarios( chill, &quot;data/future_climate&quot;, paste0(&quot;Bonn_multichill_305_59_&quot;,Time,&quot;_&quot;,SSP)) } Now all scenarios we want to process and plot have been saved to disk. We can now load them and produce chill scenarios. chill_past_scenarios &lt;- load_temperature_scenarios( &quot;data/future_climate&quot;, &quot;Bonn_multichill_305_59_historic&quot;) chill_observed &lt;- read_tab(&quot;data/future_climate/Bonn_multichill_305_59_observed.csv&quot;) chills &lt;- make_climate_scenario(chill_past_scenarios, caption = &quot;Historical&quot;, historic_data = chill_observed, time_series = TRUE) for(SSP in SSPs) for(Time in Times) { chill &lt;- load_temperature_scenarios( &quot;data/future_climate&quot;, paste0(&quot;Bonn_multichill_305_59_&quot;,Time,&quot;_&quot;,SSP)) if(SSP == &quot;ssp126&quot;) SSPcaption &lt;- &quot;SSP1&quot; if(SSP == &quot;ssp245&quot;) SSPcaption &lt;- &quot;SSP2&quot; if(SSP == &quot;ssp370&quot;) SSPcaption &lt;- &quot;SSP3&quot; if(SSP == &quot;ssp585&quot;) SSPcaption &lt;- &quot;SSP5&quot; if(Time == &quot;2050&quot;) Time_caption &lt;- &quot;2050&quot; if(Time == &quot;2085&quot;) Time_caption &lt;- &quot;2085&quot; chills &lt;- make_climate_scenario(chill, caption = c(SSPcaption, Time_caption), add_to = chills) } Now we want to make a heat map of Safe Winter Chill, using the ggplot2 functions. This again requires reorganizing our data into a long data.frame. We also have to calculate the 10% quantiles from the distributions. Since all the chill models have different units, and numeric values differ greatly across the models, we normalize all the results, expressing them as changes relative to a 1980 baseline: for(i in 1:length(chills)) {ch &lt;- chills[[i]] if(ch$caption[1] == &quot;Historical&quot;) {GCMs &lt;- rep(&quot;none&quot;,length(names(ch$data))) SSPs &lt;- rep(&quot;none&quot;,length(names(ch$data))) Years &lt;- as.numeric(ch$labels) Scenario &lt;- rep(&quot;Historical&quot;, length(names(ch$data)))} else {GCMs &lt;- names(ch$data) SSPs &lt;- rep(ch$caption[1], length(names(ch$data))) Years &lt;- rep(as.numeric(ch$caption[2]), length(names(ch$data))) Scenario &lt;- rep(&quot;Future&quot;, length(names(ch$data)))} for(nam in names(ch$data)) {for(met in metrics) {temp_res &lt;- data.frame(Metric = met, GCM = GCMs[which(nam == names(ch$data))], SSP = SSPs[which(nam == names(ch$data))], Year = Years[which(nam == names(ch$data))], Result = quantile(ch$data[[nam]][,met],0.1), Scenario = Scenario[which(nam == names(ch$data))]) if(i == 1 &amp; nam == names(ch$data)[1] &amp; met == metrics[1]) results &lt;- temp_res else results &lt;- rbind(results, temp_res) } } } for(met in metrics) results[which(results$Metric == met),&quot;SWC&quot;] &lt;- results[which(results$Metric == met),&quot;Result&quot;]/ results[which(results$Metric == met &amp; results$Year == 1980), &quot;Result&quot;]-1 Now we’re ready for plotting the results. Since we’ll have different panels in this plot and we want axes to be consistent, we need to capture the full range of Safe Winter Chill change values. Then we can make our first heat map plot. Let’s start with the future (the ones where the GCM is not ‘none’). Note that in the aesthetics we’re using factor here for the y element. This ensures that the metrics are plotted in the order specified by the levels parameter. rng = range(results$SWC) p_future &lt;- ggplot(results[which(!results$GCM == &quot;none&quot;),], aes(GCM, y = factor(Metric, levels = metrics), fill = SWC)) + geom_tile() p_future This plot still combines information for both SSPs and both points in time. Let’s show these in separate facets: p_future &lt;- p_future + facet_grid(SSP ~ Year) p_future Now can start working on the design. Let’s choose the black and white scheme and make the axis text a bit smaller. The latter seems reasonable here, because we have a lot of text there, which will be hard to show at full size. p_future &lt;- p_future + theme_bw(base_size = 15) + theme(axis.text = element_text(size=6)) p_future The current color scheme makes it hard to distinguish subtle differences. Let’s use a red to blue color ramp with a few intermediate values. The colorRamps library has a few nice schemes, including the matlab.like color ramp, from which we choose 15 equally spaced values. We’ll also show the changes in percent, and set the scale limits to the full range of the data we determined earlier: library(colorRamps) p_future &lt;- p_future + scale_fill_gradientn(colours = matlab.like(15), labels = scales::percent, limits = rng) p_future We still need a few cosmetic adjustments. Let’s change the angle of the x-axis labels to 75°, so that the labels are actually readable. We’ll also add a nicer title to the legend (note the ‘backslash n’ commands that stand for line breaks), replace the automatic axis labels with the nicer ones we designed above and change the label of the y-axis to “Chill metric”. p_future &lt;- p_future + theme(axis.text.x = element_text(angle = 75, hjust = 1, vjust = 1)) + labs(fill = &quot;Change in\\nSafe Winter Chill\\nsince 1980&quot;) + scale_y_discrete(labels = model_labels) + ylab(&quot;Chill metric&quot;) p_future Now we can make the plot of past scenarios. The procedure is largely the same as above, so I’m not going to go through this in such detail. Note that we’re moving the x-axis to the top using the scale_x_continuous(position = \"top\") command. p_past&lt;- ggplot(results[which(results$GCM == &quot;none&quot;),], aes(Year, y = factor(Metric, levels=metrics), fill = SWC)) + geom_tile() p_past&lt;- p_past + theme_bw(base_size = 15) + theme(axis.text = element_text(size = 6)) p_past&lt;- p_past + scale_fill_gradientn(colours = matlab.like(15), labels = scales::percent, limits = rng) p_past&lt;- p_past + scale_x_continuous(position = &quot;top&quot;) p_past&lt;- p_past + labs(fill = &quot;Change in\\nSafe Winter Chill\\nsince 1980&quot;) + scale_y_discrete(labels = model_labels) + ylab(&quot;Chill metric&quot;) p_past Now we can combine the plots. We’ll again use the patchwork package for this. The layout is a bit different here from last time. Mainly the plots are now on top of each other (nrow=2, with relative heights specified by heights=c(1,2)). The changes to the facet strip now only come in at this stage. It’s handy that we can still specify this here, because now we can just write this command once, rather than separately for each of the subplots. chill_comp_plot&lt;- (p_past + p_future + plot_layout(guides = &quot;collect&quot;, nrow = 2, heights = c(1,3))) &amp; theme(legend.position = &quot;right&quot;, strip.background = element_blank(), strip.text = element_text(face = &quot;bold&quot;)) chill_comp_plot This is it. Note the major differences between the behaviors of the various model. Some models indicate that Safe Winter Chill is increasing, while other say it’s decreasing. This is a clear indication that model choice matters! 19.3 An animated plot of relative changes in Safe Winter Chill Finally, let’s explore another R package - gganimate - which can add a cool feature to figures produced with ggplot2. To make use of this, let’s produce a simpler representation of the Safe Winter Chill data. For this, let’s summarize the results across all the GCMs. We’ll also duplicate the historic data and assign one of each of the duplicates to each SSP scenario. This is needed for easily plotting the full time series, disaggregated by SSP. hist_results &lt;- results[which(results$GCM == &quot;none&quot;),] hist_results$SSP &lt;- &quot;SSP1&quot; hist_results_2 &lt;- hist_results hist_results_2$SSP &lt;- &quot;SSP2&quot; hist_results_3 &lt;- hist_results hist_results_3$SSP &lt;- &quot;SSP3&quot; hist_results_4 &lt;- hist_results hist_results_4$SSP &lt;- &quot;SSP5&quot; hist_results &lt;- rbind(hist_results, hist_results_2, hist_results_3, hist_results_4) future_results &lt;- results[which(!results$GCM == &quot;none&quot;),] GCM_aggregate &lt;- aggregate( future_results$SWC, by=list(future_results$Metric, future_results$SSP, future_results$Year), FUN=mean) colnames(GCM_aggregate) &lt;- c(&quot;Metric&quot;, &quot;SSP&quot;, &quot;Year&quot;, &quot;SWC&quot;) SSP_Time_series&lt;-rbind(hist_results[,c(&quot;Metric&quot;, &quot;SSP&quot;, &quot;Year&quot;, &quot;SWC&quot;)], GCM_aggregate) Now we can make a line plot showing changes in Safe Winter Chill over the two SSP scenarios for all of the chill metrics. This is very similar to the procedures above, except that now we’re using the geom_line command rather than geom_tile (there are some more minor differences). SSP_Time_series$Year &lt;- as.numeric(SSP_Time_series$Year) chill_change_plot&lt;- ggplot(data = SSP_Time_series, aes(x = Year, y = SWC, col = factor(Metric, levels = metrics))) + geom_line(lwd = 1.3) + facet_wrap(~SSP, nrow = 4) + theme_bw(base_size = 10) + labs(col = &quot;Change in\\nSafe Winter Chill\\nsince 1980&quot;) + scale_color_discrete(labels = model_labels) + scale_y_continuous(labels = scales::percent) + theme(strip.background = element_blank(), strip.text = element_text(face = &quot;bold&quot;)) + ylab(&quot;Safe Winter Chill&quot;) chill_change_plot Now as a final step, we’ll convert this into a moving picture using the transition_reveal function from the gganimate package. We’ll save the resulting animation. library(gganimate) library(gifski) library(png) library(transformr) ccp&lt;-chill_change_plot + transition_reveal(Year) animate(ccp, fps = 10) anim_save(&quot;data/chill_comparison_animation.gif&quot;, animation = last_animation()) Animation of chill development over time, relative to 1980 and evaluated with 13 chill models (note that this was loaded from the image we just produced - real-time generation did not work in the knitting procedure that produced this book) Exercises on chill model comparison Please document all results of the following assignments in your learning logbook. Perform a similar analysis for the location you’ve chosen for your exercises. Make a heat map illustrating past and future changes in Safe Winter Chill, relative to a past scenario, for the 13 chill models used here Produce an animated line plot of your results (summarizing Safe Winter Chill across all the GCMs). "],["simple_phenology.html", "Chapter 20 Simple phenology analysis Learning goals for this lesson 20.1 Phenology analysis 20.2 Time series analysis 20.3 p-hacking 20.4 The process that generates the data 20.5 An ecological theory to guide our analysis 20.6 Temperature correlations Exercises on simple phenology analysis", " Chapter 20 Simple phenology analysis Learning goals for this lesson Understand why phenology modeling is tricky Appreciate the dangers of p-hacking Appreciate the importance of a causal theory in data analysis 20.1 Phenology analysis Now we’ve finally reached the point in this module where we seriously start analyzing phenology. We’ll use the example of bloom dates of the pear cultivar Alexander Lucas that we already worked with in the frost analysis. As you may remember, we have a time series of first, full and last bloom dates recorded at Campus Klein-Altendorf between 1958 and 2019. For this analysis, I’ll just use the first bloom dates: If you want to work with this example on your own computer, you can download the file here: Download phenology data I suggest that you save this file in the data folder of your home directory: data/Alexander_Lucas_bloom_1958_2019.csv. Otherwise, you’ll have to adjust the path below. Note that the data are provided as a .csv file. To avoid any “comma vs. semicolon”-related problems, I recommend that you open it with the read_tab function. Alex &lt;- read_tab(&quot;data/Alexander_Lucas_bloom_1958_2019.csv&quot;) Alex &lt;- pivot_longer(Alex, cols = c(First_bloom:Last_bloom), names_to = &quot;Stage&quot;, values_to = &quot;YEARMODA&quot;) Alex_first &lt;- Alex %&gt;% mutate(Year = as.numeric(substr(YEARMODA, 1, 4)), Month = as.numeric(substr(YEARMODA, 5, 6)), Day = as.numeric(substr(YEARMODA, 7, 8))) %&gt;% make_JDay() %&gt;% filter(Stage == &quot;First_bloom&quot;) 20.2 Time series analysis The first analysis people often do with such a dataset is a simple analysis over time. Let’s first plot the data: ggplot(Alex_first, aes(Pheno_year, JDay)) + geom_point() + ylab(&quot;First bloom date (day of the year)&quot;) + xlab (&quot;Year&quot;) + theme_bw(base_size = 15) It’s a bit hard to see a clear pattern here, but let’s check if there is a trend over time. We’ve already encountered the Kendall test in an earlier lesson, and we can also apply this here: library(Kendall) Kendall(x = Alex_first$Pheno_year, y = Alex_first$JDay) ## tau = -0.186, 2-sided pvalue =0.03533 I’m getting a p-value of 0.035. The tau value is negative, so it seems we have a significant trend towards earlier bloom. To determine how strong this trend is, many researchers use regression analysis, with model coefficients fitted to data. Let’s try this. We first assume a linear relationship between time and bloom dates: \\[Bloomdate = a \\cdot Phenoyear + b\\] To make the code easier to read, I’ll name the Pheno_year x and the Bloom date (JDay) y. I’ll also plot the data using ggplot: x &lt;- Alex_first$Pheno_year y &lt;- Alex_first$JDay summary(lm(y ~ x)) ## ## Call: ## lm(formula = y ~ x) ## ## Residuals: ## Min 1Q Median 3Q Max ## -30.0959 -6.3591 -0.5959 6.6468 20.1238 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 429.16615 142.06000 3.021 0.0037 ** ## x -0.16184 0.07144 -2.266 0.0271 * ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 10.07 on 60 degrees of freedom ## Multiple R-squared: 0.0788, Adjusted R-squared: 0.06345 ## F-statistic: 5.133 on 1 and 60 DF, p-value: 0.0271 ggplot(Alex_first, aes(Year, JDay)) + geom_point() + geom_smooth(method = &#39;lm&#39;, formula = y ~ x) + ylab(&quot;First bloom date (day of the year)&quot;) + xlab (&quot;Year&quot;) + theme_bw(base_size = 15) If you examine the outputs carefully, you’ll see that we’re getting a best estimate for the slope of -0.16. We also get a p-value here, but for a time series we’re better off using the one returned by the Kendall test. If you look at the diagram, you’ll notice that many of the data points are still pretty far from the regression line, with many of them way outside the confidence interval that is shown. Maybe we can find another model that better describes the data. Many people would now start on a process of gradually making the model more complex, e.g. by fitting a second-order polynomial, or maybe a third-order polynomial… Let’s cut this process short and immediately fit a 25th-order polynomial: summary(lm(y ~ poly(x, 25))) ## ## Call: ## lm(formula = y ~ poly(x, 25)) ## ## Residuals: ## Min 1Q Median 3Q Max ## -13.7311 -4.5098 -0.1227 2.8640 15.4590 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 107.3387 1.0549 101.753 &lt; 0.0000000000000002 *** ## poly(x, 25)1 -22.8054 8.3063 -2.746 0.00937 ** ## poly(x, 25)2 -5.8672 8.3063 -0.706 0.48451 ## poly(x, 25)3 14.7725 8.3063 1.778 0.08377 . ## poly(x, 25)4 -5.3974 8.3063 -0.650 0.51995 ## poly(x, 25)5 -11.6801 8.3063 -1.406 0.16825 ## poly(x, 25)6 2.1928 8.3063 0.264 0.79329 ## poly(x, 25)7 -0.3034 8.3063 -0.037 0.97107 ## poly(x, 25)8 6.0115 8.3063 0.724 0.47391 ## poly(x, 25)9 -22.2895 8.3063 -2.683 0.01094 * ## poly(x, 25)10 5.9522 8.3063 0.717 0.47825 ## poly(x, 25)11 -6.1217 8.3063 -0.737 0.46590 ## poly(x, 25)12 3.2676 8.3063 0.393 0.69636 ## poly(x, 25)13 -14.8467 8.3063 -1.787 0.08229 . ## poly(x, 25)14 13.5180 8.3063 1.627 0.11237 ## poly(x, 25)15 10.1544 8.3063 1.222 0.22946 ## poly(x, 25)16 -12.6116 8.3063 -1.518 0.13767 ## poly(x, 25)17 -1.3315 8.3063 -0.160 0.87354 ## poly(x, 25)18 -6.3438 8.3063 -0.764 0.45000 ## poly(x, 25)19 14.9753 8.3063 1.803 0.07978 . ## poly(x, 25)20 3.4573 8.3063 0.416 0.67972 ## poly(x, 25)21 -29.1997 8.3063 -3.515 0.00121 ** ## poly(x, 25)22 10.4145 8.3063 1.254 0.21799 ## poly(x, 25)23 2.9898 8.3063 0.360 0.72100 ## poly(x, 25)24 -14.3045 8.3063 -1.722 0.09363 . ## poly(x, 25)25 -20.9324 8.3063 -2.520 0.01631 * ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 8.306 on 36 degrees of freedom ## Multiple R-squared: 0.6237, Adjusted R-squared: 0.3623 ## F-statistic: 2.386 on 25 and 36 DF, p-value: 0.008421 ggplot(Alex_first, aes(Year, JDay)) + geom_point() + geom_smooth(method=&#39;lm&#39;, formula = y ~ poly(x, 25)) + ylab(&quot;First bloom date (day of the year)&quot;) + xlab (&quot;Year&quot;) + theme_bw(base_size = 15) It’s a bit hard now of course to make a clear statement about the temporal trend, since there is no single number for the slope. The slope varies over time, but it can be calculated by taking the first derivative of the complex 25th-order polynomial we computed. But we got a stellar p-value, and almost all of the data points are contained in the confidence interval! It’s probably obvious to you that this is not a useful model. If we make the model equation increasingly more complex, we’ll eventually find a structure that can perfectly fit all data points. This is not desirable, however, because we have no reason to expect that there is such a perfect relationship between our independent and dependent variables. Each measurement (such as a bloom date recording) comes with an error, and, more importantly, there may also be other factors in addition to time that affect bloom dates. If we make our model more complex than we can reasonably expect the actual relationship to be, we run the risk of overfitting our model. This means that we may get a very good fit, but our regression equation isn’t very useful for explaining the actual process we’re trying to model. In the case of our 25th-order polynomial, we’re obviously looking at an overfit. In many other cases, however, overfits aren’t quite so easy to detect. The scientific literature is full of studies where authors took the structure of their regression model far beyond what could be considered a reasonable description of the underlying process. Especially in the field of machine-learning, overfitting is a very serious risk, in particular where the learning engines are basically black boxes that the analysts may not even fully understand. 20.3 p-hacking A concept that is closely related to overfitting and that also often occurs in machine-learning is that of p-hacking, also known as a fishing expedition. The idea behind these terms is that when you look at a sufficiently large dataset, with lots of variables, you’re bound to find correlations somewhere in this dataset, regardless of whether your data involves actual causal relationships. Screening large datasets for ‘significant’ relationships and then presenting these as meaningful correlations is bad scientific practice (Nuzzo, 2014)! Possibly, such screening can lead to hypotheses that can then be tested through further studies, but we should not rely on this to generate ‘facts’. 20.4 The process that generates the data Many researchers are focused on finding structure in the datasets they work with. While this can often produce useful insights, it can also lead to us neglecting an arguably more important objective of science - to find out how things work! What we really want to understand is the process that generates the data, rather than the data themselves. While this argument may seem like semantics, it involves a change in perspective that can have important implications for how we do research. Rather than digging straight into the numbers, we first need to sit back and think about what may actually be going on in the system we’re analyzing. We can then use causal diagrams to sketch out how we think our system works: \\[A \\to B\\] With this realization, we quickly come to the conclusion that our analysis so far has been a bit beside the point. Up to now, we were looking for the following relationship: \\[Time \\to Phenology\\] Can this possibly be what’s going on here? Can time drive phenology? While I won’t completely rule out that trees are somehow able to track the passage of time within their annual cycle, I’m pretty sure they have no idea what the current year is… 20.5 An ecological theory to guide our analysis Before we start on an analysis of the kind we’re dealing with here, we should have a theory of what’s going on. In this case, this would be an ecological theory about what drives tree phenology. Let’s start with a very simple theory: Temperature drives phenology. I guess we already knew this, but it may still be useful to state it explicitly: \\[Temperature \\to Phenology\\] As you can see, this theory doesn’t involve time. The reason why we were able to find statistical relationships earlier is not that time (as in the calendar year) actually affects phenology - it is that temperatures have been rising over the years, mainly in response to anthropogenic global warming. \\[Time \\to Temperature\\] Well, actually this is \\[Time \\to GreenhouseGasConcentrations \\to ClimateForcing \\to Temperature\\] Since temperature, especially at the local scale, is subject to considerable random variation, this relationship may not be particularly strong. The noise in this relationship can easily keep us from detecting the actual response of tree phenology during our time series. The full causal diagram of these three variables (without the greenhouse effect part) is \\[Time \\to Temperature \\to Phenology\\] Sometimes we have no data on the intermediate steps in such a diagram. In such cases, we either have to live with a model that doesn’t actually get to the direct causal mechanisms in play, or we have to get a bit more creative with our analysis. Fortunately, here we actually do have data on temperature, so we can focus on the direct causal relationship between temperature and phenology. 20.6 Temperature correlations Now that we have clarified that it would make more sense to narrow in on the temperature-phenology relationship, we gained some conceptual clarity, but we are faced with a much greater statistical challenge. In correlating years with bloom dates, we had just two series of numbers to look at, since we had exactly one bloom date per year. Temperature, in contrast, is a variable we can measure at different temporal scales. If we just look at the average annual temperature, the statistical challenge is similar to using just the year number. Let’s see if we can find a correlation for this. You may have to click the button to download weather data first. I’d suggest you save it then under data/TMaxTMin1958-2019_patched.csv. Download long-term weather data temperature &lt;- read_tab(&quot;data/TMaxTMin1958-2019_patched.csv&quot;) Tmin &lt;- temperature %&gt;% group_by(Year) %&gt;% summarise(Tmin = mean(Tmin)) Tmax &lt;- temperature %&gt;% group_by(Year) %&gt;% summarise(Tmax = mean(Tmax)) Annual_means &lt;- Tmin %&gt;% cbind(Tmax[,2]) %&gt;% mutate(Tmean = (Tmin + Tmax)/2) Annual_means &lt;- merge(Annual_means, Alex_first) Annual_means_longer &lt;- Annual_means[,c(1:4,10)] %&gt;% pivot_longer(cols = c(Tmin:Tmean), names_to = &quot;Variable&quot;, values_to = &quot;Temp&quot;) ggplot(Annual_means_longer, aes(x=Temp, y=JDay)) + geom_point() + geom_smooth(method=&quot;lm&quot;, formula=y~x) + facet_wrap(&quot;Variable&quot;) summary(lm(Annual_means$JDay ~ Annual_means$Tmin)) ## ## Call: ## lm(formula = Annual_means$JDay ~ Annual_means$Tmin) ## ## Residuals: ## Min 1Q Median 3Q Max ## -25.4960 -6.9227 -0.0472 6.9066 18.4940 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 140.288 8.610 16.293 &lt; 0.0000000000000002 *** ## Annual_means$Tmin -6.020 1.558 -3.864 0.000277 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 9.385 on 60 degrees of freedom ## Multiple R-squared: 0.1992, Adjusted R-squared: 0.1859 ## F-statistic: 14.93 on 1 and 60 DF, p-value: 0.0002765 summary(lm(Annual_means$JDay ~ Annual_means$Tmax)) ## ## Call: ## lm(formula = Annual_means$JDay ~ Annual_means$Tmax) ## ## Residuals: ## Min 1Q Median 3Q Max ## -28.2420 -5.7340 0.3032 5.8515 19.4918 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 168.5020 12.9573 13.004 &lt; 0.0000000000000002 *** ## Annual_means$Tmax -4.3586 0.9198 -4.739 0.0000136 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 8.947 on 60 degrees of freedom ## Multiple R-squared: 0.2723, Adjusted R-squared: 0.2602 ## F-statistic: 22.45 on 1 and 60 DF, p-value: 0.00001363 summary(lm(Annual_means$JDay ~ Annual_means$Tmean)) ## ## Call: ## lm(formula = Annual_means$JDay ~ Annual_means$Tmean) ## ## Residuals: ## Min 1Q Median 3Q Max ## -25.9808 -5.5032 0.3793 6.1267 18.1822 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 173.467 12.379 14.013 &lt; 0.0000000000000002 *** ## Annual_means$Tmean -6.780 1.264 -5.363 0.00000138 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 8.623 on 60 degrees of freedom ## Multiple R-squared: 0.324, Adjusted R-squared: 0.3128 ## F-statistic: 28.76 on 1 and 60 DF, p-value: 0.000001381 There’s a relationship here, but this is still not really a convincing analysis. The main reason is that the time period we’re calculating the mean temperatures for is the whole year, even though bloom already occurs in spring. Temperatures after this can’t possibly affect the bloom date in the year of interest! Then why did we get such convincing results, with exceptionally low p values? Again, the reason is climate change. Temperatures have been rising over time, and phenology has advanced over time, so later years generally feature earlier bloom dates. To get to an analysis that has a chance of actually reflecting a causal relationship, however, we need to restrict the analysis to a range of dates that can plausibly affect bloom dates. Let’s write a quick function to screen for such correlations. To facilitate this, we’ll use JDay, i.e. the day of the year, to express the date. temps_JDays &lt;- make_JDay(temperature) corr_temp_pheno &lt;- function(start_JDay, # the start JDay of the period end_JDay, # the start JDay of the period temps_JDay = temps_JDays, # the temperature dataset bloom = Alex_first) # a data.frame with bloom dates { temps_JDay &lt;- temps_JDay %&gt;% mutate(Season = Year) if(start_JDay &gt; end_JDay) temps_JDay$Season[temps_JDay$JDay &gt;= start_JDay]&lt;- temps_JDay$Year[temps_JDay$JDay &gt;= start_JDay]+1 if(start_JDay &gt; end_JDay) sub_temps &lt;- subset(temps_JDay, JDay &lt;= end_JDay | JDay &gt;= start_JDay) if(start_JDay &lt;= end_JDay) sub_temps &lt;- subset(temps_JDay, JDay &lt;= end_JDay &amp; JDay &gt;= start_JDay) mean_temps &lt;- sub_temps %&gt;% group_by(Season) %&gt;% summarise(Tmin = mean(Tmin), Tmax = mean(Tmax)) %&gt;% mutate(Tmean = (Tmin + Tmax)/2) colnames(mean_temps)[1] &lt;- c(&quot;Pheno_year&quot;) temps_bloom &lt;- merge(mean_temps, bloom[c(&quot;Pheno_year&quot;, &quot;JDay&quot;)]) # Let&#39;s just extract the slopes of the regression model for now slope_Tmin &lt;- summary(lm(temps_bloom$JDay~temps_bloom$Tmin))$coefficients[2,1] slope_Tmean &lt;- summary(lm(temps_bloom$JDay~temps_bloom$Tmean))$coefficients[2,1] slope_Tmax &lt;- summary(lm(temps_bloom$JDay~temps_bloom$Tmax))$coefficients[2,1] c(start_JDay = start_JDay, end_JDay = end_JDay, length = length(unique(sub_temps$JDay)), slope_Tmin = slope_Tmin, slope_Tmean = slope_Tmean, slope_Tmax = slope_Tmax) } corr_temp_pheno(start_JDay = 305, end_JDay = 29, temps_JDay = temps_JDays, bloom = Alex_first) ## start_JDay end_JDay length slope_Tmin slope_Tmean slope_Tmax ## 305.000000 29.000000 91.000000 -1.821312 -2.135616 -2.237499 corr_temp_pheno(start_JDay = 305, end_JDay = 45, temps_JDay = temps_JDays, bloom = Alex_first) ## start_JDay end_JDay length slope_Tmin slope_Tmean slope_Tmax ## 305.000000 45.000000 107.000000 -2.254426 -2.655599 -2.799758 Now we can apply this function to all combinations of days we we find reasonable. Rather than trying all possible values, I’ll only use every 5th possible start and end date (that’s already enough computing work). library(colorRamps) # for the color scheme we&#39;ll use in the plot stJDs &lt;- seq(from = 1, to = 366, by = 10) eJDs &lt;- seq(from = 1, to = 366, by = 10) for(stJD in stJDs) for(eJD in eJDs) {correlations &lt;- corr_temp_pheno(stJD, eJD) if(stJD == 1 &amp; eJD == 1) corrs &lt;- correlations else corrs &lt;- rbind(corrs, correlations) } slopes &lt;- as.data.frame(corrs) %&gt;% rename(Tmin = slope_Tmin, Tmax = slope_Tmax, Tmean = slope_Tmean) %&gt;% pivot_longer(cols = c(Tmin : Tmax), values_to = &quot;Slope&quot;, names_to = &quot;Variable&quot;) ggplot(data = slopes, aes(x = start_JDay, y = length, fill = Slope)) + geom_tile() + facet_wrap(vars(Variable)) + scale_fill_gradientn(colours = matlab.like(15)) + ylab(&quot;Interval duration (days)&quot;) + xlab(&quot;Start date of temperature summary interval (Day of year)&quot;) + theme_bw(base_size = 15) While this plot can give us an idea about the periods during which temperatures are strongly related to bloom dates, we’ve actually veered slightly off track again. First, if we now went for the strongest possible influence and declared this as the main driver of bloom dates, we’d be p-hacking again. More importantly, we’re again looking for something that’s a bit different from what we should actually expect based on our ecological knowledge. We learned earlier that bloom dates are determined by two separate temperature-dependent processes: chilling and forcing. So we need more than one temperature period! We could now expand our p-hacking exercise to include multiple temperature summary variables. We could then also apply multiple regression, which can automatically identify variables that are correlated with bloom dates. Such fishing for correlations is a tedious and unsatisfying exercise, and it wouldn’t seem particularly enlightened. It’s likely to lead to overfits, and it can easily miss important temperature response periods by narrowing in on the phases that are most strongly correlated to the outcome variable. So let’s not do this and instead take a step back again to think about the theory. Here’s what we should actually expect: \\[\\substack{Temp_{chilling} \\to chill \\to\\\\ Temp_{forcing} \\to heat \\to} BloomDate\\] We could now start developing equations that describe what we think we know about chilling and forcing. Many colleagues have done this and then fitted the equations they came up with to observed phenology data. I don’t want to go into the details here, but I want to point out that most of the chill models we compared in the last lesson come from such exercises. Some of these are clearly way off the mark - and I assume the phenology models they were a part of still did pretty well. This is possible, because most phenology models have quite a few parameters, e.g. the start and end dates of chilling and forcing periods, the chilling and forcing requirements and the specifications of the temperature response curves during both phases. It’s easy for these parameters to compensate for each other, so that we get the right result for the wrong reasons. Such models have also often been fitted through trial and error or through less-than-convincing machine learning algorithms. So before we build a model, let’s see if we can find a bit more information to work with. In the next lesson, we’ll combine our ecological knowledge with a machine learning technique to figure out when trees are responsive to temperature. Exercises on simple phenology analysis Please document all results of the following assignments in your learning logbook. We’re not going to practice any of the analyses we’ve seen in this lesson, because I don’t find them particularly useful… Provide a brief narrative describing what p-hacking is, and why this is a problematic approach to data analysis. Provide a sketch of your causal understanding of the relationship between temperature and bloom dates. What do we need to know to build a process-based model from this? "],["pls_intro.html", "Chapter 21 Delineating temperature response phases with PLS regression Learning goals for this lesson 21.1 Detecting temperature response phases 21.2 Finding signals in hyperspectral remote sensing data 21.3 PLS regression for phenology analysis 21.4 A note of caution about PLS results 21.5 PLS analysis of ‘Alexander Lucas’ pears in Klein-Altendorf Exercises on chill model comparison", " Chapter 21 Delineating temperature response phases with PLS regression Learning goals for this lesson Understand the difference between simple regression approaches and the challenge to detect signals in noisy datasets Fully understand why relating high-resolution temperature records to phenology data is challenging Understand roughly what PLS regression does Be able to use the PLS_pheno function in chillR Be able to use ggplot to produce a nice figure of PLS results 21.1 Detecting temperature response phases In the last lesson, we tried - somewhat unsuccessfully - to find simple relationships between temperature during particular periods and phenology. Based on what we already know about phenology, we shouldn’t be particularly surprised by this. Spring phenology responds to exposure to chilling temperatures over a considerable period, during which the precise timing of this exposure is probably not important. The same applies to heat. We thus shouldn’t expect temperature during a single well-defined period to explain much of the observed variation in bloom or leafing dates. It seems more likely that temperatures during longer periods have an effect, possibly with varying levels of effectiveness. Methods that either fully consider temperatures during particular intervals or completely discard them are then not very promising. Another major problem is that we may have high-resolution temperature data, e.g. at daily or even hourly resolution, but we may not have a good way of correlating this to observed phenology. Statistically, this is because we are relating a small number of dependent variables - e.g. bloom dates, for which we usually just have one value per year - with a large number of independent variables - temperatures on each day, or during each hour, of the dormant season. Ordinary regression procedures don’t do well in such settings. The statistical challenge we are encountering here is not unique, however. Wanting to explain relatively few observations with lots of independent variables is actually a pretty common challenge, for example in remote sensing, and researchers in several disciplines have found ways of dealing with it. Let’s take a quick trip to the context where I first encountered promising analysis techniques. 21.2 Finding signals in hyperspectral remote sensing data I first worked with hyperspectral data in the context of a project in California, where we tried to detect spider mite damage in peaches (Luedeling et al., 2009c). Hyperspectral data often contain spectral reflectance (or absorption) data for radiation at hundreds (even thousands) of spectral wavelengths. Such spectra are then related to properties of particular materials. In our case, we had scored mite damage on 1132 peach leaves, for which we also collected reflectance spectra at wavelengths between 350 and 2500 nm. The following image shows two distinct reflectance profiles that represent healthy (0% damage) and heavily affected (90% damage) leaves. As you can see, the healthy leaves reflected less light at wavelengths around 500 nm and more light in a wide region around 1000 nm. We can easily see that here, but there are also mathematical procedures for detecting the signals caused by a particular property of the material (in this case mite damage). Hyperspectral reflectance spectra of healthy (0% damage) and highly mite-affected (90% damage) peach leaves in California. The lines show the averages, the shading illustrates the standard error of the mean (Luedeling et al., 2009c) To identify significant wavelengths, we should not look at this as a regression exercise, but rather address the situation as a signal detection problem. There is a lot of noise in such datasets, and we’re looking for the signal that is produced by the property we’re trying to measure. There are a number of methods to detect signals, and the blossoming machine learning literature keeps producing new ones. The method I adopted back then, and which we’re also going to learn about in this lesson, is Projection-to-Latent-Structures (PLS) regression, also known as Partial Least Squares regression. I prefer the complicated name, because it is more informative about what is going on. In principle, the method identifies latent structures, a sort of principal components, that best describe the variation in the dataset. These latent structures are then used in a regression procedure. I won’t talk about the mathematical details here, because that would be boring (and I also never fully understood them…) - what matters is that this is quite effective in identifying signals in noisy datasets, and it works in situations where we have lots of independent variables and just one dependent variable, for which we don’t necessarily need a lot of observations. Here are the PLS results for the peach leaf dataset, relating reflectance to mite damage: Coefficients of a PLS model relating mite damage to hyperspectral reflectance data. Particularly prominent wavelengths are marked (Luedeling et al., 2009c) We can see here that certain wavelengths are particularly strongly correlated with spider mite damage, so it might be possible to construct some sort of mite detection index by concentrating on wavelengths around 365 nm, 497 nm, 687 nm and so forth. Well, in this case that didn’t work so well. Except for cases of extreme damage, we didn’t really manage to detect mites. Or as one of my colleagues in the project put it: “Yes, at some point you can detect mite damage, but at that point, you could also detect mites by driving past the orchard at 60 miles an hour and just looking out of the window”… Well, fortunately, mite detection is not what we’re after here. What I want to point out is that the general statistical situation here is quite similar to the situation we’re facing when trying to relate high-resolution temperature to tree phenology. We have one dependent variable, just a few observations and lots of independent variables. So let’s see if PLS regression can help us with our temperature responses. 21.3 PLS regression for phenology analysis I first tried this kind of analysis with leaf emergence data of the walnut cultivar ‘Payne’ in California (Luedeling &amp; Gassner, 2012). We used PLS regression on a 54-year dataset, from 1953-2007 (with data for 1996 missing), recorded at the University of California at Davis. We related these leaf emergence dates with mean daily temperature, obtaining the following results: Results of a PLS regression analysis of the relationship between leaf emergence of ‘Payne’ walnuts in Davis, California, and daily mean temperature during the dormant season (Luedeling et al., 2012) This figure shows three versions of the analysis. In the analysis that produced the topmost set of figures, unprocessed daily mean temperatures were related to phenology dates. The results looked a little fuzzy, so I also ran the analysis with an 11-day running mean of temperatures (middle) and also with monthly data (bottom). Each set of plots contains illustrations of two results: the model coefficients, which are comparable to the coefficients of a normal regression model, and the ‘variable importance in the projection’ score (VIP), which indicates how important the contribution of each daily temperature is for the overall regression model. This is often interpreted as a sort of ‘significance’, which is decided on by using a cut-off threshold (often 0.8). So what do we see here? Basically, the model coefficients illustrate how leaf emergence dates are affected by particularly warm or cool conditions on a certain day. Positive model coefficients indicate a positive relationship between (Julian) leaf emergence dates and temperature, i.e. warmer than usual temperatures are correlated with later than usual leaf emergence dates. Conversely, negative model coefficients indicate a negative correlation, i.e. warm temperatures are related to early spring phenology. When we relate the emerging pattern of model coefficients to our understanding of the dormancy process, we can detect two distinct phases here. Between early November and mid-January, we see a period with positive model coefficients (and high VIP scores), i.e. warm conditions during this period are related to delayed leaf emergence in spring. This is consistent with what we might expect to be happening during the chilling period, when warm conditions might delay the fulfillment of chilling requirements, which would in turn delay all subsequent development. Following this period of positive model coefficients, we see a phase with negative coefficients between mid-January and (about) the end of March. Such coefficients are consistent with our expectation for the forcing phase, when warm temperatures would accelerate heat accumulation and thus advance leaf emergence. After early to mid-April, we see an inconsistent pattern. Given that leaf emergence happens in March to very early April, this is not surprising. Temperatures after this time cannot possibly affect budbreak dates. We also see that temperature response patterns before November are inconsistent. This may indicate that no chill accumulates before the end of October. We found quite similar patterns for the cultivars ‘Chandler’ and ‘Franquette’: VIP scores and model coefficients of PLS models relating leaf emergence dates of the walnut cultivars ‘Payne’, ‘Chandler’ and ‘Franquette’ in Davis, California, with mean daily temperatures (Luedeling et al., 2012) As you can see, the model coefficient patterns are a bit less clear here, including brief interruptions of the chilling period for the two other cultivars and lots of variation in heat and chilling responses. What does this mean? 21.4 A note of caution about PLS results We always have to keep in mind what PLS is and what it can do. This is a data mining technique that is usually used with a lot larger datasets than what we have here. Remember that in the spider mite example, we had over 1000 leaf samples. The method also works with less data, but we should not expect results to be crystal-clear then. It is thus very important that we don’t overinterpret every little feature of the plots that emerges. In fact, when we’re dealing with datasets as small as the ones we usually encounter in phenology analysis, I would strongly advise against using PLS as a data-mining tool, i.e. to detect patterns in the data. This tool should only be used in conjunction with a theory about how the system works. With this, we can use the PLS results to support or possibly refute certain ideas. In our case, we may start with a strong expectation of finding a chilling period (with positive model coefficients), followed by a forcing period (with negative coefficients). Our results are consistent with our theory, so - together with this theory - the picture that emerges is quite consistent. Important: always keep in mind that we’re using PLS with a very small dataset and we should not place too much emphasis on individual characteristics of the emerging model coefficient patterns (unless of course, we have other reasons to believe they are meaningful, or we find them across many similar analyses). In this context, it is important that we clarify our expectations before we run our analysis. It’s always possible to interpret random patterns that emerge in some reasonable-sounding way after the fact, but this practice - which is also known as rationalizing - isn’t particularly sound. It’s pretty common, however, in the discussions of machine-learning papers… 21.5 PLS analysis of ‘Alexander Lucas’ pears in Klein-Altendorf Now let’s try this analysis for ourselves. We’ll work with the dataset of pears (cultivar ‘Alexander Lucas’) we already looked at before (you can download it in the Simple phenology analysis chapter). We’ll start with first bloom, which we first have to convert to Julian dates: library(chillR) Alex_first &lt;- read_tab(&quot;data/Alexander_Lucas_bloom_1958_2019.csv&quot;) %&gt;% select(Pheno_year, First_bloom) %&gt;% mutate(Year = as.numeric(substr(First_bloom, 1, 4)), Month = as.numeric(substr(First_bloom, 5, 6)), Day = as.numeric(substr(First_bloom, 7, 8))) %&gt;% make_JDay() %&gt;% select(Pheno_year, JDay) %&gt;% rename(Year = Pheno_year, pheno = JDay) head(Alex_first) Year pheno 1958 122 1959 98 1960 101 1961 89 1962 117 1963 118 The PLS function we’ll use is a bit particular about the format of this data.frame, so I had to adjust the data.frame structure a bit and change the column names. Now we need temperature data, which we have also worked with before: KA_temps &lt;- read_tab(&quot;data/TMaxTMin1958-2019_patched.csv&quot;) %&gt;% make_JDay() head(KA_temps) DATE YEARMODA Year Month Day Tmin Tmax Tmin_source Tmax_source no_Tmin no_Tmax JDay 01-01-58 19580101 1958 1 1 5.0 7.50 NA NA FALSE FALSE 1 02-01-58 19580102 1958 1 2 1.5 9.00 NA NA FALSE FALSE 2 03-01-58 19580103 1958 1 3 -5.5 1.10 NA NA FALSE FALSE 3 04-01-58 19580104 1958 1 4 -5.5 0.50 NA NA FALSE FALSE 4 05-01-58 19580105 1958 1 5 3.5 2.75 NA NA FALSE TRUE 5 06-01-58 19580106 1958 1 6 3.0 5.00 NA NA FALSE FALSE 6 This data.frame can be more complex, but it needs to conform to the typical structure of chillR temperature datasets, i.e. it must have columns Year, Month, Day, Tmin, Tmax and in this case also JDay. With these two inputs, we can now use the PLS_pheno function from the chillR package. I note here that this function makes use of the plsr package. The PLS_pheno function requires as a minimum just a temperature dataset (weather_data) and a phenology dataset (bio_data). The result is a list of three objects: $object_type - just the string ‘PLS_Temp_pheno’, $pheno - the phenology input data, and $PLS_summary - the results we’re interested in. PLS_results &lt;- PLS_pheno(KA_temps, Alex_first) head(PLS_results$PLS_summary) Date JDay Coef VIP Tmean Tstdev 801 -152 0.0826036 0.3676590 18.32970 1.914004 802 -151 0.0932920 0.4159775 18.30846 1.884389 803 -150 0.0940262 0.4530441 18.27148 1.844368 804 -149 0.0899057 0.4609463 18.23742 1.886276 805 -148 0.0643769 0.4140336 18.19609 1.884567 806 -147 0.0103315 0.4476572 18.17148 1.855337 This summary object contains 6 columns: Date- the calendar day coded as MMDD, JDay- the Julian date, Coef- the PLS model coefficient, VIP- the variable importance in the projection score, Tmean - the mean temperature on the respective day, and Tstdev the standard deviation of temperatures on this day across the whole temperature dataset. This PLS_results element can now be plotted with the dedicated plotting function plot_PLS. Here’s what the results of this would look like: Temperature response pattern of ‘Alexander Lucas’ pears in Klein-Altendorf, as determined by PLS regression and plotted with the standard function in chillR What you see here now is a bit prettier than the figures from the original PLS publication. We have the VIP plot on top, with ‘important’ days highlighted in blue. In the second row, we have the model coefficients, with data for all the days identified as ‘important’ shown in red (when negative) or green (when positive). In the bottom row, we see the temperature dynamics during this time, with the mean temperature across all years shown by the black line, and the standard deviation indicated by the shading, which uses the same color scheme as the model coefficient plot. The gray shading at the left end of the plot shows the full range of observed bloom dates, with the dashed line indicating the mean bloom date. I hope you like how this figure looks - because you can’t really change much in it… It was also a lot of work to make this look ok. This is mainly because I put all of this together using the standard plotting functions in R, which (with my programming skills at the time) make it pretty difficult to produce complex figures. Since the sizes of all text elements and many other things had to be specifically modified, the only way to ensure acceptable outputs was to directly write the plot to an image file. Before we reproduce this using ggplot, let’s look at the parameters of the PLS_pheno function. split_month - the PLS_pheno function uses temperature data for an entire year, but we can decide when to start this year. The default is 7, which means that the phenological year ends at the end of July. runn_mean - the running mean to be applied to the temperature data before the analysis. We can set this to 1, but then we get a fairly messy temperature response pattern. The default is 11, which has usually worked pretty well. end_at_pheno_end - if this is set to TRUE (the default), then temperatures after the latest JDay of the phenology dataset aren’t considered in the analysis. use_Tmean - this can be set to TRUE, if your temperature dataset has a Tmean column and you want to use that rather than calculating means from Tmin and TMax. expl.var, ncomp.fix and crossvalidate refer to specifics of the PLS analysis, return.all indicates that you also want all the PLS outputs to be returned. Refer to the help function of PLS_pheno and possibly to the plsr package for more details. So now let’s make the same plot in ggplot: library(ggplot2) PLS_gg &lt;- PLS_results$PLS_summary %&gt;% mutate(Month = trunc(Date / 100), Day = Date - Month * 100, Date = NULL) PLS_gg$Date &lt;- ISOdate(2002, PLS_gg$Month, PLS_gg$Day) PLS_gg$Date[PLS_gg$JDay &lt;= 0] &lt;- ISOdate(2001, PLS_gg$Month[PLS_gg$JDay &lt;= 0], PLS_gg$Day[PLS_gg$JDay &lt;= 0]) PLS_gg &lt;- PLS_gg %&gt;% mutate(VIP_importance = VIP &gt;= 0.8, VIP_Coeff = factor(sign(Coef) * VIP_importance)) VIP_plot&lt;- ggplot(PLS_gg, aes(x = Date,y = VIP)) + geom_bar(stat = &#39;identity&#39;, aes(fill = VIP &gt; 0.8)) VIP_plot &lt;- VIP_plot + scale_fill_manual(name=&quot;VIP&quot;, labels = c(&quot;&lt;0.8&quot;, &quot;&gt;0.8&quot;), values = c(&quot;FALSE&quot; = &quot;grey&quot;, &quot;TRUE&quot; = &quot;blue&quot;)) + theme_bw(base_size = 15) + theme(axis.text.x = element_blank(), axis.ticks.x = element_blank(), axis.title.x = element_blank()) VIP_plot coeff_plot &lt;- ggplot(PLS_gg, aes(x = Date, y = Coef)) + geom_bar(stat =&#39;identity&#39;, aes(fill = VIP_Coeff)) + scale_fill_manual(name = &quot;Effect direction&quot;, labels = c(&quot;Advancing&quot;, &quot;Unimportant&quot;, &quot;Delaying&quot;), values = c(&quot;-1&quot; = &quot;red&quot;, &quot;0&quot; = &quot;grey&quot;, &quot;1&quot; = &quot;dark green&quot;)) + theme_bw(base_size = 15) + ylab(&quot;PLS coefficient&quot;) + theme(axis.text.x = element_blank(), axis.ticks.x = element_blank(), axis.title.x = element_blank() ) coeff_plot temp_plot &lt;- ggplot(PLS_gg) + geom_ribbon(aes(x = Date, ymin = Tmean - Tstdev, ymax = Tmean + Tstdev), fill = &quot;grey&quot;) + geom_ribbon(aes(x = Date, ymin = Tmean - Tstdev * (VIP_Coeff == -1), ymax = Tmean + Tstdev * (VIP_Coeff == -1)), fill = &quot;red&quot;) + geom_ribbon(aes(x = Date, ymin = Tmean - Tstdev * (VIP_Coeff == 1), ymax = Tmean + Tstdev * (VIP_Coeff == 1)), fill = &quot;dark green&quot;) + geom_line(aes(x = Date, y = Tmean)) + theme_bw(base_size = 15) + ylab(expression(paste(T[mean],&quot; (°C)&quot;))) temp_plot library(patchwork) plot&lt;- (VIP_plot + coeff_plot + temp_plot + plot_layout(ncol=1, guides = &quot;collect&quot;) ) &amp; theme(legend.position = &quot;right&quot;, legend.text = element_text(size = 8), legend.title = element_text(size = 10), axis.title.x = element_blank()) plot That was a bit of work, but now we have code that produces a nice compound figure that shows everything we expect of the outputs of a PLS analysis. So why not make a function from this? ggplot_PLS &lt;- function(PLS_results) { library(ggplot2) PLS_gg &lt;- PLS_results$PLS_summary %&gt;% mutate(Month = trunc(Date / 100), Day = Date - Month * 100, Date = NULL) PLS_gg$Date &lt;- ISOdate(2002, PLS_gg$Month, PLS_gg$Day) PLS_gg$Date[PLS_gg$JDay &lt;= 0] &lt;- ISOdate(2001, PLS_gg$Month[PLS_gg$JDay &lt;= 0], PLS_gg$Day[PLS_gg$JDay &lt;= 0]) PLS_gg &lt;- PLS_gg %&gt;% mutate(VIP_importance = VIP &gt;= 0.8, VIP_Coeff = factor(sign(Coef) * VIP_importance)) VIP_plot&lt;- ggplot(PLS_gg,aes(x=Date,y=VIP)) + geom_bar(stat=&#39;identity&#39;,aes(fill=VIP&gt;0.8)) VIP_plot &lt;- VIP_plot + scale_fill_manual(name=&quot;VIP&quot;, labels = c(&quot;&lt;0.8&quot;, &quot;&gt;0.8&quot;), values = c(&quot;FALSE&quot; = &quot;grey&quot;, &quot;TRUE&quot; = &quot;blue&quot;)) + theme_bw(base_size=15) + theme(axis.text.x = element_blank(), axis.ticks.x = element_blank(), axis.title.x = element_blank()) coeff_plot &lt;- ggplot(PLS_gg, aes(x = Date, y = Coef)) + geom_bar(stat =&#39;identity&#39;, aes(fill = VIP_Coeff)) + scale_fill_manual(name = &quot;Effect direction&quot;, labels = c(&quot;Advancing&quot;, &quot;Unimportant&quot;, &quot;Delaying&quot;), values = c(&quot;-1&quot; = &quot;red&quot;, &quot;0&quot; = &quot;grey&quot;, &quot;1&quot; = &quot;dark green&quot;)) + theme_bw(base_size = 15) + ylab(&quot;PLS coefficient&quot;) + theme(axis.text.x = element_blank(), axis.ticks.x = element_blank(), axis.title.x = element_blank()) temp_plot &lt;- ggplot(PLS_gg) + geom_ribbon(aes(x = Date, ymin = Tmean - Tstdev, ymax = Tmean + Tstdev), fill = &quot;grey&quot;) + geom_ribbon(aes(x = Date, ymin = Tmean - Tstdev * (VIP_Coeff == -1), ymax = Tmean + Tstdev * (VIP_Coeff == -1)), fill = &quot;red&quot;) + geom_ribbon(aes(x = Date, ymin = Tmean - Tstdev * (VIP_Coeff == 1), ymax = Tmean + Tstdev * (VIP_Coeff == 1)), fill = &quot;dark green&quot;) + geom_line(aes(x = Date, y = Tmean)) + theme_bw(base_size = 15) + ylab(expression(paste(T[mean],&quot; (°C)&quot;))) library(patchwork) plot&lt;- (VIP_plot + coeff_plot + temp_plot + plot_layout(ncol=1, guides = &quot;collect&quot;) ) &amp; theme(legend.position = &quot;right&quot;, legend.text = element_text(size = 8), legend.title = element_text(size = 10), axis.title.x = element_blank()) plot} ggplot_PLS(PLS_results) Now we have a function that can automatically plot the outputs of a PLS analysis. After solving this technical challenge, we can finally take a look at the results of our analysis… which do not look as expected. We see a strong bloom-advancing response to high temperatures in spring, but where is the chilling period? We’ll get to this in the next lesson, but maybe you already have some ideas? Exercises on chill model comparison Please document all results of the following assignments in your learning logbook. Briefly explain why you shouldn’t take the results of a PLS regression analysis between temperature and phenology at face value. What do you need in addition in order to make sense of such outputs? Replicate the PLS analysis for the Roter Boskoop dataset that you used in a previous lesson. Download Roter Boskoop dataset Write down your thoughts on why we’re not seeing the temperature response pattern we may have expected. What happened to the chill response? "],["pls_reflection.html", "Chapter 22 Successes and limitations of PLS regression analysis Learning goals for this lesson 22.1 PLS regression 22.2 PLS examples Exercises on chill model comparison", " Chapter 22 Successes and limitations of PLS regression analysis Learning goals for this lesson Learn about the mixed success of applying PLS regression in various contexts Understand important limitations of PLS regression 22.1 PLS regression We learned about Projection-to-Latent-Structures (PLS) regression (also known as Partial Least Squares regression) in the previous lesson on Delineating temperature response phases with PLS regression. In the context of phenology analysis, we can use this method to correlate high-resolution temperature data (e.g. daily data) with low-resolution (annual) data on the timing of phenology events. We realized already, however, that in the case of pears at Klein-Altendorf we were only really able to recognize the forcing period (where warm conditions advance bloom), while the chilling phase remained obscure. This was a bit disappointing, because the two dormancy phases had emerged quite clearly in the study on walnut leaf emergence in California. Let’s look at a few more examples to understand where and when this works - and to try to figure out why. 22.2 PLS examples 22.2.1 Grasslands on the Tibetan Plateau In one of our first applications of the PLS methodology, we evaluated the temperature responses of grasslands on the Tibetan Plateau. Specifically, we looked at how the beginning of the growing season has responded to climate change. When we just look at the trend over time, the pattern that emerges is rather confusing, with a fairly clear advancing trend until the late 1990s, followed by a surprising delay in ‘green up’ dates. Beginning of the growing season (BGS) for steppe (A) and meadow (B) vegetation on the Tibetan Plateau between 1982 and 2006, derived from 15-day NDVI composites obtained from the Advanced Very High Resolution Radiometer (AVHRR) sensor. BGS dates advanced markedly between 1982 and the mid 1990s, before retreating significantly after that. Consistent increases in temperature (C and D) indicate that observed changes are not linear responses to temperature. Lines in the graph represent 3-year running means (Yu et al., 2010) Similar to what we found for walnuts in California, we detected a conspicuous relationship between warm temperatures in winter and delayed beginning of the growing season in spring. Response of the BGS (A–D) in steppe and meadow vegetation of the Tibetan Plateau between 1982 and 2006 to monthly temperatures, according to PLS regression. The variable importance plots (VIP; C and D) indicate that temperatures in both spring (May and June) and winter (October through March) were important for explaining the response of BGS dates (VIP values above 0.8). Model coefficients (MC) of the centered and scaled data showed that warm winter temperatures delayed spring phenology (positive coefficients), whereas warm spring temperatures advanced the BGS (negative coefficients) for both steppe (A) and meadow (B). Including both effects into phenological models could substantially enhance our understanding of climate-change effects on vegetation at temperate and cold locations (Yu et al., 2010) We later added a spatial component to this analysis, investigating vegetation responses to temperature on a pixel-by-pixel basis. Correlations of monthly temperatures (left) and precipitation (right) with the beginning of the growing season (BGS) on the Tibetan Plateau, according to Partial Least Squares (PLS) regression. For each variable, pixels for which the variable-importance-in-the-projection score was &lt;0.8 are shown in gray. Pixels with insufficient data for PLS analysis are shown in white (Yu et al., 2012) In principle, the temperature response pattern of grasslands is thus similar to what we’ve seen for walnuts in California. The mechanisms at work here are probably quite different, so we should not jump to conclusions here without adequate knowledge of grassland ecology (which I don’t have). These findings are concerning, however, because our initial expectation would probably have been that increasing temperature allows vegetation to get going earlier in the year. Failure of the vegetation to keep up with increasingly available thermal resources indicates a possible mismatch of the established ecosystems with future climatic conditions. Such a mismatch is usually not sustainable, and it may open opportunities for invasive species that are better able to exploit the climatic ‘resources’ that will be available in the future. Well, since I don’t know much about what’s going on here ecologically, I’ll stop speculating here. Let’s rather turn our focus back to deciduous trees. 22.2.2 Deciduous trees In many of the early PLS analyses of tree phenology, I collaborated with Guo Liang, who was then a PhD student at the Kunming Institute of Botany in China (working in the group of Xu Jianchu, who also runs the regional office of World Agroforestry that is responsible for East and Central Asia). Guo Liang has since become a Full Professor, now running his own group at Northwest A &amp; F University of China. In his first analysis, Guo Liang looked at the phenology of Chinese chestnuts [https://en.wikipedia.org/wiki/Castanea_mollissima] grown in Beijing, China. Here are the findings: Results of Partial Least Squares (PLS) regression correlating first flowering dates for chestnut at Beijing Summer Palace with 11-day running means of daily mean temperatures from the previous July to June. Blue bars in the top panel indicate VIP values greater than 0.8, the threshold for variable importance. In the middle and bottom panels, red color means the model coefficients are negative (and important), while the green color indicates positive (and important) relationships between flowering and temperature. The black line in the bottom figure stands for the mean temperatures, while the gray, green and red areas represent the standard deviation of daily mean temperatures for each day of the year (Guo et al., 2013) Once again, we can quite clearly see the forcing period - the long period of consistent negative model coefficients from January to May. The chilling period is also somewhat visible, but model coefficients are much less consistent, with many ‘unimportant’ values and even some interruptions. A similar analysis of cherry phenology from Campus Klein-Altendorf produced quite similar results: Results of Partial Least Squares (PLS) regression of bloom dates for cv. ‘Schneiders späte Knorpelkirsche’ cherries in Klein-Altendorf, Germany, with 11-day running means of daily mean temperatures. The top panel shows Variable Importance in the Projection (VIP) scores, the middle panel model coefficients of the centered and scaled data, and the bottom panel mean temperatures (black line) and their standard deviation (grey areas). Blue bars in the top panel indicate values above 0.8, the threshold for variable importance. In the middle and bottom figures, data for these dates is shown in red whenever model coefficients are negative, and green when they are positive (Luedeling et al., 2013b) Also here, we see the pronounced forcing phase, which follows a chilling period that is difficult to delineate. A common pattern that emerges here is that the forcing phase is clearly visible, while the chilling phase is hard to see. This is disappointing after the very clear pattern we found earlier in California: Results of a PLS analysis relating leaf emergence dates of ‘Payne’ walnuts in California to mean daily temperature 22.2.3 Why we’re not seeing the chilling phase Does failure of the chilling phase to show up in the output of the PLS regression indicate that the method isn’t as useful for this purpose as we initially thought? Well, let’s not give up so easily, but rather look at what exactly PLS is sensitive to. In the spider mite example, PLS regression was sensitive to the quantity of reflected radiation that reached the sensor, with greater reflectance at certain wavelengths and lower reflectance at other wavelengths indicating mite damage severity. In detecting the forcing phase, PLS responded to temperature, with higher temperatures indicating greater heat accumulation, which was in turn related to early bloom. In all of these cases, changes in the response variable were monotonically related to changes in the signal, i.e. the greater the signal, the greater/smaller the response. The following figure illustrates why this doesn’t work for chill accumulation. Let’s look at the temperature ranges that the chill models respond to and compare this to the temperature range that we can observe at the three study locations during the winter months. To determine the range of effective temperatures for the various chill models we’ve already worked with, let’s see how much chill they produce at various levels of constant temperatures (I’m ommitting chill days here, because this model doesn’t work with constant temperatures): library(chillR) library(dormancyR) library(ggplot2) library(kableExtra) library(patchwork) hourly_models &lt;- list( Chilling_units = chilling_units, Low_chill = low_chill_model, Modified_Utah = modified_utah_model, North_Carolina = north_carolina_model, Positive_Utah = positive_utah_model, Chilling_Hours = Chilling_Hours, Utah_Chill_Units = Utah_Model, Chill_Portions = Dynamic_Model) daily_models &lt;- list( Rate_of_Chill = rate_of_chill, Exponential_Chill = exponential_chill, Triangular_Chill_Haninnen = triangular_chill_1, Triangular_Chill_Legave = triangular_chill_2) metrics &lt;- c(names(daily_models), names(hourly_models)) model_labels &lt;- c(&quot;Rate of Chill&quot;, &quot;Exponential Chill&quot;, &quot;Triangular Chill (Häninnen)&quot;, &quot;Triangular Chill (Legave)&quot;, &quot;Chilling Units&quot;, &quot;Low-Chill Chill Units&quot;, &quot;Modified Utah Chill Units&quot;, &quot;North Carolina Chill Units&quot;, &quot;Positive Utah Chill Units&quot;, &quot;Chilling Hours&quot;, &quot;Utah Chill Units&quot;, &quot;Chill Portions&quot;) for(T in -20:30) { hourly &lt;- sapply( hourly_models, function(x) x(rep(T,1000)) )[1000,] temp_frame &lt;- data.frame(Tmin = rep(T,1000), Tmax = rep(T,1000), Tmean = rep(T,1000)) daily &lt;- sapply( daily_models, function(x) x(temp_frame) )[1000,] if(T == -20) sensitivity &lt;- c(T = T, daily, hourly) else sensitivity &lt;- rbind(sensitivity, c(T = T, daily, hourly)) } sensitivity_normal &lt;- as.data.frame(cbind(sensitivity[,1], sapply(2:ncol(sensitivity), function(x) sensitivity[,x]/max(sensitivity[,x])))) colnames(sensitivity_normal) &lt;- colnames(sensitivity) sensitivity_gg &lt;- sensitivity_normal %&gt;% pivot_longer(Rate_of_Chill:Chill_Portions) # melt(sensitivity_normal,id.vars=&quot;T&quot;) sensitivity_gg$value[sensitivity_gg$value&lt;=0.001] &lt;- NA chill&lt;- ggplot(sensitivity_gg, aes(x = T, y = factor(name), size = value)) + geom_point(col = &quot;light blue&quot;) + scale_y_discrete(labels = model_labels) + ylab(&quot;Chill model&quot;) + xlab(&quot;Temperature (assumed constant, °C)&quot;) + xlim(c(-30, 40)) + theme_bw(base_size = 15) + labs(size = &quot;Chill \\nWeight&quot;) chill Now let’s summarize winter temperatures at the three locations for which we’ve seen phenology responses above: Klein-Altendorf (Germany), Beijing (China) and Davis (California). You can use the following buttons to download the temperature data. If you save them in the data subfolder of your working directory, all the code below should work well. Download weather data for Klein-Altendorf Download weather data for Beijing Download weather data for Davis KA_temps &lt;- read_tab(&quot;data/TMaxTMin1958-2019_patched.csv&quot;) %&gt;% make_JDay() %&gt;% filter(JDay &gt; 305 | JDay &lt; 90) %&gt;% stack_hourly_temps(latitude = 50.6) hh_KA &lt;- hist(KA_temps$hourtemps$Temp, breaks = c(-30:30), plot=FALSE) hh_KA_df &lt;- data.frame( T = hh_KA$mids, name = &quot;Klein-Altendorf, Germany&quot;, value = hh_KA$counts / max(hh_KA$counts)) hh_KA_df$value[hh_KA_df$value == 0] &lt;- NA Beijing_temps &lt;- read_tab(&quot;data/Beijing_weather.csv&quot;) %&gt;% make_JDay() %&gt;% filter(JDay &gt; 305 | JDay &lt; 90) %&gt;% stack_hourly_temps(latitude = 39.9) hh_Beijing &lt;- hist(Beijing_temps$hourtemps$Temp, breaks = c(-30:30), plot=FALSE) hh_Beijing_df&lt;-data.frame( T = hh_Beijing$mids, name = &quot;Beijing, China&quot;, value = hh_Beijing$counts / max(hh_Beijing$counts)) hh_Beijing_df$value[hh_Beijing_df$value==0]&lt;-NA Davis_temps &lt;- read_tab(&quot;data/Davis_weather.csv&quot;) %&gt;% make_JDay() %&gt;% filter(JDay &gt; 305 | JDay &lt; 90) %&gt;% stack_hourly_temps(latitude = 38.5) hh_Davis &lt;- hist(Davis_temps$hourtemps$Temp, breaks = c(-30:40), plot=FALSE) hh_Davis_df &lt;- data.frame( T = hh_Davis$mids, name = &quot;Davis, California&quot;, value = hh_Davis$counts / max(hh_Davis$counts)) hh_Davis_df$value[hh_Davis_df$value == 0] &lt;- NA hh_df&lt;-rbind(hh_KA_df, hh_Beijing_df, hh_Davis_df) locations&lt;- ggplot(data = hh_df, aes(x = T, y = name, size = value)) + geom_point(col = &quot;coral2&quot;) + ylab(&quot;Location&quot;) + xlab(&quot;Temperature (between November and March, °C)&quot;) + xlim(c(-30, 40)) + theme_bw(base_size = 15) + labs(size = &quot;Relative \\nfrequency&quot;) locations To compare the plots, let’s combine them in one figure (using the patchwork package): plot &lt;- (chill + locations + plot_layout(guides = &quot;collect&quot;, heights = c(1, 0.4)) ) &amp; theme(legend.position = &quot;right&quot;, legend.text = element_text(size = 10), legend.title = element_text(size = 12)) plot We already realized earlier that some of these models are probably pretty poor. So let’s simplify by only plotting chill according to the Dynamic Model: chill &lt;- ggplot(sensitivity_gg %&gt;% filter(name == &quot;Chill_Portions&quot;), aes(x = T, y = factor(name), size=value)) + geom_point(col = &quot;light blue&quot;) + scale_y_discrete(labels = &quot;Chill Portions&quot;) + ylab(&quot;Chill model&quot;) + xlab(&quot;Temperature (assumed constant, °C)&quot;) + xlim(c(-30, 40)) + theme_bw(base_size = 15) + labs(size = &quot;Chill \\nWeight&quot;) plot&lt;- (chill + locations + plot_layout(guides = &quot;collect&quot;, heights = c(0.5,1)) ) &amp; theme(legend.position = &quot;right&quot;, legend.text = element_text(size = 10), legend.title = element_text(size = 12)) plot If we compare the effective chill ranges with winter temperatures at the three locations, we can see that in Klein-Altendorf and Beijing, temperatures are quite often cooler than the effective temperature range for chill accumulation. At Davis, this is rarely the case. Temperatures that are too warm for chill accumulation occur quite frequently at Davis, and occasionally at the other two locations. This means that at Davis, it is reasonable to expect that warm temperatures in winter reduce chill accumulation. In the other two locations, this is not always the case. When it is relatively cold, warming may actually increase chill. When temperatures are relatively high, however, chill accumulation would be reduced by warming. At these two locations, there is thus no monotonic relationship between temperature and chill accumulation. In such a setting, we shouldn’t expect PLS regression to produce clear results. In the next chapter, we’ll learn about a way to overcome this problem. Exercises on chill model comparison Please document all results of the following assignments in your learning logbook. Briefly explain in what climatic settings we can expect PLS regression to detect the chilling phase - and in what settings this probably won’t work. How could we overcome this problem? "],["pls_chillforce.html", "Chapter 23 PLS regression with agroclimatic metrics Learning goals for this lesson 23.1 Adjusting PLS for use with non-monotonic relationships 23.2 PLS analysis with chilling and forcing data 23.3 Delineating chilling and forcing periods 23.4 ggplotting the results Exercises on chill model comparison", " Chapter 23 PLS regression with agroclimatic metrics Learning goals for this lesson Learn how we can make use of chill and heat models when looking for temperature response phases Learn how to produce daily chill accumulation data and plots Learn how to use the PLS_chill_force function to run a PLS analysis with chilling and forcing data Be able to delineate chilling and forcing phases based on PLS outputs Learn how to produce a complex PLS output figure using ggplot2 23.1 Adjusting PLS for use with non-monotonic relationships As we saw at the end of the previous lesson, the most likely reason why PLS regression failed to pick up the chilling period in relatively cold locations is that there is no monotonic relationship between temperature and chill effectiveness, i.e. warmer temperatures may either lead to less chill (when it’s fairly warm) or more chill (when it’s cold). To overcome this problem, we need to convert temperature into something that is monotonically related to chill accumulation. Maybe we can make use of the chill models we already learned about. If PLS holds its promise to identify chilling periods, it should be responsive to the daily rate of chill accumulation. This brings us back to an old problem - we don’t really know how to quantify chill accumulation accurately, and we don’t really trust the models we have. But let’s swallow these concerns for now and do such an analysis anyway. Note that if you’re ever tempted to do such a thing - swallow concerns that you know to be valid - don’t hide this from your audience. Clearly and explicitly state what you’ve done, as well as what problems may be associated with your strategy. So we’ll make this very clear here: We’ll be converting temperature data to chill (and heat) accumulation to run PLS analyses. This strategy assumes that the respective chill and heat models are reasonable approximations of the underlying biology. 23.2 PLS analysis with chilling and forcing data The chillR package has a function called PLS_chill_force that implements PLS analysis based on daily chill and heat accumulation rates. Let’s use this on our dataset of first bloom dates of ‘Alexander Lucas’ pears in Klein-Altendorf. When you look at the documentation of the PLS_chill_force function (e.g. by typing ?PLS_chill_force), you’ll see that this function requires a daily chill object (daily_chill_obj) as an input. This object contains daily chill and heat accumulation rates, as well as mean temperature data. Check out the documentation of daily_chill for more information on this. So we’ll start by applying the daily_chill function to produce such a daily chill object. We’ll also use a standard function in chillR (make_daily_chill_plot2) to plot daily chill accumulation: library(chillR) temps_hourly &lt;- read_tab(&quot;data/TMaxTMin1958-2019_patched.csv&quot;) %&gt;% stack_hourly_temps(latitude = 50.6) head(temps_hourly$hourtemps) DATE YEARMODA Year Month Day Tmin Tmax Tmin_source Tmax_source no_Tmin no_Tmax JDay Hour Temp 1 01-01-58 19580101 1958 1 1 5 7.5 NA NA FALSE FALSE 1 0 5 22452 01-01-58 19580101 1958 1 1 5 7.5 NA NA FALSE FALSE 1 1 5 44903 01-01-58 19580101 1958 1 1 5 7.5 NA NA FALSE FALSE 1 2 5 67354 01-01-58 19580101 1958 1 1 5 7.5 NA NA FALSE FALSE 1 3 5 89805 01-01-58 19580101 1958 1 1 5 7.5 NA NA FALSE FALSE 1 4 5 112256 01-01-58 19580101 1958 1 1 5 7.5 NA NA FALSE FALSE 1 5 5 daychill &lt;- daily_chill(hourtemps = temps_hourly, running_mean = 1, models = list( Chilling_Hours = Chilling_Hours, Utah_Chill_Units = Utah_Model, Chill_Portions = Dynamic_Model, GDH = GDH) ) head(daychill$daily_chill) YYMMDD Year Month Day Chilling_Hours Utah_Chill_Units Chill_Portions GDH Tmean no_Tmin no_Tmax 19580101 1958 1 1 21 24.0 0.0000000 9.7845597 5.391120 FALSE FALSE 19580102 1958 1 2 16 16.0 0.4444896 12.7332663 3.399713 FALSE FALSE 19580103 1958 1 3 5 0.0 0.0383026 0.0000000 -2.601803 FALSE FALSE 19580104 1958 1 4 10 3.0 0.3292715 0.0000000 -1.676056 FALSE FALSE 19580105 1958 1 5 24 24.0 1.3920031 0.0000000 3.020140 FALSE TRUE 19580106 1958 1 6 24 21.5 1.1161587 0.4716365 3.284117 FALSE FALSE dc &lt;- make_daily_chill_plot2(daychill, metrics = c(&quot;Chill_Portions&quot;), cumulative = FALSE, startdate = 300, enddate = 30, focusyears = c(2008), metriclabels = &quot;Chill Portions&quot;) In this plot, we can highlight specific years (with the focusyears parameter). We can also switch to cumulative view to illustrate how chill accumulation in a particular year differs from historic accumulation patterns. dc &lt;- make_daily_chill_plot2(daychill, metrics = c(&quot;Chill_Portions&quot;), cumulative = TRUE, startdate = 300, enddate = 30, focusyears = c(2008), metriclabels = &quot;Chill Portions&quot;) One special feature in this plot are the double ticks on the x-axis. These account for the additional day (29th February) that is added to the year in leap years. These leap days make Julian dates not map to precisely the same calendar dates in each year. The double ticks are an attempt to do justice to this ambiguity We can now feed this daily chill object to the PLS_chill_force function. We’ll also need the pear bloom data again: Alex_first &lt;- read_tab(&quot;data/Alexander_Lucas_bloom_1958_2019.csv&quot;) %&gt;% select(Pheno_year, First_bloom) %&gt;% mutate(Year = as.numeric(substr(First_bloom, 1, 4)), Month = as.numeric(substr(First_bloom, 5, 6)), Day = as.numeric(substr(First_bloom, 7, 8))) %&gt;% make_JDay() %&gt;% select(Pheno_year, JDay) %&gt;% rename(Year = Pheno_year, pheno = JDay) plscf &lt;- PLS_chill_force(daily_chill_obj = daychill, bio_data_frame = Alex_first, split_month = 6, chill_models = &quot;Chill_Portions&quot;, heat_models = &quot;GDH&quot;) head(plscf$Chill_Portions$GDH$PLS_summary) Date Type JDay Coef VIP MetricMean MetricStdev 701 Chill -183 0.0006500 0.3088661 0.0501720 0.2205416 702 Chill -182 -0.0828120 0.5363662 0.0499267 0.2194706 703 Chill -181 0.0169911 0.6376308 0.0501616 0.2204947 704 Chill -180 -0.1470842 0.7171508 0.0671167 0.2532628 705 Chill -179 0.2099085 1.7366297 0.0834634 0.2792043 706 Chill -178 0.0000000 0.0000000 0.0000000 0.0000000 We could have specified multiple chill and heat models, and the function would have evaluated all combinations of these models. This is why, to find the results, we have to look at plscf$Chill_Portions$GDH$PLS_summary. We can plot the results with the inbuilt function plot_PLS. Here’s how this is done: plot_PLS(plscf, PLS_results_path = &quot;data/plscf_outputs&quot;) Once again, this is a fairly old function that writes an image in a place you can specify. We’ll redo this with ggplot2 later. Plot of results from the PLS_chill_force procedure, as plotted with chillR’s standard plotting function We’ll reproduce this with ggplot2 soon, but you may already notice that the results don’t look very clear quite yet. To a considerable extent, this is because we didn’t use a running mean to smooth the chill and heat data. Especially for the Dynamic Model, this is worth considering, because Chill Portions accumulate in a stepwise manner, rather than continuously. Such steps aren’t reached every day, which adds a random element to estimations of daily rates. Let’s apply an 11-day running mean and plot the results again: plscf &lt;- PLS_chill_force(daily_chill_obj = daychill, bio_data_frame=Alex_first, split_month = 6, chill_models = &quot;Chill_Portions&quot;, heat_models = &quot;GDH&quot;, runn_means = 11) plot_PLS(plscf, PLS_results_path = &quot;data/plscf_outputs_11days&quot;) Plot of results from the PLS_chill_force procedure, with an 11-day running mean applied to chill and heat inputs, as plotted with chillR’s standard plotting function This looks a lot clearer now. We see two plots here, with the one on the left showing the relationship between bloom dates and chill accumulation, and the one on the right showing the same for heat accumulation. Note that these are plotted in different panels, but they emerged from the same PLS analysis, which thus related bloom dates to a total of 730 independent variables - chill and heat accumulation dates for each calendar day (if you set end_at_pheno_end = TRUE, minus all days after the latest bloom date). To find the chilling and forcing periods, we should now look for consistent periods of negative model coefficients on both sides of the figure. For the chilling period, we’ll look on the left, where the relationship of bloom dates with daily chill accumulation rates is shown, and for the forcing period, we’ll look right, where the same is shown for daily heat accumulation rates. Again, the forcing period is easier to see than the chilling phase. It’s approximately between early January and the bloom date (between mid-March and early May). The chilling period is still a bit hard to see, but we can now detect a phase between some point in November or early December and February where high chill accumulation rates are correlated with early bloom. In these delineations, I recommend to not focus too narrowly on ‘important’ values, but rather take a broad perspective in evaluating model coefficient dynamics. Always remember that PLS regression with small datasets may struggle to distinguish signals from noise, with random effects easily creeping in. We also need to remember that our chill and heat models aren’t perfect and that they don’t actually include much knowledge on dormancy physiology. We’ll discuss some more reasons for poor chilling period delineations later. 23.3 Delineating chilling and forcing periods The precise delineations of chilling and forcing periods are often a bit debatable, and there have often been slight disagreements about the precise dates to use. I would recommend taking both the plot and the detailed results table into account in deciding when periods start and end. More importantly, consider what you know about tree dormancy! Never lose sight of the ecological theory behind your analysis when you evaluate the results. My call on the present dataset would be a chilling period between 13th November and 3rd March (Julian dates -48 to 62) and a forcing period between 3rd January and the date of bloom (Julian dates 3 to 105.5, which represents the median of all bloom dates). We can illustrate these periods in the plot: plot_PLS(plscf, PLS_results_path = &quot;data/plscf_outputs_11days_periods&quot;, add_chill = c(-48,62), add_heat = c(3,105.5)) Plot of PLS_chill_force results, with our delineations of chilling (light blue) and forcing (light red) phases highlighted 23.4 ggplotting the results We’ve gone through most of what we need here already when we made the original PLS plots, but let’s do this again for the PLS_chill_force outputs. The only real change is that we need to split the results according to chill vs. heat analysis. We’ll use facet_wrap for this. First we need to prepare the data for ggplotting: PLS_gg &lt;- plscf$Chill_Portions$GDH$PLS_summary %&gt;% mutate(Month = trunc(Date/100), Day = Date - Month * 100, Date = ISOdate(2002, Month, Day)) PLS_gg[PLS_gg$JDay &lt;= 0,&quot;Date&quot;]&lt;- ISOdate(2001, PLS_gg$Month[PLS_gg$JDay &lt;= 0], PLS_gg$Day[PLS_gg$JDay &lt;= 0]) PLS_gg &lt;- PLS_gg %&gt;% mutate(VIP_importance = VIP &gt;= 0.8, VIP_Coeff = factor(sign(Coef) * VIP_importance)) chill_start_JDay &lt;- -48 chill_end_JDay &lt;- 62 heat_start_JDay &lt;- 3 heat_end_JDay &lt;- 105.5 chill_start_date &lt;- ISOdate(2001, 12, 31) + chill_start_JDay * 24 * 3600 chill_end_date &lt;- ISOdate(2001, 12, 31) + chill_end_JDay * 24 * 3600 heat_start_date &lt;- ISOdate(2001, 12, 31) + heat_start_JDay * 24 * 3600 heat_end_date &lt;- ISOdate(2001, 12, 31) + heat_end_JDay * 24 * 3600 This time we’ll start with the bottom plot, because that’s the most complicated one. It’s complicated, because we need to put different labels on the y-axes of the two facets. Since the daily chill accumulation rate is between 0 and ~1 Chill Portions, and the daily heat accumulation rate can reach 300 GDH and more, we also need different scales for the axes. We’ll start with the hardest plot, because the way we solve these problems may have implications for how we have to construct the other plots. library(ggplot2) temp_plot &lt;- ggplot(PLS_gg, x = Date) + annotate(&quot;rect&quot;, xmin = chill_start_date, xmax = chill_end_date, ymin = -Inf, ymax = Inf, alpha = .1, fill = &quot;blue&quot;) + annotate(&quot;rect&quot;, xmin = heat_start_date, xmax = heat_end_date, ymin = -Inf, ymax = Inf, alpha = .1, fill = &quot;red&quot;) + annotate(&quot;rect&quot;, xmin = ISOdate(2001, 12, 31) + min(plscf$pheno$pheno, na.rm = TRUE) * 24 * 3600, xmax = ISOdate(2001, 12, 31) + max(plscf$pheno$pheno, na.rm = TRUE) * 24 * 3600, ymin = -Inf, ymax = Inf, alpha = .1, fill = &quot;black&quot;) + geom_vline(xintercept = ISOdate(2001, 12, 31) + median(plscf$pheno$pheno, na.rm = TRUE) * 24 * 3600, linetype = &quot;dashed&quot;) + geom_ribbon(aes(x = Date, ymin = MetricMean - MetricStdev , ymax = MetricMean + MetricStdev), fill=&quot;grey&quot;) + geom_ribbon(aes(x = Date, ymin = MetricMean - MetricStdev * (VIP_Coeff == -1), ymax = MetricMean + MetricStdev * (VIP_Coeff == -1)), fill = &quot;red&quot;) + geom_ribbon(aes(x = Date, ymin = MetricMean - MetricStdev * (VIP_Coeff == 1), ymax = MetricMean + MetricStdev * (VIP_Coeff == 1)), fill = &quot;dark green&quot;) + geom_line(aes(x = Date, y = MetricMean )) temp_plot temp_plot &lt;- temp_plot + facet_wrap(vars(Type), scales = &quot;free_y&quot;, strip.position = &quot;left&quot;, labeller = labeller(Type = as_labeller( c(Chill = &quot;Chill (CP)&quot;, Heat = &quot;Heat (GDH)&quot;)))) + ggtitle(&quot;Daily chill and heat accumulation rates&quot;) + theme_bw(base_size = 15) + theme(strip.background = element_blank(), strip.placement = &quot;outside&quot;, strip.text.y = element_text(size =12), plot.title = element_text(hjust = 0.5), axis.title.y = element_blank() ) temp_plot I looked around a bit for an honest way to customize the y-axis labels for each facet, but didn’t find a viable solution. So I used the facet labels instead and moved them to the left side, using them as y-axis labels. The labeller element in facet_wrap can easily be customized with text of your choice. I also added a title to the plot. We can now use the same strategy to make the VIP and model coefficient plots (this is important, because the plots should have similar structures when we combine them later). VIP_plot&lt;- ggplot(PLS_gg, aes(x = Date, y = VIP)) + annotate(&quot;rect&quot;, xmin = chill_start_date, xmax = chill_end_date, ymin = -Inf, ymax = Inf, alpha = .1, fill = &quot;blue&quot;) + annotate(&quot;rect&quot;, xmin = heat_start_date, xmax = heat_end_date, ymin = -Inf, ymax = Inf, alpha = .1, fill = &quot;red&quot;) + annotate(&quot;rect&quot;, xmin = ISOdate(2001, 12, 31) + min(plscf$pheno$pheno, na.rm = TRUE) * 24 * 3600, xmax = ISOdate(2001, 12, 31) + max(plscf$pheno$pheno, na.rm = TRUE) * 24 * 3600, ymin = -Inf, ymax = Inf, alpha = .1, fill = &quot;black&quot;) + geom_vline(xintercept = ISOdate(2001, 12, 31) + median(plscf$pheno$pheno, na.rm = TRUE) * 24 * 3600, linetype = &quot;dashed&quot;) + geom_bar(stat = &#39;identity&#39;, aes(fill = VIP &gt; 0.8)) VIP_plot VIP_plot &lt;- VIP_plot + facet_wrap(vars(Type), scales = &quot;free&quot;, strip.position = &quot;left&quot;, labeller = labeller(Type = as_labeller( c(Chill = &quot;VIP for chill&quot;, Heat = &quot;VIP for heat&quot;)))) + scale_y_continuous( limits = c(0, max(plscf$Chill_Portions$GDH$PLS_summary$VIP))) + ggtitle(&quot;Variable Importance in the Projection (VIP) scores&quot;) + theme_bw(base_size = 15) + theme(strip.background = element_blank(), strip.placement = &quot;outside&quot;, strip.text.y = element_text(size = 12), plot.title = element_text(hjust = 0.5), axis.title.y = element_blank() ) VIP_plot VIP_plot &lt;- VIP_plot + scale_fill_manual(name = &quot;VIP&quot;, labels = c(&quot;&lt;0.8&quot;, &quot;&gt;0.8&quot;), values = c(&quot;FALSE&quot; = &quot;grey&quot;, &quot;TRUE&quot; = &quot;blue&quot;)) + theme(axis.text.x = element_blank(), axis.ticks.x = element_blank(), axis.title.x = element_blank(), axis.title.y = element_blank()) VIP_plot coeff_plot &lt;- ggplot(PLS_gg, aes(x = Date, y = Coef)) + annotate(&quot;rect&quot;, xmin = chill_start_date, xmax = chill_end_date, ymin = -Inf, ymax = Inf, alpha = .1, fill = &quot;blue&quot;) + annotate(&quot;rect&quot;, xmin = heat_start_date, xmax = heat_end_date, ymin = -Inf, ymax = Inf, alpha = .1, fill = &quot;red&quot;) + annotate(&quot;rect&quot;, xmin = ISOdate(2001, 12, 31) + min(plscf$pheno$pheno, na.rm=TRUE) * 24 * 3600, xmax = ISOdate(2001, 12, 31) + max(plscf$pheno$pheno, na.rm = TRUE) * 24 * 3600, ymin = -Inf, ymax = Inf, alpha = .1, fill = &quot;black&quot;) + geom_vline(xintercept = ISOdate(2001, 12, 31) + median(plscf$pheno$pheno, na.rm = TRUE) * 24 * 3600, linetype = &quot;dashed&quot;) + geom_bar(stat = &#39;identity&#39;, aes(fill = VIP_Coeff)) coeff_plot coeff_plot &lt;- coeff_plot + facet_wrap(vars(Type), scales = &quot;free&quot;, strip.position = &quot;left&quot;, labeller = labeller( Type = as_labeller( c(Chill = &quot;MC for chill&quot;, Heat = &quot;MC for heat&quot;)))) + scale_y_continuous( limits = c(min(plscf$Chill_Portions$GDH$PLS_summary$Coef), max(plscf$Chill_Portions$GDH$PLS_summary$Coef))) + ggtitle(&quot;Model coefficients (MC)&quot;) + theme_bw(base_size = 15) + theme(strip.background = element_blank(), strip.placement = &quot;outside&quot;, strip.text.y = element_text(size = 12), plot.title = element_text(hjust = 0.5), axis.title.y = element_blank() ) coeff_plot coeff_plot &lt;- coeff_plot + scale_fill_manual(name=&quot;Effect direction&quot;, labels = c(&quot;Advancing&quot;, &quot;Unimportant&quot;, &quot;Delaying&quot;), values = c(&quot;-1&quot; = &quot;red&quot;, &quot;0&quot; = &quot;grey&quot;, &quot;1&quot; = &quot;dark green&quot;)) + ylab(&quot;PLS coefficient&quot;) + theme(axis.text.x = element_blank(), axis.ticks.x = element_blank(), axis.title.x = element_blank(), axis.title.y = element_blank()) coeff_plot Now it’s time to combine the plots. We’ll use the patchwork package again. library(patchwork) plot&lt;- (VIP_plot + coeff_plot + temp_plot + plot_layout(ncol = 1, guides = &quot;collect&quot;) ) &amp; theme(legend.position = &quot;right&quot;, legend.text = element_text(size = 8), legend.title = element_text(size = 10), axis.title.x = element_blank()) plot Since I like what we’ve produced here, I’ll make a function out of it. plot_PLS_chill_force &lt;- function(plscf, chill_metric = &quot;Chill_Portions&quot;, heat_metric = &quot;GDH&quot;, chill_label = &quot;CP&quot;, heat_label = &quot;GDH&quot;, chill_phase = c(-48, 62), heat_phase = c(3, 105.5)) { PLS_gg &lt;- plscf[[chill_metric]][[heat_metric]]$PLS_summary %&gt;% mutate(Month = trunc(Date/100), Day = Date - Month * 100, Date = ISOdate(2002, Month, Day)) PLS_gg[PLS_gg$JDay &lt;= 0,&quot;Date&quot;]&lt;- ISOdate(2001, PLS_gg$Month[PLS_gg$JDay &lt;= 0], PLS_gg$Day[PLS_gg$JDay &lt;= 0]) PLS_gg &lt;- PLS_gg %&gt;% mutate(VIP_importance = VIP &gt;= 0.8, VIP_Coeff = factor(sign(Coef) * VIP_importance)) chill_start_date &lt;- ISOdate(2001, 12, 31) + chill_phase[1] * 24 * 3600 chill_end_date &lt;- ISOdate(2001, 12, 31) + chill_phase[2] * 24 * 3600 heat_start_date &lt;- ISOdate(2001, 12, 31) + heat_phase[1] * 24 * 3600 heat_end_date &lt;- ISOdate(2001, 12, 31) + heat_phase[2] * 24 * 3600 temp_plot &lt;- ggplot(PLS_gg) + annotate(&quot;rect&quot;, xmin = chill_start_date, xmax = chill_end_date, ymin = -Inf, ymax = Inf, alpha = .1, fill = &quot;blue&quot;) + annotate(&quot;rect&quot;, xmin = heat_start_date, xmax = heat_end_date, ymin = -Inf, ymax = Inf, alpha = .1, fill = &quot;red&quot;) + annotate(&quot;rect&quot;, xmin = ISOdate(2001, 12, 31) + min(plscf$pheno$pheno, na.rm = TRUE) * 24 * 3600, xmax = ISOdate(2001, 12, 31) + max(plscf$pheno$pheno, na.rm = TRUE) * 24 * 3600, ymin = -Inf, ymax = Inf, alpha = .1, fill = &quot;black&quot;) + geom_vline(xintercept = ISOdate(2001, 12, 31) + median(plscf$pheno$pheno, na.rm=TRUE) * 24 * 3600, linetype = &quot;dashed&quot;) + geom_ribbon(aes(x = Date, ymin = MetricMean - MetricStdev , ymax = MetricMean + MetricStdev ), fill = &quot;grey&quot;) + geom_ribbon(aes(x = Date, ymin = MetricMean - MetricStdev * (VIP_Coeff == -1), ymax = MetricMean + MetricStdev * (VIP_Coeff == -1)), fill = &quot;red&quot;) + geom_ribbon(aes(x = Date, ymin = MetricMean - MetricStdev * (VIP_Coeff == 1), ymax = MetricMean + MetricStdev * (VIP_Coeff == 1)), fill = &quot;dark green&quot;) + geom_line(aes(x = Date, y = MetricMean)) + facet_wrap(vars(Type), scales = &quot;free_y&quot;, strip.position = &quot;left&quot;, labeller = labeller( Type = as_labeller(c(Chill = paste0(&quot;Chill (&quot;, chill_label, &quot;)&quot;), Heat = paste0(&quot;Heat (&quot;, heat_label, &quot;)&quot;))))) + ggtitle(&quot;Daily chill and heat accumulation rates&quot;) + theme_bw(base_size = 15) + theme(strip.background = element_blank(), strip.placement = &quot;outside&quot;, strip.text.y = element_text(size = 12), plot.title = element_text(hjust = 0.5), axis.title.y = element_blank() ) VIP_plot &lt;- ggplot(PLS_gg, aes(x = Date, y = VIP)) + annotate(&quot;rect&quot;, xmin = chill_start_date, xmax = chill_end_date, ymin = -Inf, ymax = Inf, alpha = .1, fill = &quot;blue&quot;) + annotate(&quot;rect&quot;, xmin = heat_start_date, xmax = heat_end_date, ymin = -Inf, ymax = Inf, alpha = .1, fill = &quot;red&quot;) + annotate(&quot;rect&quot;, xmin = ISOdate(2001, 12, 31) + min(plscf$pheno$pheno, na.rm = TRUE) * 24 * 3600, xmax = ISOdate(2001, 12, 31) + max(plscf$pheno$pheno, na.rm = TRUE) * 24 * 3600, ymin = -Inf, ymax = Inf, alpha = .1, fill = &quot;black&quot;) + geom_vline(xintercept = ISOdate(2001, 12, 31) + median(plscf$pheno$pheno, na.rm = TRUE) * 24 * 3600, linetype = &quot;dashed&quot;) + geom_bar(stat = &#39;identity&#39;, aes(fill = VIP&gt;0.8)) + facet_wrap(vars(Type), scales = &quot;free&quot;, strip.position = &quot;left&quot;, labeller = labeller( Type = as_labeller(c(Chill=&quot;VIP for chill&quot;, Heat=&quot;VIP for heat&quot;)))) + scale_y_continuous( limits = c(0, max(plscf[[chill_metric]][[heat_metric]]$PLS_summary$VIP))) + ggtitle(&quot;Variable Importance in the Projection (VIP) scores&quot;) + theme_bw(base_size = 15) + theme(strip.background = element_blank(), strip.placement = &quot;outside&quot;, strip.text.y = element_text(size = 12), plot.title = element_text(hjust = 0.5), axis.title.y = element_blank() ) + scale_fill_manual(name = &quot;VIP&quot;, labels = c(&quot;&lt;0.8&quot;, &quot;&gt;0.8&quot;), values = c(&quot;FALSE&quot; = &quot;grey&quot;, &quot;TRUE&quot; = &quot;blue&quot;)) + theme(axis.text.x = element_blank(), axis.ticks.x = element_blank(), axis.title.x = element_blank(), axis.title.y = element_blank()) coeff_plot &lt;- ggplot(PLS_gg, aes(x = Date, y = Coef)) + annotate(&quot;rect&quot;, xmin = chill_start_date, xmax = chill_end_date, ymin = -Inf, ymax = Inf, alpha = .1, fill = &quot;blue&quot;) + annotate(&quot;rect&quot;, xmin = heat_start_date, xmax = heat_end_date, ymin = -Inf, ymax = Inf, alpha = .1, fill = &quot;red&quot;) + annotate(&quot;rect&quot;, xmin = ISOdate(2001, 12, 31) + min(plscf$pheno$pheno, na.rm = TRUE) * 24 * 3600, xmax = ISOdate(2001, 12, 31) + max(plscf$pheno$pheno, na.rm = TRUE) * 24 * 3600, ymin = -Inf, ymax = Inf, alpha = .1, fill = &quot;black&quot;) + geom_vline(xintercept = ISOdate(2001, 12, 31) + median(plscf$pheno$pheno, na.rm = TRUE) * 24 * 3600, linetype = &quot;dashed&quot;) + geom_bar(stat = &#39;identity&#39;, aes(fill = VIP_Coeff)) + facet_wrap(vars(Type), scales = &quot;free&quot;, strip.position = &quot;left&quot;, labeller = labeller( Type = as_labeller(c(Chill = &quot;MC for chill&quot;, Heat = &quot;MC for heat&quot;)))) + scale_y_continuous( limits = c(min(plscf[[chill_metric]][[heat_metric]]$PLS_summary$Coef), max(plscf[[chill_metric]][[heat_metric]]$PLS_summary$Coef))) + ggtitle(&quot;Model coefficients (MC)&quot;) + theme_bw(base_size = 15) + theme(strip.background = element_blank(), strip.placement = &quot;outside&quot;, strip.text.y = element_text(size = 12), plot.title = element_text(hjust = 0.5), axis.title.y = element_blank() ) + scale_fill_manual(name = &quot;Effect direction&quot;, labels = c(&quot;Advancing&quot;, &quot;Unimportant&quot;, &quot;Delaying&quot;), values = c(&quot;-1&quot; = &quot;red&quot;, &quot;0&quot; = &quot;grey&quot;, &quot;1&quot; = &quot;dark green&quot;)) + ylab(&quot;PLS coefficient&quot;) + theme(axis.text.x = element_blank(), axis.ticks.x = element_blank(), axis.title.x = element_blank(), axis.title.y = element_blank()) library(patchwork) plot &lt;- (VIP_plot + coeff_plot + temp_plot + plot_layout(ncol = 1, guides = &quot;collect&quot;) ) &amp; theme(legend.position = &quot;right&quot;, legend.text = element_text(size = 8), legend.title = element_text(size = 10), axis.title.x = element_blank()) plot } plot_PLS_chill_force(plscf) Now that we’ve automated the plot production, we can easily look at how useful other chill models would be in delineating chilling and forcing periods. daychill &lt;- daily_chill(hourtemps = temps_hourly, running_mean = 11, models = list(Chilling_Hours = Chilling_Hours, Utah_Chill_Units = Utah_Model, Chill_Portions = Dynamic_Model, GDH = GDH) ) plscf &lt;- PLS_chill_force(daily_chill_obj = daychill, bio_data_frame = Alex_first, split_month = 6, chill_models = c(&quot;Chilling_Hours&quot;, &quot;Utah_Chill_Units&quot;, &quot;Chill_Portions&quot;), heat_models = c(&quot;GDH&quot;)) plot_PLS_chill_force(plscf, chill_metric = &quot;Chilling_Hours&quot;, heat_metric = &quot;GDH&quot;, chill_label = &quot;CH&quot;, heat_label = &quot;GDH&quot;, chill_phase = c(0,0), heat_phase = c(0,0)) plot_PLS_chill_force(plscf, chill_metric = &quot;Utah_Chill_Units&quot;, heat_metric = &quot;GDH&quot;, chill_label = &quot;CU&quot;, heat_label = &quot;GDH&quot;, chill_phase = c(0,0), heat_phase = c(0,0)) So the other two common models aren’t so great at picking up the chilling period either. We’ll reflect on why this is happening later. Exercises on chill model comparison Please document all results of the following assignments in your learning logbook. Repeat the PLS_chill_force procedure for the ‘Roter Boskoop’ dataset. Include plots of daily chill and heat accumulation. Run PLS_chill_force analyses for all three major chill models. Delineate your best estimates of chilling and forcing phases for all of them. Plot results for all three analyses, including shaded plot areas for the chilling and forcing periods you estimated. "],["pls_chillforce_ex.html", "Chapter 24 Examples of PLS regression with agroclimatic metrics Learning goals for this lesson 24.1 PLS regression across species and agroclimatic contexts Exercises on examples of PLS regression with agroclimatic metrics", " Chapter 24 Examples of PLS regression with agroclimatic metrics Learning goals for this lesson Get an overview of studies where the PLS approach has been used with agroclimatic metrics Get a feeling for the effectiveness of the approach across locations and species Start thinking about possible limitations of this approach in delineating temperature response phases 24.1 PLS regression across species and agroclimatic contexts Since 2012, PLS regression using agroclimatic metrics (chill and heat) as inputs has been applied in a bunch of different contexts. The method has been adopted by a few other researchers as well, but I’ll restrict the examples for this chapter to the studies that I was involved in. 24.1.1 Chestnut, jujube and apricot in Beijing One of the coldest locations we’ve used this approach in is Beijing, where, led by Guo Liang we worked with bloom data for Chinese chestnut (Castanea mollissima) and jujube (Ziziphus jujuba) to delineate chilling and forcing periods (Guo et al., 2014a). In another study, we also examined datasets for apricot (Prunus armeniaca) and mountain peach (Prunus davidiana). Here are the results: Results of a PLS analysis based on the relationship between daily chill (quantified with the Dynamic Model) and heat (quantified with the GDH model) accumulation and bloom of Chinese chestnut (Castanea mollissima) in Beijing, China (Guo et al., 2014a) Results of a PLS analysis based on the relationship between daily chill (quantified with the Dynamic Model) and heat (quantified with the GDH model) accumulation and bloom of jujube (Ziziphus jujuba) in Beijing, China (Guo et al., 2014a) Results of a PLS analysis based on the relationship between daily chill (quantified with the Dynamic Model) and heat (quantified with the GDH model) accumulation and bloom of mountain peach (Prunus davidiana) in Beijing, China (Guo et al., 2014b) Results of a PLS analysis based on the relationship between daily chill (quantified with the Dynamic Model) and heat (quantified with the GDH model) accumulation and bloom of apricot (Prunus armeniaca) in Beijing, China (Guo et al., 2014b) For apricots, we also ran PLS regressions with multiple chill metrics, i.e. Chilling Hours, the Utah Model (Chill Units) and the Dynamic Model (Chill Portions): Results of a PLS analysis based on the relationship between daily chill and heat accumulation and bloom of apricot (Prunus armeniaca) in Beijing, China. Coefficients for heat are not shown here (they are similar to what’s shown in the previous figure). Chill accumulation was quantified with the Chilling Hours Model (left), the Utah Model (middle) and the Dynamic Model (right) (Guo et al., 2015b) In all analyses of phenology records from Beijing, the forcing period was easy to delineate, but the chilling period was difficult to see. 24.1.2 Apples in Shaanxi Province, China Guo Liang also led a study on apple phenology in Shaanxi, one of China’s main apple growing provinces: Results of a PLS analysis of the relationship between chill (in Chill Portions) and heat (in GDH) and bloom dates of apple in Shaanxi, China (Guo et al., 2019) Also here the chilling phase was visible but difficult to delineate. 24.1.3 Cherries in Klein-Altendorf Winters in Beijing and Shaanxi are rather cold. Let’s look at a slightly warmer location - cherries in Klein-Altendorf. Results of a PLS analysis of bloom dates of cherries ‘Schneiders späte Knorpelkirsche’ in Klein-Altendorf, Germany, based on chill (in Chill Portions) and heat (in GDH) accumulation (Luedeling et al., 2013a) Again, it’s pretty difficult to see the chilling period. 24.1.4 Apricots in the UK For apricots in the UK National Fruit Collection at Brogdale Farm in Faversham, southern England, we can see a clear chill response phase in January and February, but this period is quite a bit later than we would normally expect chill accumulation to start: Results of a PLS analysis of apricot bloom in the southern UK, based on chill accumulation (in Chill Portions) and heat accumulation (in GDH) (Martı́nez-Lüscher et al., 2017) 24.1.5 Grapevine in Croatia Grapes also have chilling requirements, so Johann Martínez-Lüscher, who also led the UK apricot study, looked into the temperature response of grapes grown in Croatia: Results of a PLS analysis of flowering dates of grapevine (cv. ‘Riesling Italico’) in Mandicevac, Croatia. Chill was quantified with the Dynamic Model, heat with the Growing Degree Hours Model (Martı́nez-Lüscher et al., 2016) Here in Croatia, where winters are warmer than in the earlier locations and chill accumulation rates are more variable, we see the chilling period emerge more clearly, with a particularly pronounced bloom response to chill accumulation in December and January. If we choose to be a bit more generous in our interpretation, we can see a chilling period extending from late September to February. 24.1.6 Walnuts in California Let’s look at a location with an even warmer winter. For walnuts in California, we could already see the chilling period when working with raw temperatures, and we can also see it clearly when we use agroclimatic metrics: Results of a PLS analysis of leaf emergence dates of walnuts (cv. ‘Payne’) in Davis, California. Chill was quantified with the Dynamic Model, heat with the Growing Degree Hours Model (Luedeling et al., 2013a) Once again, we can see the chilling period pretty clearly in this analysis. As we’ve seen before, it appears to consist of two parts (what could be the reason for this? May be worth looking into at some point), but we can easily spot a period between mid-October and the end of December, during which bloom dates respond to high chill accumulation rates. 24.1.7 Almonds in Tunisia Sfax in Central Tunisia is an even warmer location - close to the cultivation margin of temperate nut trees. In a study led by Haïfa Benmoussa, we evaluated bloom data of a total of 37 almond cultivars. In virtually all cases, we could clearly delineate both the chilling phase and the forcing period. The following three figures show the results. PLS results for almond cultivars near Sfax, Tunisia - part 1 (Benmoussa et al., 2017a) PLS results for almond cultivars near Sfax, Tunisia - part 2 (Benmoussa et al., 2017a) PLS results for almond cultivars near Sfax, Tunisia - part 3 (Benmoussa et al., 2017a) 24.1.8 Pistachios in Tunisia We also evaluated data for pistachios from the same experimental station in the Sfax region of Tunisia. For this crop, we found a long chilling period, with very clear responses to chill accumulation rates. Interestingly, the forcing period was now hard to see: PLS results for pistachios near Sfax, Tunisia (Benmoussa et al., 2017b) Exercises on examples of PLS regression with agroclimatic metrics Please document all results of the following assignments in your learning logbook. Look across all the PLS results presented above. Can you detect a pattern in where chilling and forcing periods could be delineated clearly, and where this attempt failed? Think about possible reasons for the success or failure of PLS analysis based on agroclimatic metrics. Write down your thoughts. References Guo L, Dai J, Ranjitkar S, Yu H, Xu J &amp; Luedeling E. (2014a). Chilling and heat requirements for flowering in temperate fruit trees. International Journal of Biometeorology, 58(6), 1195–1206. doi: 10.1007/s00484-013-0714-3 "],["pls_chillforce_reflection.html", "Chapter 25 Why PLS doesn’t always work Learning goals for this lesson 25.1 Disappointing PLS performance 25.2 What PLS regression can find 25.3 Chill model sensitivity vs. observed temperature 25.4 Heat model sensitivity vs. observed temperature Exercises on expected PLS responsiveness", " Chapter 25 Why PLS doesn’t always work Learning goals for this lesson Understand why PLS regression sometimes doesn’t perform as expected Be able to make temperature response plots for agroclimatic metrics Be able to relate temperatures at a study site to temperature responses of models to anticipate whether PLS analysis will be effective 25.1 Disappointing PLS performance As we’ve seen in the previous chapter, results from PLS regression often don’t allow easy delineation of temperature response phases, especially when it comes to the chilling period. This problem didn’t really go away after replacing temperatures with agroclimatic metrics in the analysis. In many cases, we saw some short periods that matched the expected pattern, but these often only occurred at the beginning and end of the likely endodormancy phase, with a large gap between them. To understand what’s going on here, we have to remind ourselves of what the analysis procedure we’re using can accomplish - and what it can’t. 25.2 What PLS regression can find What PLS looks for is responses of a response variable to variation in the input variable. We’ve already learned earlier that this response should be monotonic, i.e. the response (bloom date) should be either positively or negatively correlated with the input variables. The sign of this relationship should not change halfway through the range of the input variables. Another prerequisite for a successful PLS regression, which may seem so obvious that we usually don’t pay much attention to it, is that there needs to be meaningful variation in the signal variables in the first place. If the independent variables don’t vary, we obviously can’t detect a response to variation. In the specific example we’re looking at, if chill effectiveness is always more or less the same during a certain period, we can’t expect PLS regression to derive much useful information on the temperature response during this phase. Let’s explore whether the reason for poor PLS performance might be low variation in chill accumulation during particular periods, in particular during the winter in cold study locations such as Klein-Altendorf or Beijing. We’ll start by making a plot of the model response to temperature. I’m only going to work with the Dynamic Model now, but we could of course do similar analyses with other chill models (in case we’re still not convinced that the Dynamic Model is superior). What we’ll do now is produce a figure that shows how the Dynamic Model responds to particular daily temperature curves. For simplicity, I’ll assume that we have the same minimum and maximum temperature over a longer period and then compute the mean daily chill accumulation rate. This is preferable to a single-day calculation, because the Dynamic Model sometimes takes multiple days to accumulate a Chill Portion. library(chillR) mon &lt;- 1 # Month ndays &lt;- 31 # Number of days per month tmin &lt;- 1 tmax &lt;- 8 latitude &lt;- 50 weather &lt;- make_all_day_table( data.frame(Year = c(2001, 2001), Month = c(mon, mon), Day = c(1, ndays), Tmin = c(0, 0), Tmax = c(0, 0))) %&gt;% mutate(Tmin = tmin, Tmax = tmax) hourly_temps &lt;- stack_hourly_temps(weather, latitude = latitude) CPs &lt;- Dynamic_Model( hourly_temps$hourtemps$Temp) daily_CPs &lt;- CPs[length(CPs)] / nrow(weather) daily_CPs ## [1] 0.712235 To be able to add flexibility to the code later, let me introduce an alternative way to run a function. So far, we’ve been running the Dynamic_Model function by typing Dynamic_Model(...). This is easy and straightforward, but assume now that we’d like our function to be able to run different models, and we want to pass the model into our function as a parameter. In such cases, we can use the do.call function: do.call(temp_model, list(...)). The list here contains all the arguments to the temperature model function. In our original case, temp_model would be equal to Dynamic_Model (and the list would contain the arguments of the Dynamic_Model function), but we could now replace it by temp_model = GDH or a similar expression. So far we’ve just been working on one particular Tmin/Tmax combination, and we only generated results for one month. Let’s produce such data for each month, and for a wide range of Tmin/Tmax combinations. We’ll need a bit of slightly more complicated code here to solve some problems that come up when we try to generalize, such as the need to figure out how many days each month has. library(chillR) latitude &lt;- 50.6 month_range &lt;- c(10, 11, 12, 1, 2, 3) Tmins &lt;- c(-20:20) Tmaxs &lt;- c(-15:30) mins &lt;- NA maxs &lt;- NA CP &lt;- NA month &lt;- NA temp_model &lt;- Dynamic_Model for(mon in month_range) {days_month &lt;- as.numeric( difftime( ISOdate(2002, mon + 1, 1), ISOdate(2002, mon, 1))) if(mon == 12) days_month &lt;- 31 weather &lt;- make_all_day_table( data.frame(Year = c(2001, 2001), Month = c(mon, mon), Day = c(1, days_month), Tmin = c(0, 0), Tmax = c(0, 0))) for(tmin in Tmins) for(tmax in Tmaxs) if(tmax &gt;= tmin) { hourtemps &lt;- weather %&gt;% mutate(Tmin = tmin, Tmax = tmax) %&gt;% stack_hourly_temps(latitude = latitude) %&gt;% pluck(&quot;hourtemps&quot;, &quot;Temp&quot;) CP &lt;- c(CP, tail(do.call(temp_model, list(hourtemps)), 1) / days_month) mins &lt;- c(mins, tmin) maxs &lt;- c(maxs, tmax) month &lt;- c(month, mon) } } results &lt;- data.frame(Month = month, Tmin = mins, Tmax = maxs, CP) results &lt;- results[!is.na(results$Month), ] write.csv(results, &quot;data/model_sensitivity_development.csv&quot;, row.names = FALSE) head(results) Month Tmin Tmax CP 10 -20 -15 0 10 -20 -14 0 10 -20 -13 0 10 -20 -12 0 10 -20 -11 0 10 -20 -10 0 latitude &lt;- 50.6 month_range &lt;- c(10, 11, 12, 1, 2, 3) Tmins &lt;- c(-20:20) Tmaxs &lt;- c(-15:30) Now we can make a plot of this temperature response curve. library(ggplot2) library(colorRamps) results$Month_names &lt;- factor(results$Month, levels = month_range, labels = month.name[month_range]) DM_sensitivity &lt;- ggplot(results, aes(x = Tmin, y = Tmax, fill = CP)) + geom_tile() + scale_fill_gradientn(colours = alpha(matlab.like(15), alpha = .5), name = &quot;Chill/day (CP)&quot;) + ylim(min(results$Tmax), max(results$Tmax)) + ylim(min(results$Tmin), max(results$Tmin)) DM_sensitivity DM_sensitivity &lt;- DM_sensitivity + facet_wrap(vars(Month_names)) + ylim(min(results$Tmax), max(results$Tmax)) + ylim(min(results$Tmin), max(results$Tmin)) DM_sensitivity (the reason why the colors in the upper plot seem more vibrant than the colors in the legend is that the alpha function in the ggplot call makes the colors transparent - but we’re plotting data points for 6 months on top of each other. Six layers of transparent tiles make for pretty vibrant colors.) Note that this plot is specific to the latitude we entered above, because daily temperature curves are influenced by sunrise and sunset times. We can see clear variation in chill effectiveness across the temperature spectrum, with no chill accumulation at high and low temperatures and a sweet spot in the middle. We also see that there is a fairly steep gradient in chill accumulation rates around the edge of the effective range. We can get an important indication of the likelihood of PLS regression to work in this climatic situation by plotting temperatures on top of this diagram. This plot is specific to latitude 50.6°N, so we can overlay temperatures for Klein-Altendorf. temperatures &lt;- read_tab(&quot;data/TMaxTMin1958-2019_patched.csv&quot;) %&gt;% filter(Month %in% month_range) %&gt;% mutate(Month_names = factor(Month, levels = c(10, 11, 12, 1, 2, 3), labels = c(&quot;October&quot;, &quot;November&quot;, &quot;December&quot;, &quot;January&quot;, &quot;February&quot;, &quot;March&quot;))) temperatures[which(temperatures$Tmax &lt; temperatures$Tmin), c(&quot;Tmax&quot;, &quot;Tmin&quot;)] &lt;- NA DM_sensitivity + geom_point(data = temperatures, aes(x = Tmin, y = Tmax, fill = NULL, color = &quot;Temperature&quot;), size = 0.2) + facet_wrap(vars(Month_names)) + scale_color_manual(values = &quot;black&quot;, labels = &quot;Daily temperature \\nextremes (°C)&quot;, name = &quot;Observed at site&quot; ) + guides(fill = guide_colorbar(order = 1), color = guide_legend(order = 2)) + ylab(&quot;Tmax (°C)&quot;) + xlab(&quot;Tmin (°C)&quot;) + theme_bw(base_size = 15) Before we start looking at the results in detail, let’s automate this procedure and also generate data for some of the other locations we’ve seen PLS results for. I’ll make two functions: one for producing the model sensitivity data (because that takes a while) and another one for plotting. Chill_model_sensitivity&lt;- function(latitude, temp_models = list(Dynamic_Model = Dynamic_Model, GDH = GDH), month_range = c(10, 11, 12, 1, 2, 3), Tmins = c(-10:20), Tmaxs = c(-5:30)) { mins &lt;- NA maxs &lt;- NA metrics &lt;- as.list(rep(NA, length(temp_models))) names(metrics) &lt;- names(temp_models) month &lt;- NA for(mon in month_range) { days_month &lt;- as.numeric(difftime(ISOdate(2002, mon + 1, 1), ISOdate(2002, mon, 1) )) if(mon == 12) days_month &lt;- 31 weather &lt;- make_all_day_table(data.frame(Year = c(2001, 2001), Month = c(mon, mon), Day = c(1, days_month), Tmin = c(0, 0), Tmax = c(0, 0))) for(tmin in Tmins) for(tmax in Tmaxs) if(tmax &gt;= tmin) { hourtemps &lt;- weather %&gt;% mutate(Tmin = tmin, Tmax = tmax) %&gt;% stack_hourly_temps( latitude = latitude) %&gt;% pluck(&quot;hourtemps&quot;, &quot;Temp&quot;) for(tm in 1:length(temp_models)) metrics[[tm]] &lt;- c(metrics[[tm]], tail(do.call(temp_models[[tm]], list(hourtemps)),1)/ days_month) mins &lt;- c(mins, tmin) maxs &lt;- c(maxs, tmax) month &lt;- c(month, mon) } } results &lt;- cbind(data.frame(Month = month, Tmin = mins, Tmax = maxs), as.data.frame(metrics)) results &lt;- results[!is.na(results$Month),] } Chill_sensitivity_temps &lt;- function(chill_model_sensitivity_table, temperatures, temp_model, month_range = c(10, 11, 12, 1, 2, 3), Tmins = c(-10:20), Tmaxs = c(-5:30), legend_label = &quot;Chill/day (CP)&quot;) { library(ggplot2) library(colorRamps) cmst &lt;- chill_model_sensitivity_table cmst &lt;- cmst[which(cmst$Month %in% month_range),] cmst$Month_names &lt;- factor(cmst$Month, levels = month_range, labels = month.name[month_range]) DM_sensitivity&lt;- ggplot(cmst, aes_string(x = &quot;Tmin&quot;, y = &quot;Tmax&quot;, fill = temp_model)) + geom_tile() + scale_fill_gradientn(colours = alpha(matlab.like(15), alpha = .5), name = legend_label) + xlim(Tmins[1], Tmins[length(Tmins)]) + ylim(Tmaxs[1], Tmaxs[length(Tmaxs)]) temperatures&lt;- temperatures[which(temperatures$Month %in% month_range),] temperatures[which(temperatures$Tmax &lt; temperatures$Tmin), c(&quot;Tmax&quot;, &quot;Tmin&quot;)] &lt;- NA temperatures$Month_names &lt;- factor(temperatures$Month, levels = month_range, labels = month.name[month_range]) DM_sensitivity + geom_point(data = temperatures, aes(x = Tmin, y = Tmax, fill = NULL, color = &quot;Temperature&quot;), size = 0.2) + facet_wrap(vars(Month_names)) + scale_color_manual(values = &quot;black&quot;, labels = &quot;Daily temperature \\nextremes (°C)&quot;, name = &quot;Observed at site&quot; ) + guides(fill = guide_colorbar(order = 1), color = guide_legend(order = 2)) + ylab(&quot;Tmax (°C)&quot;) + xlab(&quot;Tmin (°C)&quot;) + theme_bw(base_size = 15) } To compare the locations, I’ll first generate all the model sensitivity data (and save them to file, so I only have to do this once). Model_sensitivities_CKA &lt;- Chill_model_sensitivity(latitude = 50, temp_models = list(Dynamic_Model = Dynamic_Model, GDH = GDH), month_range = c(10:12, 1:5)) write.csv(Model_sensitivities_CKA, &quot;data/Model_sensitivities_CKA.csv&quot;, row.names = FALSE) Model_sensitivities_Davis &lt;- Chill_model_sensitivity(latitude = 38.5, temp_models = list(Dynamic_Model = Dynamic_Model, GDH = GDH), month_range=c(10:12, 1:5)) write.csv(Model_sensitivities_Davis, &quot;data/Model_sensitivities_Davis.csv&quot;, row.names = FALSE) Model_sensitivities_Beijing &lt;- Chill_model_sensitivity(latitude = 39.9, temp_models = list(Dynamic_Model = Dynamic_Model, GDH = GDH), month_range = c(10:12, 1:5)) write.csv(Model_sensitivities_Beijing, &quot;data/Model_sensitivities_Beijing.csv&quot;, row.names = FALSE) Model_sensitivities_Sfax &lt;- Chill_model_sensitivity(latitude = 35, temp_models = list(Dynamic_Model = Dynamic_Model, GDH = GDH), month_range = c(10:12, 1:5)) write.csv(Model_sensitivities_Sfax, &quot;data/Model_sensitivities_Sfax.csv&quot;, row.names = FALSE) Now we can look at how temperatures during particular months compare to what is effective for chill and heat accumulation at the four locations. Use the following buttons to download long-term weather data for the four locations. I recommend that you save this in a subfolder of your working directory that is called data. Download weather data for Beijing Download weather data for Klein-Altendorf Download weather data for Davis Download weather data for Sfax Beijing_weather &lt;- read_tab(&quot;data/Beijing_weather.csv&quot;) CKA_temperatures &lt;- read_tab(&quot;data/TMaxTMin1958-2019_patched.csv&quot;) Davis_weather &lt;- read_tab(&quot;data/Davis_weather.csv&quot;) Sfax_weather &lt;- read_tab(&quot;data/Sfax_weather.csv&quot;) We’ll start with the coldest location, Beijing, then move to Klein-Altendorf, Davis and Sfax, as progressively warmer growing regions. Note that the output of the Chill_sensitivity_temps is a ggplot plot, so we can manipulate it using the + notation. I’ll add titles to all plots using the ggtitle function. Here are the plots for chill accumulation (quantified with the Dynamic Model): Chill_sensitivity_temps(Model_sensitivities_Beijing, Beijing_weather, temp_model = &quot;Dynamic_Model&quot;, month_range = c(10, 11, 12, 1, 2, 3), legend_label = &quot;Chill per day \\n(Chill Portions)&quot;) + ggtitle(&quot;Chill model sensitivity at Beijing, China&quot;) Chill_sensitivity_temps(Model_sensitivities_CKA, CKA_temperatures, temp_model = &quot;Dynamic_Model&quot;, month_range = c(10, 11, 12, 1, 2, 3), legend_label = &quot;Chill per day \\n(Chill Portions)&quot;) + ggtitle(&quot;Chill model sensitivity at Klein-Altendorf, Germany&quot;) Chill_sensitivity_temps(Model_sensitivities_Davis, Davis_weather, temp_model = &quot;Dynamic_Model&quot;, month_range = c(10, 11, 12, 1, 2, 3), legend_label = &quot;Chill per day \\n(Chill Portions)&quot;) + ggtitle(&quot;Chill model sensitivity at Davis, California&quot;) Chill_sensitivity_temps(Model_sensitivities_Sfax, Sfax_weather, temp_model = &quot;Dynamic_Model&quot;, month_range = c(10, 11, 12, 1, 2, 3), legend_label = &quot;Chill per day \\n(Chill Portions)&quot;) + ggtitle(&quot;Chill model sensitivity near Sfax, Tunisia&quot;) And here are the plots for heat accumulation: Chill_sensitivity_temps(Model_sensitivities_Beijing, Beijing_weather, temp_model = &quot;GDH&quot;, month_range = c(12, 1:5), legend_label = &quot;Heat per day \\n(GDH)&quot;) + ggtitle(&quot;Heat model sensitivity at Beijing, China&quot;) Chill_sensitivity_temps(Model_sensitivities_CKA, CKA_temperatures, temp_model = &quot;GDH&quot;, month_range = c(12, 1:5), legend_label = &quot;Heat per day \\n(GDH)&quot;) + ggtitle(&quot;Heat model sensitivity at Klein-Altendorf, Germany&quot;) Chill_sensitivity_temps(Model_sensitivities_Davis, Davis_weather, temp_model = &quot;GDH&quot;, month_range = c(12, 1:5), legend_label = &quot;Heat per day \\n(GDH)&quot;) + ggtitle(&quot;Heat model sensitivity at Davis, California&quot;) Chill_sensitivity_temps(Model_sensitivities_Sfax, Sfax_weather, temp_model = &quot;GDH&quot;, month_range = c(12, 1:5), legend_label = &quot;Heat per day \\n(GDH)&quot;) + ggtitle(&quot;Heat model sensitivity near Sfax, Tunisia&quot;) Now we can look at the response patterns in relation to the sensitivity of chill and heat models. Let’s start with the chill model. 25.3 Chill model sensitivity vs. observed temperature Even though we know that chill model sensitivity depends on hourly temperatures, which in turn are influenced by sunset and sunrise times, the sensitivity patterns appear almost identical across all the locations. There are in fact minor differences, but these are not particularly meaningful. What does differ between the sites is the ‘location’ of observed hourly temperatures in relation to the sensitive periods. This also varied between months of the year. 25.3.1 Beijing, China For Beijing, we can see that observed temperatures in October are quite equally distributed between temperature situations we expect to be effective for chill accumulation and situations that are too warm. Such a setting may generate chill-related signals that may cause a meaningful response in bloom dates. For the next month, November, the situation looks entirely different. Almost all temperature values are within a temperature range that is highly effective for chill accumulation. Even though temperatures vary considerably, chill accumulation rates are very similar for most days in November. Assuming that our chill model is accurate, all these days would thus create similar chill signals. Without meaningful variation, we should not expect PLS to produce useful results. In December, January and February, temperatures are even lower, so that now we have many hours that are colder than the effective chill accumulation rate. Assuming that the Dynamic Model accurately captures the chill accumulation behavior at the low-temperature end (which I’m not convinced about), we may see a response here. March is similar to November, in that temperatures are almost always nearly optimal for chill accumulation. In summary, conditions in Beijing should allow fairly good identification of chill effects in most months, but probably not in November. 25.3.2 Klein-Altendorf, Germany Temperatures at Klein-Altendorf are possibly less ideal than those in Beijing for PLS-based delineation of the chilling period. Like in Beijing, we also have both optimal and suboptimal temperatures in many months, but the share of days with suboptimal chill conditions is considerably lower than in Beijing. In October, December, January and February, the majority of all days had almost optimal chill conditions, with relatively few days being either too warm (mainly in October) or too cold for chilling. In November and March, almost all days are near the optimal chill accumulation range. Klein-Altendorf may thus be a fairly unpromising location for delineating temperature response phases with PLS regression analysis. 25.3.3 Davis, California Davis offers more favorable conditions in terms of the distribution of daily temperatures across chill model sensitivity levels, at least for some winter months. In November and March, days are about equally distributed among effective and ineffective chill accumulation settings. In February, most days are optimal, with relatively few low-chill (or zero-chill) days. January and December largely feature optimal conditions for chill accumulation. This may compromise the ability of PLS regression to detect signals. In summary, Davis offers better conditions than the colder locations, but may still face some limitations to the application of PLS regression to delineate response phases. 25.3.4 Sfax, Tunisia In Sfax, finally, we see temperature settings that favor PLS regression for all months between December and February. Also in November and March, temperature conditions may evoke a chill signal, though the proportion of days during which chill is effectively accumulated is much smaller than in the other months. We should not expect much of a signal in October, when temperatures are consistently too high for chill accumulation. 25.4 Heat model sensitivity vs. observed temperature In comparison to the Dynamic Model, the temperature response of the Growing Degree Hours model is pretty unspectacular. Any day with a minimum temperature above 4°C contributes to heat accumulation, and the warmer it gets, the stronger the response. Between December and May, such days are rare in December, January and February in Beijing, but quite abundant in all other months at this location, and in all months at the other sites. In summary, across our four study sites, we can rarely observe months that would limit the ability of PLS regression to identify heat accumulation phases. This may in part explain why it has generally been easier to delineate the ecodormancy phase (when heat accumulates) than the endodormancy periods (when chill accumulates). Exercises on expected PLS responsiveness Please document all results of the following assignments in your learning logbook. Produce chill and heat model sensitivity plots for the location you focused on in previous exercises. "],["pls_eval_PLS.html", "Chapter 26 Evaluating PLS outputs Learning goals for this lesson 26.1 Chilling and forcing requirements 26.2 Response to seasonal temperature 26.3 Applying our functions to California walnuts Exercises on evaluating PLS regression results", " Chapter 26 Evaluating PLS outputs Learning goals for this lesson Understand what we can do with the temperature response phase delineations Be able to compute estimates of chill and heat requirements based on the outputs of a PLS analysis Be able to make temperature response plots for phenology data 26.1 Chilling and forcing requirements Despite some trouble in delineating chill and heat response periods, we’ve often been able to identify both dormancy phases. Let’s see how we can make use of this information. We’ll use the example of our ‘Alexander Lucas’ pears again, for which we’ll first draw the PLS response curve. library(chillR) Alex_first &lt;- read_tab(&quot;data/Alexander_Lucas_bloom_1958_2019.csv&quot;) %&gt;% select(Pheno_year, First_bloom) %&gt;% mutate(Year = as.numeric(substr(First_bloom, 1, 4)), Month = as.numeric(substr(First_bloom, 5, 6)), Day = as.numeric(substr(First_bloom, 7, 8))) %&gt;% make_JDay() %&gt;% select(Pheno_year, JDay) %&gt;% rename(Year = Pheno_year, pheno = JDay) temps &lt;- read_tab(&quot;data/TMaxTMin1958-2019_patched.csv&quot;) temps_hourly &lt;- temps %&gt;% stack_hourly_temps(latitude = 50.6) daychill &lt;- daily_chill(hourtemps = temps_hourly, running_mean = 1, models = list(Chilling_Hours = Chilling_Hours, Utah_Chill_Units = Utah_Model, Chill_Portions = Dynamic_Model, GDH = GDH) ) plscf &lt;- PLS_chill_force(daily_chill_obj = daychill, bio_data_frame = Alex_first, split_month = 6, chill_models = &quot;Chill_Portions&quot;, heat_models = &quot;GDH&quot;, runn_means = 11) We’ll plot the results using the plot_PLS_chill_force function we produced in PLS regression with agroclimatic metrics. plot_PLS_chill_force(plscf, chill_metric = &quot;Chill_Portions&quot;, heat_metric = &quot;GDH&quot;, chill_label = &quot;CP&quot;, heat_label = &quot;GDH&quot;, chill_phase = c(-48, 62), heat_phase = c(3, 105.5)) I’ve already indicated here what phases I consider relevant for chilling (light blue) and forcing (light red). If we accept these periods as chilling and forcing phases, the amount of chill or heat accumulated during these phases should be a reasonable approximation of the tree’s agroclimatic needs. We can easily calculate these with the tempResponse function. Of course, chill and heat accumulated during these phases isn’t identical across all years of the dataset. It’s not entirely clear how to arrive at reliable estimates for chill and heat requirements from this set of values, but I’ve found it quite reasonable to use the mean accumulation during the delineated periods as our best estimate and the standard deviation to evaluate the error. chill_phase &lt;- c(317, 62) heat_phase &lt;- c(3, 105.5) chill &lt;- tempResponse(hourtemps = temps_hourly, Start_JDay = chill_phase[1], End_JDay = chill_phase[2], models = list(Chill_Portions = Dynamic_Model), misstolerance = 10) heat &lt;- tempResponse(hourtemps = temps_hourly, Start_JDay = heat_phase[1], End_JDay = heat_phase[2], models = list(GDH = GDH)) Let’s draw quick histograms for good measure and then quantify the chill and heat requirements, plus their errors. ggplot(data = chill, aes(x = Chill_Portions)) + geom_histogram() + ggtitle(&quot;Chill accumulation during endodormancy (Chill Portions)&quot;) + xlab(&quot;Chill accumulation (Chill Portions)&quot;) + ylab(&quot;Frequency between 1958 and 2019&quot;) + theme_bw(base_size = 12) ggplot(data = heat, aes(x = GDH)) + geom_histogram() + ggtitle(&quot;Heat accumulation during ecodormancy (GDH)&quot;) + xlab(&quot;Heat accumulation (Growing Degree Hours)&quot;) + ylab(&quot;Frequency between 1958 and 2019&quot;) + theme_bw(base_size = 12) chill_requirement &lt;- mean(chill$Chill_Portions) chill_req_error &lt;- sd(chill$Chill_Portions) heat_requirement &lt;- mean(heat$GDH) heat_req_error &lt;- sd(heat$GDH) So we find that the chilling requirement (chill_requirement) is about 72.3 Chill Portions, with an estimated error (chill_req_error) of 7.7 CP. The heat requirement (heat_requirement) is about 3415 Growing Degree Hours, with an estimated error (heat_req_error) of 1402 GDH. Compared to other fruit trees, this is a fairly high chilling requirement, while the heat need is quite low. I should add that we have some ambiguity here regarding the duration of the chilling period especially, and a considerable overlap between the two phases. This may lead to these estimates not being totally reliable here. There have been some discussions about how useful these statistical estimates are. In some cases, they have been pretty close to requirements that were estimated experimentally, while in other cases, there were substantial differences. Even though some doubts about the accuracy of this method to determine agroclimatic needs remain, it has enabled quick and easy initial estimates of chill and heat requirements, at least for cultivars for which we have long-term bloom data (coupled with temperature recordings). The first statistical estimates of chill and heat needs with this method were produced for ‘Schneider’s späte Knorpelkirsche’ cherries in Klein-Altendorf (Luedeling et al., 2013b). In that study, we just used a temperature-based PLS analysis, but we later also ran similar analyses with PLS regression using agroclimatic metrics (Luedeling et al., 2013a). 26.2 Response to seasonal temperature In addition to estimating chill and heat requirements, we can also take a more general look at tree responses to temperature during these delineated phases. While (as I hope you remember) our delineations of chilling and forcing phases were based on the assumption that the agroclimatic models were somewhat accurate, we’ll now take a step back and use raw temperatures again. Now that we have a reasonable estimate of the major temperature response phases, let’s see if we can explain (part of) the trees’ bloom dates just by mean temperature during these periods. We know that conditions during both the chilling and the forcing phases affect bloom dates, so let’s try to illustrate both of these effects in one figure. We now have two independent variables (mean temperature during chilling and mean temperature during forcing), and we have one dependent variable (bloom date). This means we need three dimensions in our plot. What chillR provides for us is a bit of a black box, but we’ll reproduce this ourselves later. The function to look at for this is the make_pheno_trend_plot function. The only inputs we need to provide are a data.frame with weather data, a data.frame with phenology data and the start and end days of the temperature response phases we identified. The other inputs are necessary because, like many other functions in the package, chillR is currently set up to produce images rather than just plots in R. chill_phase &lt;- c(317, 62) heat_phase &lt;- c(360, 106) # note that the end date here was rounded # to an integer number, so that a proper # axis label can be generated. mpt &lt;- make_pheno_trend_plot(weather_data_frame = temps, pheno = Alex_first, Start_JDay_chill = chill_phase[1], End_JDay_chill = chill_phase[2], Start_JDay_heat = heat_phase[1], End_JDay_heat = heat_phase[2], outpath = &quot;data/&quot;, file_name = &quot;pheno_trend_plot&quot;, plot_title = &quot;Impacts of chilling and forcing temperatures on pear phenology&quot;, image_type = &quot;png&quot;, colorscheme = &quot;normal&quot;) Standard chillR output of phenology trend plot for pears ‘Alexander Lucas’ in Klein-Altendorf What we see here is a surface that is interpolated from all bloom dates included in the phenology record, which relates bloom date expectations to temperatures during the chilling phase (x-axis) and the forcing phase (y-axis). The shape of the plotted surface is defined by the array of winter conditions that have been observed since 1958. Apparently, for instance, there have been no years with an average temperature during chilling around -2°C and 4°C during forcing. Hence the plot area remains white in this region. The array of historically observed conditions is relatively narrow here, with a fairly strong correlation between temperatures during eco- and endodormancy, as indicated by the narrow diagonal shape of the area. Nevertheless, we can already get an idea about the temperature responses. All the blue colors are near the top of the plot, while the red colors are at the bottom. This means that early bloom dates (blue) were mostly associated with a warm forcing phase, while cool conditions during that period were related to late bloom. Evaluating the effect of temperatures during chilling is more difficult here, because of missing data in climatic spaces that would be relevant. We’ll look at other examples later that show a clearer response. Now let’s see if we can reproduce this figure using ggplot. We’ll first compute the mean temperatures for the chilling and forcing period. We’ve done something like this before, in the Simple phenology analysis chapter. I’ll reuse code from there to make a function to summarize temperatures for a particular JDay interval mean_temp_period &lt;- function( temps, start_JDay, end_JDay, end_season = end_JDay) { temps_JDay &lt;- make_JDay(temps) %&gt;% mutate(Season =Year) if(start_JDay &gt; end_season) temps_JDay$Season[which(temps_JDay$JDay &gt;= start_JDay)]&lt;- temps_JDay$Year[which(temps_JDay$JDay &gt;= start_JDay)]+1 if(start_JDay &gt; end_season) sub_temps &lt;- subset(temps_JDay, JDay &lt;= end_JDay | JDay &gt;= start_JDay) if(start_JDay &lt;= end_JDay) sub_temps &lt;- subset(temps_JDay, JDay &lt;= end_JDay &amp; JDay &gt;= start_JDay) mean_temps &lt;- aggregate(sub_temps[, c(&quot;Tmin&quot;, &quot;Tmax&quot;)], by = list(sub_temps$Season), FUN = function(x) mean(x, na.rm=TRUE)) mean_temps[, &quot;n_days&quot;] &lt;- aggregate(sub_temps[, &quot;Tmin&quot;], by = list(sub_temps$Season), FUN = length)[,2] mean_temps[, &quot;Tmean&quot;] &lt;- (mean_temps$Tmin + mean_temps$Tmax) / 2 mean_temps &lt;- mean_temps[, c(1, 4, 2, 3, 5)] colnames(mean_temps)[1] &lt;- &quot;End_year&quot; return(mean_temps) } mean_temp_chill &lt;- mean_temp_period(temps = temps, start_JDay = chill_phase[1], end_JDay = chill_phase[2], end_season = 60) mean_temp_heat &lt;- mean_temp_period(temps = temps, start_JDay = heat_phase[1], end_JDay = heat_phase[2], end_season = 60) Note that we have to be a bit careful here that we don’t assign heat or chill accumulation to the wrong season. This can easily happen when the chilling phase begins and ends before the beginning of January. To prevent this, I added the parameter end_season to the function. If we set this to a JDay of the year that we expect the phenological stage of interest to occur in, we should have no problem with erroneous assignment to seasons. Now we can combine these two datasets (just the Tmean columns) and merge them with the phenology data. Before that, all incomplete years should be filtered out. mean_temp_chill &lt;- mean_temp_chill[which(mean_temp_chill$n_days &gt;= max(mean_temp_chill$n_days)-1),] mean_temp_heat &lt;- mean_temp_heat[which(mean_temp_heat$n_days &gt;= max(mean_temp_heat$n_days)-1),] mean_chill &lt;- mean_temp_chill[, c(&quot;End_year&quot;, &quot;Tmean&quot;)] colnames(mean_chill)[2] &lt;- &quot;Tmean_chill&quot; mean_heat &lt;- mean_temp_heat[,c(&quot;End_year&quot;, &quot;Tmean&quot;)] colnames(mean_heat)[2] &lt;- &quot;Tmean_heat&quot; phase_Tmeans &lt;- merge(mean_chill, mean_heat, by = &quot;End_year&quot;) pheno &lt;- Alex_first colnames(pheno)[1] &lt;- &quot;End_year&quot; Tmeans_pheno &lt;- merge(phase_Tmeans, pheno, by = &quot;End_year&quot;) head(Tmeans_pheno) End_year Tmean_chill Tmean_heat pheno 1959 2.924324 4.5815534 98 1960 3.147206 4.5100953 101 1961 4.047768 6.0223301 89 1962 2.541892 2.6927184 117 1963 -3.529730 -0.9257282 118 1964 1.443243 2.4723301 116 Now we want to interpolate a surface from these data. There are various ways to do this. In spatial contexts, the so-called Kriging technique is a widely used interpolation method. Check out the link for more details. chillR uses this technique as implemented in the fields package (function Krig). library(fields) k &lt;- Krig(x = as.matrix( Tmeans_pheno[, c(&quot;Tmean_chill&quot;, &quot;Tmean_heat&quot;)]), Y = Tmeans_pheno$pheno) pred &lt;- predictSurface(k) colnames(pred$z) &lt;- pred$y rownames(pred$z) &lt;- pred$x library(reshape2) melted &lt;- melt(pred$z) library(metR) library(colorRamps) colnames(melted) &lt;- c(&quot;Tmean_chill&quot;, &quot;Tmean_heat&quot;, &quot;value&quot;) ggplot(melted, aes(x = Tmean_chill, y = Tmean_heat, z = value)) + geom_contour_fill(bins = 100) + scale_fill_gradientn(colours = alpha(matlab.like(15)), name = &quot;Bloom date \\n(day of the year)&quot;) + geom_contour(col = &quot;black&quot;) + geom_point(data = Tmeans_pheno, aes(x = Tmean_chill, y = Tmean_heat, z = NULL), size = 0.7) + geom_text_contour(stroke = 0.2) + ylab(expression(paste(&quot;Forcing phase &quot;, T[mean], &quot; (&quot;, degree, &quot;C)&quot;))) + xlab(expression(paste(&quot;Chilling phase &quot;, T[mean], &quot; (&quot;, degree, &quot;C)&quot;))) + theme_bw(base_size = 15) This now looks remarkably easy, but it took me a while to put all the pieces together. What happened here is that we used the Kriging function and predicted a surface based on the result. The output contained separate elements for the x, y and z values of the surface, which had to be integrated into one data.frame to be useful for ggplot2. The melt function of the reshape2 package came in handy here. To make a proper plot from these data, we needed the colorRamps package for nice colors, and the metR package to place nice labels on the contour lines. Now that we have the code together to make nice plots, we should make a function from it. pheno_trend_ggplot &lt;- function(temps, pheno, chill_phase, heat_phase, phenology_stage = &quot;Bloom&quot;) { library(fields) library(reshape2) library(metR) library(ggplot2) library(colorRamps) # first, a sub-function (function defined within a function) to # compute the temperature means mean_temp_period &lt;- function(temps, start_JDay, end_JDay, end_season = end_JDay) { temps_JDay &lt;- make_JDay(temps) %&gt;% mutate(Season = Year) if(start_JDay &gt; end_season) temps_JDay$Season[which(temps_JDay$JDay &gt;= start_JDay)] &lt;- temps_JDay$Year[which(temps_JDay$JDay &gt;= start_JDay)]+1 if(start_JDay &gt; end_season) sub_temps &lt;- subset(temps_JDay, JDay &lt;= end_JDay | JDay &gt;= start_JDay) if(start_JDay &lt;= end_JDay) sub_temps &lt;- subset(temps_JDay, JDay &lt;= end_JDay &amp; JDay &gt;= start_JDay) mean_temps &lt;- aggregate(sub_temps[, c(&quot;Tmin&quot;, &quot;Tmax&quot;)], by = list(sub_temps$Season), FUN = function(x) mean(x, na.rm = TRUE)) mean_temps[, &quot;n_days&quot;] &lt;- aggregate(sub_temps[, &quot;Tmin&quot;], by = list(sub_temps$Season), FUN = length)[,2] mean_temps[,&quot;Tmean&quot;] &lt;- (mean_temps$Tmin + mean_temps$Tmax) / 2 mean_temps &lt;- mean_temps[, c(1, 4, 2, 3, 5)] colnames(mean_temps)[1] &lt;- &quot;End_year&quot; return(mean_temps) } mean_temp_chill &lt;- mean_temp_period(temps = temps, start_JDay = chill_phase[1], end_JDay = chill_phase[2], end_season = heat_phase[2]) mean_temp_heat &lt;- mean_temp_period(temps = temps, start_JDay = heat_phase[1], end_JDay = heat_phase[2], end_season = heat_phase[2]) mean_temp_chill &lt;- mean_temp_chill[which(mean_temp_chill$n_days &gt;= max(mean_temp_chill$n_days)-1),] mean_temp_heat &lt;- mean_temp_heat[which(mean_temp_heat$n_days &gt;= max(mean_temp_heat$n_days)-1),] mean_chill &lt;- mean_temp_chill[, c(&quot;End_year&quot;, &quot;Tmean&quot;)] colnames(mean_chill)[2] &lt;- &quot;Tmean_chill&quot; mean_heat&lt;-mean_temp_heat[,c(&quot;End_year&quot;, &quot;Tmean&quot;)] colnames(mean_heat)[2] &lt;- &quot;Tmean_heat&quot; phase_Tmeans &lt;- merge(mean_chill, mean_heat, by = &quot;End_year&quot;) colnames(pheno) &lt;- c(&quot;End_year&quot;, &quot;pheno&quot;) Tmeans_pheno &lt;- merge(phase_Tmeans, pheno, by=&quot;End_year&quot;) # Kriging interpolation k &lt;- Krig(x = as.matrix(Tmeans_pheno[,c(&quot;Tmean_chill&quot;, &quot;Tmean_heat&quot;)]), Y = Tmeans_pheno$pheno) pred &lt;- predictSurface(k) colnames(pred$z) &lt;- pred$y rownames(pred$z) &lt;- pred$x melted &lt;- melt(pred$z) colnames(melted) &lt;- c(&quot;Tmean_chill&quot;, &quot;Tmean_heat&quot;, &quot;value&quot;) ggplot(melted, aes(x = Tmean_chill, y = Tmean_heat, z = value)) + geom_contour_fill(bins = 60) + scale_fill_gradientn(colours = alpha(matlab.like(15)), name = paste(phenology_stage, &quot;date \\n(day of the year)&quot;)) + geom_contour(col = &quot;black&quot;) + geom_text_contour(stroke = 0.2) + geom_point(data = Tmeans_pheno, aes(x = Tmean_chill, y = Tmean_heat, z = NULL), size = 0.7) + ylab(expression(paste(&quot;Forcing phase &quot;, T[mean], &quot; (&quot;, degree, &quot;C)&quot;))) + xlab(expression(paste(&quot;Chilling phase &quot;, T[mean], &quot; (&quot;, degree, &quot;C)&quot;))) + theme_bw(base_size = 15) } chill_phase &lt;- c(317, 62) heat_phase &lt;- c(360, 105.5) pheno_trend_ggplot(temps = temps, pheno = Alex_first, chill_phase = chill_phase, heat_phase = heat_phase, phenology_stage = &quot;Bloom&quot;) Now we’ve automated the whole procedure, so that we never have to bother with the details of the plot production again. 26.3 Applying our functions to California walnuts Let’s use the functions we’ve produced so far to do a quick analysis of walnuts in California. With the following button, you can download leaf emergence data for the Payne walnut cultivar, observed in Davis, California. Save this in your data directory. Download walnut phenology data for Davis Cali_temps &lt;- read_tab(&quot;data/Davis_weather.csv&quot;) Walnut_pheno &lt;- read_tab(&quot;data/Davis_Payne_leaf_out.csv&quot;) %&gt;% mutate(Year = as.numeric(substr(Leaf.date,7,8)), Year = Year+(19+(Year&lt;25))*100, Month = as.numeric(substr(Leaf.date,4,5)), Day = as.numeric(substr(Leaf.date,1,2))) %&gt;% make_JDay() %&gt;% select(Year, JDay) colnames(Walnut_pheno) &lt;- c(&quot;Year&quot;, &quot;pheno&quot;) Cali_temps_hourly &lt;- stack_hourly_temps(Cali_temps, latitude = 38.5) Cali_daychill &lt;- daily_chill(hourtemps = Cali_temps_hourly, running_mean = 1, models = list(Chilling_Hours = Chilling_Hours, Utah_Chill_Units = Utah_Model, Chill_Portions = Dynamic_Model, GDH = GDH) ) plscf &lt;- PLS_chill_force(daily_chill_obj = Cali_daychill, bio_data_frame = Walnut_pheno, split_month = 6, chill_models = &quot;Chill_Portions&quot;, heat_models = &quot;GDH&quot;, runn_means = 11) plot_PLS_chill_force(plscf, chill_metric = &quot;Chill_Portions&quot;, heat_metric = &quot;GDH&quot;, chill_label = &quot;CP&quot;, heat_label = &quot;GDH&quot;, chill_phase = c(-56, 5), heat_phase = c(19, 77)) pheno_trend_ggplot(temps = Cali_temps, pheno = Walnut_pheno, chill_phase = c(309, 5), heat_phase = c(19, 77), phenology_stage = &quot;Leaf emergence&quot;) Here we have a more revealing color pattern. The earliest leaf emergence occurred when the chilling phase was cool, and the forcing phase warm. This is indicated by the blue colors in the top left corner of the plot. The bottom right corner, in contrast, looks red, indicating that a warm chilling phase and a cool forcing phase lead to late bloom. Exercises on evaluating PLS regression results Please document all results of the following assignments in your learning logbook. Reproduce the analysis for the ‘Roter Boskoop’ dataset. We’ve looked at data from a number of locations so far. How would you expect this surface plot to look like in Beijing? And how should it look in Tunisia? "],["pls_chillforce_relimp.html", "Chapter 27 The relative importance of chill and heat Learning goals for this lesson 27.1 Chilling vs. forcing temperatures 27.2 Patterns in temperature responses 27.3 The warm end of the spectrum 27.4 Implications of our hypothesis Exercises on the relative importance of chill and heat", " Chapter 27 The relative importance of chill and heat Learning goals for this lesson Get an overview of temperature response patterns of temperate tree species across a range of climates Become familiar with a general hypothesis of how temperate trees respond to warming during the chilling and forcing phases Consider evidence in favor of this hypothesis, as well well as implications for phenology changes in response to climate change 27.1 Chilling vs. forcing temperatures In the last chapter, we related mean temperatures during the chilling and forcing phases to bloom dates of ‘Alexander Lucas’ pears. Bloom dates of pear ‘Alexander Lucas’ in Klein-Altendorf, as a function of mean temperatures during the chilling and forcing phases We did a similar analysis for leaf emergence dates of the walnut cultivar ‘Payne’ in Davis, California. Bloom dates of ‘Payne’ walnuts in Davis, California, as a function of mean temperatures during the chilling and forcing phases It was somewhat difficult to detect a clear pattern for the pears in Klein-Altendorf, but the walnut analysis showed a fairly clear pattern, with the earliest leaf emergence dates corresponding to cool conditions during endodormancy and relatively high temperatures during ecodormancy. This is in line with what we know about the dormancy phase, which should be shortened by abundant chill during endodormancy and by lots of heat during ecodormancy. Given what we learned about the temperature chill relationship in the chapter on Why PLS doesn’t always work, we should not be surprised to see the kind of temperature response curve that’s shown in the plot. But what do we see in different climatic settings? There have been a number of similar analyses by now, so let’s look at what came out of these. One of the first plots was produced for chestnuts in Beijing: Bloom dates of chestnuts in Beijing, as a function of mean temperatures during the chilling and forcing phases (Guo et al., 2013) Here you can see the plot for cherries in Klein-Altendorf: Bloom dates of cherries ‘Schneiders späte Knorpelkirsche’ in Klein-Altendorf, as a function of mean temperatures during the chilling and forcing phases (Luedeling et al., 2013a) And this is the figure for apricots in the UK: Bloom dates of apricots in the UK, as a function of mean temperatures during the chilling and forcing phases (Martı́nez-Lüscher et al., 2017) 27.2 Patterns in temperature responses You’ll have noticed that the general color scheme is the same, and there’s a tendency for the earliest dates to be in the upper left corner and the latest dates at the bottom right. There are also some differences, however, in the appearance of these plots, in particular regarding the slope of the color gradient. Admittedly, these differences didn’t come out too clearly in the plots we just looked at, but we can see what’s going on when we look at such plots across a climatic gradient. To explore tree phenology responses along a temperature gradient, we compared apricot bloom data from five locations across China: Study locations in China used to study phenology responses to temperature across a temperature gradient (Guo et al., 2015a) As you can see below, winter temperatures at these five locations are quite different: Temperature profiles of the study locations in China (Guo et al., 2015a) For each of these locations, we found phenology data in the Chinese Phenology database and did similar analyses to what we’ve looked at so far. I should note that these were different apricot cultivars, which represents a potential source of error. It’s hard to display the full color surfaces for all five locations in the same figure, so the following plot only shows the contour lines: Bloom dates of apricots in five locations in China, as a function of mean temperatures during the chilling and forcing phases (Guo et al., 2015a) With increasing temperature, we see increasingly steep contour lines. While these lines were almost horizontal for Jiamusi, the coldest location, they are approximately diagonal for Guiyang, the warmest site. All other sites fit nicely on the gradient between cold and warm, along which their contour lines show increasingly steep slopes. What we found here looks like there could be a general pattern in the temperature response of temperate trees. We illustrated this temperature response hypothesis in the following figure (original in grayscale in Guo et al. (2015a)): Hypothetical response of temperate tree phenology to temperature during the chilling and forcing periods According to this hypothesis, spring phenology of trees growing in cold-winter climates should respond primarily to temperatures during ecodormancy, when buds are responsive to heat. Chill accumulation there, at the left end of this figure, is probably so high, and winter temperatures are so favorable for chill accumulation, that the usual temperature variation during this period has little to no effect. Such a temperature response situation might explain why we’ve been having such a hard time delineating the chilling period in cold places (note of course that such ambiguous delineations are the basis for these figures). As endodormancy temperatures increase, conditions during chill accumulation start showing an effect. We’re now entering the yellow area in the diagram, where contour lines start bending upwards, indicating that warm chilling periods now add a delaying effect to the still dominant influence of forcing temperatures. As we transition through the yellow region, this delaying effect gets increasingly stronger. Eventually, with further increases in temperature, we reach a point where temperature conditions during chill accumulation take over as the dominant effect. At this point, we might be in a situation where temperature increases no longer lead to advancing phenology, but first to stagnation and ultimately even to delays in budbreak dates. This is only a hypothesis for now, so we should look for ways to test it. A bit more weight was added to this hypothesis by an analysis done on ‘Fuji’ apples at 4 locations in Shaanxi Province in China. The temperature gradient here isn’t quite as impressive as in the larger-scale study on apricots, but there is still some variation here, and now we’re actually working with the same apple cultivar across all four locations: Study locations in Shaanxi, China (Guo et al., 2019) Mean temperatures during the chilling season ranged from 2.6°C to 6.0°C, and the overall range of chilling season temperatures ranged from about 1°C to approximately 7°C. Results from the contour analysis indicate that these differences had a distinct impact on the bloom date response to temperature during chilling and forcing: Bloom date response of ‘Fuji’ apples across four locations in Shaanxi Province, China, to temperatures during the chilling and forcing periods (Guo et al., 2019) I once enjoyed the privilege of visiting the coldest location, Yan’an, in winter, and I can confirm that it’s pretty cold there… Accordingly, the contour lines in the diagram are quite close to horizontal. For the warmer sites, especially for Liquan, we see a very different pattern, with a marked bloom-delaying effect of high temperatures during endodormancy. 27.3 The warm end of the spectrum So far, all the temperature response curves we looked at, even the whole range of the temperature gradients from China, featured relatively cool conditions. With a bit of imagination, we can easily fit all these locations within our temperature response hypothesis. However, the boldest predictions concern the warmest end of the temperature spectrum, for which we’re expecting a net delay in spring phenology in response to warming. Delayed phenology is not something you find often in the scientific literature, where the expectation of continually advancing bloom and leaf emergence dates is currently dominant. Interestingly, however, even some of the key references on such phenology advances (like this one: Parmesan &amp; Yohe (2003)) contain, besides lots of data indicating advancing phenology, also a few records that point in the opposite direction. These could be measurement errors of course, but they may also indicate that something else is going on here. In the context of our line of work, testing the warm end of our hypothetical temperature response curve would require phenology data from a really warm location. Unfortunately, at such warm locations, people usually don’t grow temperate fruit trees. Or do they? Maybe you can imagine that I was quite excited when I was contacted in 2015 by Haïfa Benmoussa from Tunisia, who was working with long-term phenology records from this really warm growing region for her PhD. You’ve already seen some of her results in earlier chapters. What I was most excited about was the prospect of drawing contour lines for trees grown under really warm conditions that might help test our temperature response hypothesis. Here’s what we found for almonds grown in Central Tunisia: Temperature response of local almond cultivars in Sfax, Tunisia (Benmoussa et al., 2017a) These are local almond cultivars, so we can expect them to be pretty well adapted to local temperature conditions. Let’s look at some ‘foreign’ cultivars that were imported from cooler locations: Temperature response of foreign almond cultivars in Sfax, Tunisia (Benmoussa et al., 2017a) We see variation in temperature response slopes, but the array of cultivars observed here certainly includes some that responded more strongly to temperatures during chilling than during forcing. Almonds generally have a fairly low chilling requirement, making them suitable for a lot of Mediterranean-climate growing regions, such as California, Spain or Tunisia. The situation is a bit different for pistachios, which are also grown in many of these regions but grow leaves and flowers much later and are believed to need more chill than almonds. The colleagues in Sfax have also been collecting phenology data for pistachios, and the contour plots are rather striking: Temperature response of pistachios in Sfax, Tunisia, to temperatures during the chilling and forcing phases (Benmoussa et al., 2017b) Here, we actually see the vertical contour lines that our hypothesis predicted! Have we now proven our hypothesis? Well, no. It’s hard to prove anything in science (unless you’re in Mathematics). We can only ever hope to support our hypotheses, not really prove them (or we can reject them sometimes). To really firmly conclude that we’ve described the temperature response pattern well, we’d need more evidence from more species in more places (lots of opportunities to get involved here). 27.4 Implications of our hypothesis If our temperature response hypothesis is correct, we should be looking out for signals in phenology dynamics that are not well aligned with the notion of ever-advancing phenology. We should be expecting strong advances up to a certain point, but with continued warming, we should also expect a slowdown in these advances. Eventually, phenology may stagnate, and at some point, we may even see a shift to noticeable phenology delays. I’ve seen a few papers that point in this direction, but I don’t think there’s been a lot of systematic work on this (another opportunity to get involved). Exercises on the relative importance of chill and heat Please document all results of the following assignments in your learning logbook. Describe the temperature response hypothesis outlined in this chapter. References Guo L, Dai J, Wang M, Xu J &amp; Luedeling E. (2015a). Responses of spring phenology in temperate zone trees to climate warming: A case study of apricot flowering in china. Agricultural and Forest Meteorology, 201, 1–7. doi: 10.1016/j.agrformet.2014.10.016 Parmesan C &amp; Yohe G. (2003). A globally coherent fingerprint of climate change impacts across natural systems. Nature, 421(6918), 37–42. doi: https://www.nature.com/articles/nature01286 "],["exp_PLS.html", "Chapter 28 Experimentally enhanced PLS Learning goals for this lesson 28.1 Enhanced phenology data Exercises on experimental PLS", " Chapter 28 Experimentally enhanced PLS Learning goals for this lesson Learn how to enhance your phenology records Get some insights into work conducted in our lab 28.1 Enhanced phenology data We’ve learned about the difficulty of working with data from locations such as Klein-Altendorf, where temperature dynamics limit our ability to probe for phenology responses to chill and heat variation (because there is very little variation during certain months). Can we possibly find a way to enhance our dataset, so that it becomes more amenable to the kind of analysis we want to do? Yes, we can! And that is what we did in a two-winter experiment in Campus Klein-Altendorf (Fernandez et al., 2021). Our experiment relied on generating a number of environments to which young potted trees were exposed over the winter. During the season 2018/2019, we used three environmental conditions: During the second winter (2019/2020), we added 4 more environments to the experiment. These new environments were three chambers covered with different materials plus the conditions outside these chambers in Campus Endenich of the University of Bonn. By transferring the trees across environments at different times, we were able to generate 66 experimental seasons in apple and 33 experimental seasons in pear. In the plot below, we can take a look at a schematic representation (animated🙂) of the experiment using the libraries ggplot2 and gganimate. Note that most of the code for plotting is a common ggplot call using the geom_jitter() and geom_path() functions. We can later add the animation with the transition_reveal() function. We’ll need the interactive_plot_PLS.csv file, which you can download here. As usual, please save this in your data directory. Download interactive plot data library(ggplot2) library(gganimate) library(gifski) library(png) data &lt;- read_tab(&quot;data/interactive_plot_PLS.csv&quot;) # This part is to re-code the different conditions data[which(data$Final_Condition == &quot;Outside&quot;), &quot;Final_condition_2&quot;] &lt;- 1 data[which(data$Final_Condition == &quot;Un-heated&quot;), &quot;Final_condition_2&quot;] &lt;- 2 data[which(data$Final_Condition == &quot;Heated&quot;), &quot;Final_condition_2&quot;] &lt;- 3 # Implement the plot exp_plot &lt;- ggplot(data, aes(Day, Final_condition_2, color = factor(Treatment, levels = c(1 : 33)))) + geom_jitter(size = 4) + geom_path(size = 1) + scale_y_continuous(breaks = c(1, 2, 3), labels = c(&quot;Outside&quot;, &quot;Un-Heated&quot;, &quot;Heated&quot;)) + scale_x_continuous(breaks = as.numeric(levels(as.factor(data$Day))), labels = levels(as.factor(data$Day))) + labs(x = &quot;Days of experiment&quot;, y = &quot;Condition&quot;, color = &quot;Treatment&quot;) + theme_bw() + theme(axis.text.y = element_text(angle = 90, hjust = 0.5), legend.position = &quot;none&quot;) + transition_reveal(Day) anim_save(&quot;data/interactive_experiment_plot.gif&quot;, animation = last_animation()) Illustration of the tree movements in our PLS-enhancement experiment We recorded the date of bloom in our trees after exposing them to different temperature patterns over the winter period. This range of conditions resulted in substantial differences in bloom dates. In the plot above, you can see the mean temperature (solid line), the range of mean temperature (sky blue shade) and the range of bloom dates (rectangles at the bottom) among treatments over the two winters. Now that we know how the data were generated, we can take a look at some of the general results generated by this study. Let’s load the weather files and the file of flowering date observations for apples (and save them in the data directory): Download phenology data Download weather data library(chillR) library(lubridate) pheno_data &lt;- read_tab(&quot;data/final_bio_data_S1_S2_apple.csv&quot;) weather_data &lt;- read_tab(&quot;data/final_weather_data_S1_S2.csv&quot;) We’ll need some functions we produced in earlier chapters: ggplot_PLS from the chapter on Delineating temperature response phases with PLS regression plot_PLS_chill_force from the chapter on PLS regression with agroclimatic metrics pheno_trend_ggplot from the chapter on Evaluating PLS outputs Chill_model_sensitivity from the chapter on Why PLS doesn’t always work Chill_sensitivity_temps from the chapter on Why PLS doesn’t always work I’m loading them again now, but you don’t need to see this again, so I’m setting the chunk options to echo=FALSE, message=FALSE, warning=FALSE. We’ll want to do a PLS analysis, so I have to manipulate the dataset a bit first (I’ll explain this in the class). pheno_data$Year &lt;- pheno_data$Treatment + 2000 weather_data$Year[which(weather_data$Month &lt; 6)] &lt;- weather_data$Treatment[which(weather_data$Month &lt; 6)] + 2000 weather_data$Year[which(weather_data$Month &gt;= 6)]&lt;- weather_data$Treatment[which(weather_data$Month &gt;= 6)] + 1999 day_month_from_JDay &lt;- function(year, JDay) { fulldate &lt;- ISOdate(year - 1, 12, 31) + JDay * 3600 * 24 return(list(day(fulldate), month(fulldate))) } weather_data$Day &lt;- day_month_from_JDay(weather_data$Year, weather_data$JDay)[[1]] weather_data$Month &lt;- day_month_from_JDay(weather_data$Year, weather_data$JDay)[[2]] Now we’re ready for the PLS analysis: pls_out &lt;- PLS_pheno(weather_data = weather_data, bio_data = pheno_data) ggplot_PLS(pls_out) This has gotten a lot clearer than what we’ve seen in chapter Delineating temperature response phases with PLS regression for records from this location. Let’s try the same analysis with agroclimatic metrics (Chill Portions and Growing Degree Hours): temps_hourly &lt;- stack_hourly_temps(weather_data, latitude = 50.6) daychill &lt;- daily_chill(hourtemps = temps_hourly, running_mean = 1, models = list(Chilling_Hours = Chilling_Hours, Utah_Chill_Units = Utah_Model, Chill_Portions = Dynamic_Model, GDH = GDH) ) plscf &lt;- PLS_chill_force(daily_chill_obj = daychill, bio_data_frame = pheno_data[!is.na(pheno_data$pheno), ], split_month = 6, chill_models = &quot;Chill_Portions&quot;, heat_models = &quot;GDH&quot;, runn_means = 11) plot_PLS_chill_force(plscf, chill_metric = &quot;Chill_Portions&quot;, heat_metric = &quot;GDH&quot;, chill_label = &quot;CP&quot;, heat_label = &quot;GDH&quot;, chill_phase = c(-76, 10), heat_phase = c(17, 97.5)) This is now pretty clear, and we can easily derive chilling and forcing phases. For these we can then calculate the mean chill accumulation and the mean heat accumulation, which approximate the respective requirements. Because some of the treatments produced rather anomalous bloom predictions, I’m not using the mean of the chill and heat accumulation during the respective interval, but the median. I’ll use the 25% and 75% quantiles of the distributions as an estimate of uncertainty. chill_phase &lt;- c(290, 10) heat_phase &lt;- c(17, 97.5) chill &lt;- tempResponse(hourtemps = temps_hourly, Start_JDay = chill_phase[1], End_JDay = chill_phase[2], models = list(Chill_Portions = Dynamic_Model), misstolerance = 10) heat &lt;- tempResponse(hourtemps = temps_hourly, Start_JDay = heat_phase[1], End_JDay = heat_phase[2], models = list(GDH = GDH)) chill_requirement &lt;- median(chill$Chill_Portions) chill_req_error &lt;- quantile(chill$Chill_Portions, c(0.25, 0.75)) heat_requirement &lt;- median(heat$GDH) heat_req_error &lt;- quantile(heat$GDH, c(0.25, 0.75)) So we have a chilling requirement around 48.2 CP, but with a 50% confidence interval ranging from 34.4 to 59 CP. The heat need of this cultivar is estimated as 11709 GDH, with a 50% confidence interval ranging from 6615 to 16387 GDH. Let’s also look at the temperature range at this location in relation to the temperature sensitivity of the Dynamic Model. Model_sensitivities_CKA &lt;- Chill_model_sensitivity(latitude = 50.6, temp_models = list(Dynamic_Model = Dynamic_Model, GDH = GDH), month_range = c(10:12, 1:5)) write.csv(Model_sensitivities_CKA, &quot;data/Model_sensitivities_CKA.csv&quot;, row.names = FALSE) Chill_sensitivity_temps(Model_sensitivities_CKA, weather_data, temp_model = &quot;Dynamic_Model&quot;, month_range = c(10, 11, 12, 1, 2, 3), legend_label = &quot;Chill per day \\n(Chill Portions)&quot;) + ggtitle(&quot;Chill model sensitivity at Klein-Altendorf on steroids&quot;) This pattern looks a lot more promising. We see that temperature data spans quite a bit of model variation, which is an indication that PLS analysis may capture dormancy dynamics better than in the naturally observed dataset from Klein-Altendorf. Let’s see if we can see a pattern in the temperature response plot now. pheno_trend_ggplot(temps = weather_data, pheno = pheno_data[ ,c(&quot;Year&quot;, &quot;pheno&quot;)], chill_phase = chill_phase, heat_phase = heat_phase, exclude_years = pheno_data$Year[is.na(pheno_data$pheno)], phenology_stage = &quot;Bloom&quot;) Now we can see a fairly clear temperature response pattern for Klein-Altendorf. Some of the points are still a bit off from what we may have expected to see. Here we should note that some of the treatments were quite far from what a tree might experience in an orchard. It seems likely that some of these extraordinary temperature curves were involved in generating the strange patterns. Exercises on experimental PLS No exercises today. Maybe you can work on cleaning up your logbook. References Fernandez E, Krefting P, Kunz A, Do H, Fadón E &amp; Luedeling E. (2021). Boosting statistical delineation of chill and heat periods in temperate fruit trees through multi-environment observations. Agricultural and Forest Meteorology, 310, 108652. doi: 10.1016/j.agrformet.2021.108652 "],["model_validity.html", "Chapter 29 Making valid tree phenology models Learning goals for this lesson 29.1 The modeling challenge 29.2 Validating models 29.3 Mapping validity domains 29.4 One last thought on model validity Exercises on making valid tree phenology models", " Chapter 29 Making valid tree phenology models Learning goals for this lesson Understand why models should not just be validated based on the output they produce Learn the difference between output validation and process validation Understand what validation for purpose means Learn what validity domains of models are Get an idea of what it takes to make models that can be trusted with projections under future temperature conditions 29.1 The modeling challenge We’ve already touched on the challenges of modeling winter chill a few times, but so far we’ve stayed away from the full challenge of modeling the whole dormancy season - and making predictions of budburst dates. Today, we’ll start getting into this topic. I’m not going to systematically review modeling attempts of the past. A major reason for this is that I’m too lazy to do that, but I’m also quite sure that there haven’t been many convincing modeling attempts so far. This is largely because several major challenges have stood in the way of generating a good model: uncertainty about the temperature response during chilling uncertainty about the temperature response during forcing uncertainty about possible interactions between chill accumulation and heat requirements uncertainty about start and end dates of chilling and forcing periods On the other hand, we have experimental or observational evidence on tree responses during dormancy that a model should be able to explain: trees respond to chilling for some time, and to forcing later it seems likely that low chill accumulation can be compensated by additional heat high temperatures appear to cancel previously accumulated chill, to some extent at least trees show distinct responses to temperatures occurring in particular temperature cycles frost doesn’t seem to be effective for chill accumulation temperate tree crops can be grown even in fairly warm locations … There are surely more things we know about trees during dormancy that should also be listed here. Credible models should include mechanisms that allow them, at least in principle, to explain phenomena we see. When models lack mechanisms that might explain important behavior that we see in orchards, they aren’t particularly credible. Similarly, when models disregard the uncertainties listed above and are based on the assumption that processes that are still quite unclear are perfectly understood, it is difficult to take them very seriously. In my view, this is true for virtually all full dormancy modeling frameworks so far - at least the ones I’m familiar with. 29.2 Validating models There have certainly been some models that have been able to produce reasonably accurate predictions of observed bloom dates, but this doesn’t necessarily mean that they are actually accurate models. Comparing a model’s ability to predict observations that have been made is often used as the only way of validating models, but this is really not enough. I’ll distinguish here between output validation and process validation. In output validation, we only look at whether our model can predict what we actually observed. This can then be quantified with various measures, including Root Mean Square Error, Model Efficiency etc. With this validation method, however, we get very little information on whether the model actually did something reasonable. It’s quite possible that the model produced the right results for the wrong reasons, if we don’t bother to look under the hood. Process validation is harder and it requires us to actually know something about the processes involved in the system of interest. I don’t know of any formal procedures for doing such a process validation, so we’re a bit on our own with this (unless you know of a method). What we need to achieve is a comparison of (our) knowledge about the biological processes that are at work with the set of processes that are included in the model. As in the chapter on Simple phenology analysis, we could consider starting this process with an influence diagram (a drawing with boxes and arrows) or some other schematic representation of our understanding of system dynamics. Or we can start with the kind of lists I showed above, and see if we can convince ourselves that our model covers these issues. Note that we probably shouldn’t be too hard on the poor modelers, because it is awfully difficult to make good models. Sometimes not-so-perfect models are sufficient for the purposes of the people who use the models. But we should always remain critical and look for possible flaws in the products we might want to use. Another important consideration in model validation is the purpose of the model, i.e. what do we actually want to use the model for. A validation for purpose would start with a reflection on what the model should be able to achieve and carefully evaluate whether we can realistically expect it to prove useful in the context we have in mind. This is important, because each model has a certain validity domain, i.e. the range of conditions that the model is capable of making reliable predictions for. To illustrate this point, let’s look at a very simple example: require(ggplot2) dat&lt;-data.frame(x = c(1, 2, 3, 4), y = c(2.3, 2.5, 2.7, 2.7)) ggplot(dat,aes(x = x, y = y)) + geom_smooth(method = &quot;lm&quot;, fullrange = TRUE) + geom_smooth(method = &quot;lm&quot;, fullrange = FALSE, col = &quot;dark green&quot;) + geom_point() + xlim(c(0,10)) + geom_vline(xintercept = 8, col=&quot;red&quot;) + theme_bw(base_size = 15) In this figure, I’ve produced a very simple regression model based on measurements of y for x-values between 1 and 4. Can we use this model to predict the value of y for x=8, which is indicated by the red line? My guess is that most readers will have a bad feeling about this task - and for good reasons. The model’s validity domain is quite tightly circumscribed by the set of values that were used to produce the model - the range shown by the green regression line and the dark shaded area. We really have no way of knowing how the system of interest behaves outside this range. The blue line and the lightly shaded area should normally not even be drawn (and it took setting the fullrange parameter in geom_smooth to TRUE to make this appear). Actually, what I just said isn’t always strictly true, unless you’re a true believer in the frequentist idea of science, where we assume that we know absolutely nothing except what the data tells us. If you’re not one of these people, you should have developed an expectation of how the system behaves even before running the regression analysis. If this expectation leaves you reasonably confident that the response variable you’re modeling behaves similarly for x=8 as for x=3, then you may be able to make such predictions. You should then clearly state that you’re making this assumption, however, and provide reasons for why you think this is justified. Assuming that we have no reason to expect the regression model to be valid outside the range of values used to calibrate it, it is easy to see where we can expect reliable predictions and where we can’t. For more complex models, such as crop models or phenology models, this is much harder to see, and questions about validity domains are often not adequately addressed. For us to have confidence in a phenology prediction model, we should expect model performance to be validated under conditions that resemble those we want to make predictions for. This may seem obvious, but it is actually pretty difficult to achieve, when your goal is, for example, to predict phenology responses to climate change. This is a pretty common objective of phenology modeling studies, and I’m not aware of any such studies having presented adequate evidence that the models that are applied actually meet this requirement. The previous chapters have shown that questions about the validity domain of phenology models are justified. After all, we expect temperature responses to change as the climate changes, e.g. from a dominant effect of forcing temperatures to a greater importance of chilling temperatures. It is of course possible to build such models, but most analyses use relatively simple equations to describe phenology changes, which clearly don’t allow for changes in temperature response dynamics. When we can have little confidence that models sufficiently capture the temperature-responsive processes that are going on in our system, it is hard to know what to make of them. Especially when such studies make no attempt to quantify the possible error that results from this omission, we really get very little out of such analyses. They provide numbers we can’t trust, and they don’t offer information on how reliable they are. Usually we also don’t get clear indications of the major assumptions about system biology that were made in producing the models. Such studies, in my opinionated view, are useless at best, and misleading at worst. 29.3 Mapping validity domains Let’s assume we made a phenology model based on historic phenology observations at Klein-Altendorf, and we wanted to use this model to predict future phenology at the same location. We can map the validity domain of our model by plotting the range of conditions under which we’ve made observations. We can then compare this range with the range of conditions we want to make predictions for, in this case the various future climate scenarios we produced in the chapter on Making CMIP6 scenarios. We saved all of these data earlier (I hope you did…), so we can just load them now. I’ll also convert the data into one long data.frame, with all the attributes (Time horizon, GCM, SSP) stored with each data point. require(chillR) past_weather &lt;- read_tab(&quot;data/TMaxTMin1958-2019_patched.csv&quot;) past_weather$SSP_Time &lt;- &quot;Past&quot; future_temps &lt;- load_temperature_scenarios(&quot;data/future_climate&quot;, &quot;Bonn_futuretemps&quot;) SSPs &lt;- c(&quot;ssp126&quot;, &quot;ssp245&quot;, &quot;ssp370&quot;, &quot;ssp585&quot;) Times &lt;- c(2050, 2085) list_ssp &lt;- strsplit(names(future_temps), &#39;\\\\.&#39;) %&gt;% map(2) %&gt;% unlist() list_gcm &lt;- strsplit(names(future_temps), &#39;\\\\.&#39;) %&gt;% map(3) %&gt;% unlist() list_time &lt;- strsplit(names(future_temps), &#39;\\\\.&#39;) %&gt;% map(4) %&gt;% unlist() for(SSP in SSPs) for(Time in Times) {Temps &lt;- future_temps[list_ssp == SSP &amp; list_time == Time] names(Temps) &lt;- list_gcm[list_ssp == SSP &amp; list_time == Time] for(gcm in names(Temps)) Temps[[gcm]] &lt;- Temps[[gcm]] %&gt;% mutate(GCM = gcm, SSP = SSP, Time = Time) Temps &lt;- do.call(&quot;rbind&quot;, Temps) if(SSP == SSPs[1] &amp; Time == Times[1]) results &lt;- Temps else results &lt;- rbind(results, Temps) } results$SSP[results$SSP == &quot;ssp126&quot;] &lt;- &quot;SSP1&quot; results$SSP[results$SSP == &quot;ssp245&quot;] &lt;- &quot;SSP2&quot; results$SSP[results$SSP == &quot;ssp370&quot;] &lt;- &quot;SSP3&quot; results$SSP[results$SSP == &quot;ssp585&quot;] &lt;- &quot;SSP5&quot; results$SSP_Time &lt;- paste0(results$SSP,&quot; &quot;,results$Time) future_months &lt;- aggregate(results[, c(&quot;Tmin&quot;, &quot;Tmax&quot;)], by = list(results$SSP_Time, results$Year, results$Month), FUN = mean) colnames(future_months)[1:3] &lt;- c(&quot;SSP_Time&quot;, &quot;Year&quot;, &quot;Month&quot;) past_months &lt;- aggregate(past_weather[, c(&quot;Tmin&quot;,&quot;Tmax&quot;)], by = list(past_weather$SSP_Time, past_weather$Year, past_weather$Month), FUN=mean) colnames(past_months)[1:3] &lt;- c(&quot;SSP_Time&quot;, &quot;Year&quot;, &quot;Month&quot;) all_months &lt;- rbind(past_months, future_months) all_months$month_name &lt;- factor(all_months$Month, levels = c(6:12, 1:5), labels = month.name[c(6:12, 1:5)]) The total range of point values can be described with a so-called convex hull. This is a polygon that includes all observed values. It is constructed from the smallest possible set of actual observations that still allows enclosing all observations by a polygon connecting all the data points. Here’s how we can plot this with ggplot: library(tidyverse) # Calculate the hulls for each group hull_temps &lt;- all_months %&gt;% group_by(SSP_Time, month_name) %&gt;% slice(chull(Tmin, Tmax)) ggplot(hull_temps, aes(Tmin, Tmax, fill = factor(SSP_Time))) + geom_polygon() + facet_wrap(vars(month_name)) + scale_fill_manual(name=&quot;Scenario&quot;, breaks=c(&quot;Past&quot;, &quot;SSP1 2050&quot;, &quot;SSP1 2085&quot;, &quot;SSP2 2050&quot;, &quot;SSP2 2085&quot;, &quot;SSP3 2050&quot;, &quot;SSP3 2085&quot;, &quot;SSP5 2050&quot;, &quot;SSP5 2085&quot;), values=c(&quot;black&quot;, alpha(&quot;light green&quot;,0.4), alpha(&quot;dark green&quot;,0.4), alpha(&quot;coral&quot;,0.4), alpha(&quot;dark red&quot;,0.4), alpha(&quot;yellow&quot;,0.4), alpha(&quot;orange&quot;,0.4), alpha(&quot;light blue&quot;,0.4), alpha(&quot;dark blue&quot;,0.4))) + theme_bw(base_size = 15) It’s hard to see what’s going on here, so let’s only focus on the dormancy months. ggplot(hull_temps[which(hull_temps$Month %in% c(10,11,12,1,2,3)),], aes(Tmin, Tmax, fill = factor(SSP_Time))) + geom_polygon() + facet_wrap(vars(month_name)) + scale_fill_manual(name=&quot;Scenario&quot;, breaks=c(&quot;Past&quot;, &quot;SSP1 2050&quot;, &quot;SSP1 2085&quot;, &quot;SSP2 2050&quot;, &quot;SSP2 2085&quot;, &quot;SSP3 2050&quot;, &quot;SSP3 2085&quot;, &quot;SSP5 2050&quot;, &quot;SSP5 2085&quot;), values=c(&quot;black&quot;, alpha(&quot;light green&quot;,0.4), alpha(&quot;dark green&quot;,0.4), alpha(&quot;coral&quot;,0.4), alpha(&quot;dark red&quot;,0.4), alpha(&quot;yellow&quot;,0.4), alpha(&quot;orange&quot;,0.4), alpha(&quot;light blue&quot;,0.4), alpha(&quot;dark blue&quot;,0.4))) + theme_bw(base_size = 15) We see clearly that the data we collected in the past - the data we would presumably use to calibrate a phenology model - only cover a relatively small part of the temperature regime that we should expect in the future. Especially for SSP5, we’d be missing a substantial part of the range of expected conditions, if we relied on a model built with data collected in the past. This means that we should not use such a model to predict conditions for these future scenarios! What if we based our model development on our experimentally enhanced observations? enhanced &lt;- read_tab(&quot;data/final_weather_data_S1_S2.csv&quot;) enhanced$Year &lt;- enhanced$Treatment enhanced$SSP_Time &lt;- &quot;Past enhanced&quot; enhanced_months &lt;- aggregate(enhanced[, c(&quot;Tmin&quot;, &quot;Tmax&quot;)], by = list(enhanced$SSP_Time, enhanced$Year, enhanced$Month), FUN = mean) colnames(enhanced_months)[1:3] &lt;- c(&quot;SSP_Time&quot;, &quot;Year&quot;, &quot;Month&quot;) all_months_enhanced &lt;- rbind(enhanced_months, future_months) all_months_enhanced$month_name &lt;- factor(all_months_enhanced$Month, levels = c(6:12, 1:5), labels = month.name[c(6:12, 1:5)]) # Calculate the hulls for each group hull_temps_enhanced &lt;- all_months_enhanced %&gt;% group_by(SSP_Time, month_name) %&gt;% slice(chull(Tmin, Tmax)) ggplot(hull_temps_enhanced[ which(hull_temps_enhanced$Month %in% c(10, 11, 12, 1, 2, 3)),], aes(Tmin, Tmax, fill = factor(SSP_Time))) + geom_polygon() + facet_wrap(vars(month_name)) + scale_fill_manual(name=&quot;Scenario&quot;, breaks=c(&quot;Past enhanced&quot;, &quot;SSP1 2050&quot;, &quot;SSP1 2085&quot;, &quot;SSP2 2050&quot;, &quot;SSP2 2085&quot;, &quot;SSP3 2050&quot;, &quot;SSP3 2085&quot;, &quot;SSP5 2050&quot;, &quot;SSP5 2085&quot;), values=c(&quot;black&quot;, alpha(&quot;light green&quot;,0.4), alpha(&quot;dark green&quot;,0.4), alpha(&quot;coral&quot;,0.4), alpha(&quot;dark red&quot;,0.4), alpha(&quot;yellow&quot;,0.4), alpha(&quot;orange&quot;,0.4), alpha(&quot;light blue&quot;,0.4), alpha(&quot;dark blue&quot;,0.4))) + theme_bw(base_size = 15) This is also not such a great coverage of the scenarios we’re expecting, but mainly we’ve overshot our goal a bit, with much warmer scenarios in the experimental setting than are predicted for the future. Maybe we need to combine historic conditions with our enhanced treatment. past_months$SSP_Time &lt;- &quot;Past combined&quot; enhanced_months$SSP_Time &lt;- &quot;Past combined&quot; all_months_both &lt;- rbind(enhanced_months, past_months, future_months) all_months_both$month_name &lt;- factor(all_months_both$Month, levels = c(6:12, 1:5), labels = month.name[c(6:12, 1:5)]) hull_temps_both &lt;- all_months_both %&gt;% group_by(SSP_Time, month_name) %&gt;% slice(chull(Tmin, Tmax)) ggplot(hull_temps_both[ which(hull_temps_both$Month %in% c(10, 11, 12, 1, 2, 3)),], aes(Tmin, Tmax, fill = factor(SSP_Time))) + geom_polygon() + facet_wrap(vars(month_name)) + scale_fill_manual(name=&quot;Scenario&quot;, breaks=c(&quot;Past combined&quot;, &quot;SSP1 2050&quot;, &quot;SSP1 2085&quot;, &quot;SSP2 2050&quot;, &quot;SSP2 2085&quot;, &quot;SSP3 2050&quot;, &quot;SSP3 2085&quot;, &quot;SSP5 2050&quot;, &quot;SSP5 2085&quot;), values=c(&quot;black&quot;, alpha(&quot;light green&quot;,0.4), alpha(&quot;dark green&quot;,0.4), alpha(&quot;coral&quot;,0.4), alpha(&quot;dark red&quot;,0.4), alpha(&quot;yellow&quot;,0.4), alpha(&quot;orange&quot;,0.4), alpha(&quot;light blue&quot;,0.4), alpha(&quot;dark blue&quot;,0.4))) + theme_bw(base_size = 15) This is now a pretty good coverage for all months, with the possible exception of October, which wasn’t covered by our experiments. If we succeed in producing a model that performs satisfactorily under all conditions covered by the Past_combined scenarios here, we could confidently expect it to produce accurate forecasts of future phenology. This would then open the door to follow-on studies, e.g. on future frost risk. But how do we develop a phenology model and parameterize it with observed phenology? Let’s see if we can find the answer in the next chapter on The PhenoFlex model. 29.4 One last thought on model validity The example of phenology models is fairly straightforward, because we expect phenology to be almost exclusively dependent on temperature. Many other models depend on more factors that are difficult to keep track of. For example, crop models may only have been validated under a certain range of climatic conditions, with effective pest and disease control, for a particular set of crop varieties, for a selection of soils and for mechanized cultivation. Should we use such a model for smallholder systems under marginal soil and climate conditions, where farmers rely on manual cultivation methods? Probably not… (yet this is widely done) Exercises on making valid tree phenology models Please document all results of the following assignments in your learning logbook. Explain the difference between output validation and process validation. Explain what a validity domain is and why it is important to consider this whenever we want to use our model to forecast something. What is validation for purpose? How can we ensure that our model is suitable for the predictions we want to make? "],["phenoflex.html", "Chapter 30 The PhenoFlex model Learning goals for this lesson 30.1 Ingredients of this lesson 30.2 Towards credible phenology models 30.3 The PhenoFlex framework 30.4 Running PhenoFlex 30.5 Parameterizing PhenoFlex 30.6 Conclusions on PhenoFlex Exercises on making valid tree phenology models", " Chapter 30 The PhenoFlex model Learning goals for this lesson Get to know the PhenoFlex modeling framework Learn how to run PhenoFlex Learn how to parameterize PhenoFlex based on spring phenology data 30.1 Ingredients of this lesson Long-term temperature data for Klein-Altendorf is available for download here again - save this in the data folder if it’s not there already: Download weather data for Campus Klein Altendorf (1958-2019) The ‘Alexander Lucas’ pear dataset from Klein-Altendorf, which we’ll fit the PhenoFlex model for, is available here for download again - save this in the data folder if it’s not there already: Download bloom data for Alexander Lucas pears (1958-2019) And here’s all the code for this lesson as one R script: R script for this lesson 30.2 Towards credible phenology models So far, all phenology modeling frameworks that I’m aware of are based on the rather broad concepts of chill and heat accumulation (or only heat accumulation), without including much detail on tree physiology. In the long run, a process-based model that incorporates robust biological knowledge on what happens in trees during dormancy would be desirable. We’ve explored this objective a bit, and we still have it in mind for future model development, but it doesn’t seem like such a model is within easy reach at the moment. Even with the tools that have been used for phenology modeling so far, there is considerable scope for improving phenology models. As I mentioned a few times already, the Dynamic Model is currently the front-runner among available chill models - but we’re not even using it as intended by the developers. This model was produced for peaches grown under experimental conditions in Israel, and the authors explicitly recommended re-calibrating it before use on other species (and possibly in other locations). This has almost never been done. I’m not aware of any calls for re-calibrating the most commonly used heat model, the Growing Degree Hours Model, but also there, we really have no good reason to believe that all trees respond in the same way as the peaches in Utah that were used in making this model. What also remains largely unaddressed in existing phenology modeling frameworks is the possibility that trees can, to some extent, compensate insufficient chill accumulation by additional heat. The ‘Overlap model’ (Pope et al., 2014) does this to some extent, but it has not tackled the two other issues mentioned above. 30.3 The PhenoFlex framework PhenoFlex (Luedeling et al., 2021) is a new modeling framework developed in a collaboration between my working group and Prof. Carsten Urbach, from the Helmholtz-Institut für Strahlen- und Kernphysik. In some way, we tried following the footsteps of Dr. Amnon Erez’ group in Israel, where the Dynamic Model was developed. Amnon also found a physicist to collaborate with, Dr. Svetlana Fishman, who contributed most of the maths to that project. Working across disciplines often comes with a lot of explaining of disciplinary basics (in all directions), and it often involves some misunderstandings, but the outcomes can be quite rewarding! We could never have developed the PhenoFlex model on our own, and Carsten would never have thought of applying his skills to such a problem. A classic win-win situation! So here’s what this model includes: Schematic overview of the PhenoFlex modeling framework We’re making use of the basic structure of the Dynamic Model for chill accumulation and the structure of the Growing Degree Hours concept for forcing. The transition between these two dormancy phases is modeled via a sigmoidal curve that translates accumulated chill into heat effectiveness. Below a certain critical chill accumulation, heat doesn’t accumulate at all. Past this threshold, heat gradually gets more effective, until it reaches full effectiveness. The source code of the PhenoFlex model is now written in C++, because that apparently allows the code to run faster. We can still run it in R, but to actually see the code, we need to look into the C++ source file. We’ll skip this here, because things get a bit more technical there than we need to be here. Let’s rather look at how this model can be run. 30.4 Running PhenoFlex chillR now contains the function PhenoFlex. The default parameters in this function allow us to run the model. Of course, we should first find a plausible set of parameters, before we use it for actual phenology predictions. But let’s first see how the model can be run. I’ll use an hourly temperature dataset derived from our weather data for Klein-Altendorf to demonstrate this. library(chillR) library(ggplot2) CKA_weather &lt;- read_tab(&quot;data/TMaxTMin1958-2019_patched.csv&quot;) hourtemps &lt;- stack_hourly_temps(CKA_weather, latitude = 50.6) We’ll set a critical chilling requirement yc and a heat requirement zc and leave all the other parameters as they are in the default model. The way this model is run is that we first generate a dataset iSeason that contains separate data for each season (the mrange parameter indicates the start and end months of the season). We can then apply the PhenoFlex framework directly, using the temperature column of our dataset. I first selected only the data for a possible season of interest (2009) for clarity. yc &lt;- 40 zc &lt;- 190 iSeason &lt;- genSeason(hourtemps, mrange = c(8, 6), years = c(2009)) season_data &lt;- hourtemps$hourtemps[iSeason[[1]],] res &lt;- PhenoFlex(temp = season_data$Temp, times = c(1: length(season_data$Temp)), zc = zc, stopatzc = TRUE, yc = yc, basic_output = FALSE) The res object now contains a lot of information, including daily values for all the variables that are tracked throughout the season (x, y, z and xs). In this notation, x is the precursor to the dormancy-breaking factor (in the Dynamic Model), y is the dormancy-breaking factor (a.k.a. Chill Portion, in the Dynamic Model), z is heat accumulation (according to the Growing Degree Hours model) and xs is the ratio of the formation to the destruction rate of x (again for the Dynamic Model). Finally, the single number res$bloomindex is the date of bloom (or whatever this particular version of the model predicts). This date is given as the number of the hour in the seasonal temperature dataset that corresponds to bloom. We can convert it by typing season_data$DATE[res$bloomindex]. In this case, that date is 15-04-09. We can look in detail at how the various variables change over time by examining the other output elements, e.g. the accumulation of chill (y) and heat (z) over time: DBreakDay &lt;- res$bloomindex seasontemps &lt;- hourtemps$hourtemps[iSeason[[1]],] seasontemps[,&quot;x&quot;] &lt;- res$x seasontemps[,&quot;y&quot;] &lt;- res$y seasontemps[,&quot;z&quot;] &lt;- res$z seasontemps &lt;- add_date(seasontemps) CR_full &lt;- seasontemps$Date[which(seasontemps$y &gt;= yc)[1]] Bloom &lt;- seasontemps$Date[which(seasontemps$z &gt;= zc)[1]] chillplot &lt;- ggplot(data = seasontemps[1:DBreakDay,], aes(x = Date, y = y)) + geom_line(col = &quot;blue&quot;, lwd = 1.5) + theme_bw(base_size = 20) + geom_hline(yintercept = yc, lty = 2, col = &quot;blue&quot;, lwd = 1.2) + geom_vline(xintercept = CR_full, lty = 3, col = &quot;blue&quot;, lwd = 1.2) + ylab(&quot;Chill accumulation (y)&quot;) + labs(title = &quot;Chilling&quot;) + annotate(&quot;text&quot;, label = &quot;Chill req. (yc)&quot;, x = ISOdate(2008,10,01), y = yc*1.1, col = &quot;blue&quot;, size = 5) heatplot &lt;- ggplot(data = seasontemps[1:DBreakDay,], aes(x = Date, y = z)) + geom_line(col = &quot;red&quot;, lwd = 1.5) + theme_bw(base_size = 20) + scale_y_continuous(position = &quot;right&quot;) + geom_hline(yintercept = zc, lty = 2, col = &quot;red&quot;, lwd = 1.2) + geom_vline(xintercept = CR_full, lty = 3, col = &quot;blue&quot;, lwd = 1.2) + geom_vline(xintercept = Bloom, lty = 3, col = &quot;red&quot;, lwd = 1.2) + ylab(&quot;Heat accumulation (z)&quot;) + labs(title = &quot;Forcing&quot;) + annotate(&quot;text&quot;, label = &quot;Heat req. (zc)&quot;, x = ISOdate(2008,10,01), y = zc*0.95, col = &quot;red&quot;, size = 5) library(patchwork) chillplot + heatplot The dotted lines here show the dates of fulfillment for the critical chill requirement (blue) and the heat requirement (red). You can see that heat accumulation (right plot) starts to rise slowly after the critical chill requirement has been fulfilled and only really takes off some time after that. This is partly explained by temperatures being pretty low during this time, but it may also be related to the gradual phasing in of heat effectiveness. Now let’s formulate this as a loop, so we can easily get predictions for multiple seasons. I’ll only output the bloom dates now, rather than the full details. yc &lt;- 40 zc &lt;- 190 seasons &lt;- 1959:2019 iSeason &lt;- genSeason(hourtemps, mrange = c(8, 6), years = seasons) for (sea in 1:length(seasons)) {season_data &lt;- hourtemps$hourtemps[iSeason[[sea]], ] res &lt;- PhenoFlex(temp = season_data$Temp, times = c(1: length(season_data$Temp)), zc = zc, stopatzc = TRUE, yc = yc, basic_output = FALSE) if(sea == 1) results &lt;- season_data$DATE[res$bloomindex] else results &lt;- c(results, season_data$DATE[res$bloomindex])} predictions &lt;- data.frame(Season = seasons, Prediction = results) predictions$Prediction &lt;- ISOdate(2001, substr(predictions$Prediction, 4, 5), substr(predictions$Prediction, 1, 2)) ggplot(data = predictions, aes(x = Season, y = Prediction)) + geom_smooth() + geom_point() + ylab(&quot;Predicted bloom date&quot;) + theme_bw(base_size = 15) So now we can use this model, but we still can’t adapt it to the particular tree cultivar we’re interested in. One of the benefits of the PhenoFlex framework is that it can be parameterized with observed phenology data. Well, this feature isn’t really unique to PhenoFlex, but so far the procedures used to achieve such parameterization have often remained somewhat obscure. Here, we’ll show how this can be done. 30.5 Parameterizing PhenoFlex The PhenoFlex model has 12 parameters: yc - chilling requirement; critical value of y, which defines the end of chill accumulation - default value: 40 zc - heat requirement; critical value of z, which defines the end of heat accumulation - default value: 190 s1 - slope parameter that determines the transition from the chill accumulation to the heat accumulation period in PhenoFlex - default value: 0.5 Tu - optimal temperature of the Growing Degree Hours (GDH) model - default value: 25 E0 - time-independent activation energy of forming the PDBF - default value: 3372.8 (as in the widely used version of the Dynamic Model) E1 - time-independent activation energy of destroying the PDBF - default value: 9900.3 (as in the widely used version of the Dynamic Model) A0 - amplitude of the (hypothetical) process involved in forming the precursor to the dormancy-breaking factor in the Dynamic Model - default value: 6319.5 (as in the widely used version of the Dynamic Model) A1 - amplitude of the (hypothetical) process involved in destroying the precursor to the dormancy-breaking factor (PDBF) in the Dynamic Model - default value: 5.939917e+13 (as in the widely used version of the Dynamic Model) Tf - transition temperature parameter of the sigmoidal function in the Dynamic Model, involved in converting PDBF to Chill Portions - default value: 4 Tc - upper threshold in the GDH model - default value: 36 Tb - base temperature of the GDH model - default value: 4 slope - slope parameter of the sigmoidal function in the Dynamic Model, which determines what fraction of the PDBF is converted to a Chill Portion - default value: 1.6 Fitting a model with so many parameters and with a somewhat complex structure isn’t trivial. There is no analytical solution that would allow us to unambiguously compute the ‘correct’ values. In such situations, we can use empirical solving procedures to determine suitable parameter sets. I’m not a big expert on such solvers, but let me tell you how I understand them. Basically, you start with a set of initial estimates for all parameters. You can also set plausible ranges for all the parameters that the final solution should be within. The solver then uses these initial parameters to predict outcomes. Based on the errors it encounters, it then adjusts these parameters in certain ways until it identifies a parameter set that delivers predictions with reasonable accuracy. In using solvers, we usually can’t be sure that we’ve actually found the ideal parameter set, because there are many paths the solver can take through the parameter space, and there may be multiple points where the residuals (the prediction errors) reach local minima. This is why it is common to run a solver multiple times with differing sets of initial values, which can sometimes lead to rather different results. Compared to a simple regression model, this process may seem a bit messy, but such empirical procedures are very commonly applied in many fields of science. The solving process we use within chillR is called Simulated Annealing. If you’re mathematically inclined, check out the Wikipedia link. It’s a pretty cool procedure that’s commonly used for similar challenges. We’ll use our Alexander Lucas dataset to fit the PhenoFlex model. Alex_first &lt;- read_tab(&quot;data/Alexander_Lucas_bloom_1958_2019.csv&quot;) %&gt;% select(Pheno_year, First_bloom) %&gt;% mutate(Year = as.numeric(substr(First_bloom, 1, 4)), Month = as.numeric(substr(First_bloom, 5, 6)), Day = as.numeric(substr(First_bloom, 7, 8))) %&gt;% make_JDay() %&gt;% select(Pheno_year, JDay) %&gt;% rename(Year = Pheno_year, pheno = JDay) hourtemps &lt;- read_tab(&quot;data/TMaxTMin1958-2019_patched.csv&quot;) %&gt;% stack_hourly_temps(latitude = 50.6) We need to start the model with a set of initial parameters, as well as lower and upper bounds for all parameters. Most of these are quite difficult to fit in this case, because they don’t correspond to a real-life process we can easily make estimates for. The Dynamic Model in particular contains parameters for the activation energies and amplitudes of two temperature-dependent processes that produce and destroy the precursor to chill. These considerations are based on a hypothetical process whose nature we don’t understand. This makes it pretty hard to come up with reasonable numbers here. The job isn’t made much easier by looking at previous estimates, which feature a wide range of values for these parameters. I currently don’t have very good guidance for estimating many of the values. Other parameters, such as the sensitive temperatures in the Growing Degree Hours model, can be estimated with greater confidence of course. Hopefully, we’ll come up with a parameter selection strategy at some point. In the meantime, let’s use this set: # here&#39;s the order of the parameters (from the helpfile of the # PhenoFlex_GDHwrapper function) # yc, zc, s1, Tu, E0, E1, A0, A1, Tf, Tc, Tb, slope par &lt;- c(40, 190, 0.5, 25, 3372.8, 9900.3, 6319.5, 5.939917e13, 4, 36, 4, 1.60) upper &lt;- c(41, 200, 1.0, 30, 4000.0, 10000.0, 7000.0, 6.e13, 10, 40, 10, 50.00) lower &lt;- c(38, 180, 0.1, 0 , 3000.0, 9000.0, 6000.0, 5.e13, 0, 0, 0, 0.05) To run the fitting procedure, we have to first generate a list of seasons and then feed this into the actual fitter function phenologyFitter. Note that the model function in the fitter isn’t PhenoFlex itself, but a wrapper function that just requires the arguments x (the temperature data) and par, which contains the whole set of parameters. This format is needed to run the fitter. Running such a solver can take a long time, because the algorithm should run through 1000 or more iterations before settling on the final parameter set. This is controlled with the maxit parameter. I’ve run the procedure with 1000 iterations and saved the parameters, so I don’t have to do it again now. If you want to use the resulting parameter set for some real purpose, I’d recommend investing the time to wait for the results. If you’re just doing this for the fun of it, you can reduce maxit, maybe to 100. SeasonList &lt;- genSeasonList(hourtemps$hourtemps, mrange = c(8, 6), years = c(1959:2019)) Fit_res &lt;- phenologyFitter(par.guess = par, modelfn = PhenoFlex_GDHwrapper, bloomJDays = Alex_first$pheno[which(Alex_first$Year &gt; 1958)], SeasonList = SeasonList, lower = lower, upper = upper, control = list(smooth = FALSE, verbose = FALSE, maxit = 1000, nb.stop.improvement = 5)) Alex_par &lt;- Fit_res$par write.csv(Alex_par, &quot;data/PhenoFlex_parameters_Alexander_Lucas.csv&quot;) Now we may want to visualize model quality. I only saved the model parameters so far (and I don’t want to repeat these 1000 iterations), so we may have to reproduce the predictions for this. I’ll then calculate the RMSEP, the mean error and the mean absolute error, which are useful measures of model accuracy, and I’ll make a couple of plots. Alex_par &lt;- read_tab(&quot;data/PhenoFlex_parameters_Alexander_Lucas.csv&quot;)[,2] SeasonList &lt;- genSeasonList(hourtemps$hourtemps, mrange = c(8, 6), years = c(1959:2019)) Alex_PhenoFlex_predictions &lt;- Alex_first[which(Alex_first$Year &gt; 1958),] for(y in 1:length(Alex_PhenoFlex_predictions$Year)) Alex_PhenoFlex_predictions$predicted[y] &lt;- PhenoFlex_GDHwrapper(SeasonList[[y]], Alex_par) Alex_PhenoFlex_predictions$Error &lt;- Alex_PhenoFlex_predictions$predicted - Alex_PhenoFlex_predictions$pheno RMSEP(Alex_PhenoFlex_predictions$predicted, Alex_PhenoFlex_predictions$pheno) ## [1] 4.813428 mean(Alex_PhenoFlex_predictions$Error) ## [1] 0.9077869 mean(abs(Alex_PhenoFlex_predictions$Error)) ## [1] 3.778005 ggplot(Alex_PhenoFlex_predictions, aes(x = pheno, y = predicted)) + geom_point() + geom_abline(intercept = 0, slope = 1) + theme_bw(base_size = 15) + xlab(&quot;Observed bloom date (Day of the year)&quot;) + ylab(&quot;Predicted bloom date (Day of the year)&quot;) + ggtitle(&quot;Predicted vs. observed bloom dates&quot;) ggplot(Alex_PhenoFlex_predictions, aes(Error)) + geom_histogram() + ggtitle(&quot;Distribution of prediction errors&quot;) The mean error of the predictions is 0.91, the mean absolute error is 3.8 and the RMSEP is 4.8. All of these are very low, indicating very good performance of the PhenoFlex model. Strictly speaking, we should not validate model performance in this way. We should be using a certain set of observations to calibrate the model and another set to validate it. Ideally, we’d find a set of observations that allow us to validate for purpose, i.e., for a climate change study, under particularly warm conditions. We’re not going to do this here, but note that this should ideally be done. I’ll admit here that in running the solver, I didn’t allow for a lot of flexibility in terms of the Dynamic Model parameters. This constrained the temperature response during endodormancy to a shape that is relatively close to that in the the original version of the model. Allowing for much more wiggle room there can lead to quite unrealistic results that do not seem plausible. As I mentioned before, deciding on the right set of initial values and setting appropriate boundaries for the model parameters can be critical, but I don’t currently have a lot of good advice on how to select all these values. We should also now estimate the errors that are involved in our predictions. This can be achieved with the bootstrap.phenologyFit function in chillR. If you want to learn more about this, please refer to the chillR vignette on the PhenoFlex model. 30.6 Conclusions on PhenoFlex The PhenoFlex framework performed quite convincingly in predicting bloom dates of ‘Alexander Lucas’ pears in Klein-Altendorf. Observed bloom dates were reproduced quite reliably, with prediction errors more or less normally distributed. Prediction errors were homogeneously distributed across the whole spectrum of bloom dates, indicating that the model is equally reliable in predicting early bloom dates as in predicting late flowering. These characteristics bode well for use of this modeling framework to predict phenology even under future temperature conditions. All the considerations about validity domains etc. still hold, but I’d be a lot more confident in this model than in most previous prediction attempts, where models often did not perform as well, and also fell short of incorporating the state of knowledge on temperature responses during dormancy. Exercises on making valid tree phenology models Please document all results of the following assignments in your learning logbook. Parameterize the PhenoFlex model for `Roter Boskoop’ apples. Produce plots of predicted vs. observed bloom dates and distribution of prediction errors. Compute the model performance metrics RMSEP, mean error and mean absolute error. References Luedeling E, Schiffers K, Fohrmann T &amp; Urbach C. (2021). Pheno-flex - an integrated model to predict spring phenology in temperate fruit trees. Agricultural and Forest Meteorology, 307, 108491. doi: 10.1016/j.agrformet.2021.108491 Pope K, Da Silva D, Brown P &amp; DeJong T. (2014). A biologically based approach to modeling spring phenology in temperate deciduous trees. Agricultural and Forest Meteorology, 198, 15–23. doi: 10.1016/j.agrformet.2014.07.009 "],["phenoflex2.html", "Chapter 31 The PhenoFlex model - a second look Learning goals for this lesson 31.1 Some basic diagnostics for our PhenoFlex fit 31.2 Temperature response of the PhenoFlex components 31.3 Overall impression 31.4 Caveats and assumptions 31.5 Outlook Exercises on basic PhenoFlex diagnostics", " Chapter 31 The PhenoFlex model - a second look Learning goals for this lesson Explore the chill and heat responses of our newly parameterized PhenoFlex model for ‘Alexander Lucas’ pears Be able to produce temperature response plots for such a model 31.1 Some basic diagnostics for our PhenoFlex fit Once you’ve come up with a new model, it’s easy to get so excited about it that you forget to look for possible weaknesses. As the saying goes: “Statisticians, like artists, have the bad habit of falling in love with their models” — George Box This is not only true for statisticians, but for any kind of modelers. It may actually be a bigger problem for modelers without proper statistics training, who may lack sensitivity for all the things that can go wrong. So let’s examine the PhenoFlex framework a bit, specifically focusing on the parameter set we determined. With a few quick helper functions, we can examine the temperature response curves during chilling and forcing that are described by the fitted parameters. library(ggplot2) library(tidyr) library(chillR) apply_const_temp &lt;- function(temp, A0, A1, E0, E1, Tf, slope, portions = 1200, deg_celsius = TRUE) { temp_vector &lt;- rep(temp, times = portions) res &lt;- chillR::DynModel_driver(temp = temp_vector, A0 = A0, A1 = A1, E0 = E0, E1 = E1, Tf = Tf, slope = slope, deg_celsius = deg_celsius) return(res$y[length(res$y)]) } gen_bell &lt;- function(par, temp_values = seq(-5, 20, 0.1)) { E0 &lt;- par[5] E1 &lt;- par[6] A0 &lt;- par[7] A1 &lt;- par[8] Tf &lt;- par[9] slope &lt;- par[12] y &lt;- c() for(i in seq_along(temp_values)) { y[i] &lt;- apply_const_temp(temp = temp_values[i], A0 = A0, A1 = A1, E0 = E0, E1 = E1, Tf = Tf, slope = slope) } return(invisible(y)) } GDH_response &lt;- function(T, par) {Tb &lt;- par[11] Tu &lt;- par[4] Tc &lt;- par[10] GDH_weight &lt;- rep(0, length(T)) GDH_weight[which(T &gt;= Tb &amp; T &lt;= Tu)] &lt;- 1/2 * (1 + cos(pi + pi * (T[which(T &gt;= Tb &amp; T &lt;= Tu)] - Tb)/(Tu - Tb))) GDH_weight[which(T &gt; Tu &amp; T &lt;= Tc)] &lt;- (1 + cos(pi/2 + pi/2 * (T[which(T &gt; Tu &amp; T &lt;= Tc)] -Tu)/(Tc - Tu))) return(GDH_weight) } The gen_bell function here produces the chill effectiveness curve, and the GDH_response function illustrates heat effectiveness. Now let’s apply these functions to the parameter set we determined for our ‘Alexander Lucas’ pears. I’ll explore the temperature response in the range from -5 to 30°C, at a resolution of 0.1°C. I’ll first load the parameter set we saved in the last chapter on The PhenoFlex model. Alex_par &lt;- read_tab(&quot;data/PhenoFlex_parameters_Alexander_Lucas.csv&quot;)[,2] temp_values = seq(-5, 30, 0.1) temp_response &lt;- data.frame(Temperature = temp_values, Chill_response = gen_bell(Alex_par, temp_values), Heat_response = GDH_response(temp_values, Alex_par)) pivoted_response &lt;- pivot_longer(temp_response, c(Chill_response, Heat_response)) ggplot(pivoted_response, aes(x = Temperature, y = value)) + geom_line(linewidth = 2, aes(col = name)) + ylab(&quot;Temperature response (arbitrary units)&quot;) + xlab(&quot;Temperature (°C)&quot;) + facet_wrap(vars(name), scales = &quot;free&quot;, labeller = labeller(name = c(Chill_response = c(&quot;Chill response&quot;), Heat_response = c(&quot;Heat response&quot;)))) + scale_color_manual(values = c(&quot;Chill_response&quot; = &quot;blue&quot;, &quot;Heat_response&quot; = &quot;red&quot;)) + theme_bw(base_size = 15) + theme(legend.position = &quot;none&quot;) These response curves seem pretty sensible to me. During chilling, we see peak effectiveness around 2-3°C, and a rapid decline in chill effectiveness around 6°C. Note that this response curve assumes constant temperatures over extended periods, which is not something we’d usually see in an orchard. The heat response also looks quite plausible. I wouldn’t place large bets on the accuracy of the final drop-off point, however, because temperatures around 30°C have probably never (or at least very rarely) been observed during dormancy. 31.2 Temperature response of the PhenoFlex components When we evaluated the temperature response of the Dynamic Model in chapter Why PLS doesn’t always work, we didn’t just work with assumptions of constant temperatures, but we tested temperature responses for days with particular combinations of daily minimum and maximum temperatures. Let’s also do this here. PhenoFlex works a bit differently from the models we called earlier, so I’m not using the function we made in the chapter on Why PLS doesn’t always work here. The code is largely similar though: latitude &lt;- 50.6 month_range &lt;- c(10, 11, 12, 1, 2, 3) Tmins = c(-20:20) Tmaxs = c(-15:30) mins &lt;- NA maxs &lt;- NA chill_eff &lt;- NA heat_eff &lt;- NA month &lt;- NA simulation_par &lt;- Alex_par for(mon in month_range) {days_month &lt;- as.numeric(difftime(ISOdate(2002, mon+1, 1), ISOdate(2002, mon, 1))) if(mon == 12) days_month &lt;- 31 weather &lt;- make_all_day_table(data.frame(Year = c(2002, 2002), Month = c(mon, mon), Day = c(1, days_month), Tmin = c(0, 0), Tmax = c(0, 0))) for(tmin in Tmins) for(tmax in Tmaxs) if(tmax &gt;= tmin) { hourtemps &lt;- weather %&gt;% mutate(Tmin = tmin, Tmax = tmax) %&gt;% stack_hourly_temps(latitude = latitude) %&gt;% pluck(&quot;hourtemps&quot;, &quot;Temp&quot;) chill_eff &lt;- c(chill_eff, PhenoFlex(temp = hourtemps, times = c(1: length(hourtemps)), A0 = simulation_par[7], A1 = simulation_par[8], E0 = simulation_par[5], E1 = simulation_par[6], Tf = simulation_par[9], slope = simulation_par[12], deg_celsius = TRUE, basic_output = FALSE)$y[length(hourtemps)] / (length(hourtemps) / 24)) heat_eff &lt;- c(heat_eff, cumsum(GDH_response(hourtemps, simulation_par))[length(hourtemps)] / (length(hourtemps) / 24)) mins &lt;- c(mins, tmin) maxs &lt;- c(maxs, tmax) month &lt;- c(month, mon) } } results &lt;- data.frame(Month = month, Tmin = mins, Tmax = maxs, Chill_eff = chill_eff, Heat_eff = heat_eff) %&gt;% filter(!is.na(Month)) write.csv(results, &quot;data/model_sensitivity_PhenoFlex.csv&quot;) For the plotting part, we can use the Chill_sensitivity_temps function we produced in the Why PLS doesn’t always work chapter. With this, we’re now ready to make the temperature response plots: Model_sensitivities_PhenoFlex &lt;- read.csv(&quot;data/model_sensitivity_PhenoFlex.csv&quot;) CKA_weather &lt;- read_tab(&quot;data/TMaxTMin1958-2019_patched.csv&quot;) Chill_sensitivity_temps(Model_sensitivities_PhenoFlex, CKA_weather, temp_model = &quot;Chill_eff&quot;, month_range = c(10, 11, 12, 1, 2, 3), Tmins = c(-20:20), Tmaxs = c(-15:30), legend_label = &quot;Chill per day \\n(arbitrary)&quot;) + ggtitle(&quot;PhenoFlex chill efficiency (&#39;Alexander Lucas&#39;)&quot;) If you compare the chill response plot for this version of the PhenoFlex model with the response plot for the ordinary Dynamic Model (shown in Why PLS doesn’t always work), you’ll notice that the response looks generally similar, but the actual ‘chill per day’ values are somewhat different. Overall, it seems like the effective temperature range is quite well aligned with what’s shown in the constant-temperature response plot above. Chill_sensitivity_temps(Model_sensitivities_PhenoFlex, CKA_weather, temp_model = &quot;Heat_eff&quot;, month_range = c(10, 11, 12, 1, 2, 3), Tmins = c(-20:20), Tmaxs = c(-15:30), legend_label = &quot;Heat per day \\n(arbitrary)&quot;) + ggtitle(&quot;PhenoFlex heat efficiency (&#39;Alexander Lucas&#39;)&quot;) We can also look at the heat response plot, which looks very similar to that of the ordinary Growing Degree Hours model. This is not surprising, since the constant-temperature plot above only indicated a drop-off in heat effectiveness at very high temperatures that don’t occur in Klein-Altendorf during the winter months. 31.3 Overall impression Deciding whether this cultivar-specific parameterization of the PhenoFlex framework is actually accurate remains difficult. We’ve seen that the model was pretty good at predicting observed values, but this is only one of the criteria we should be using to judge model quality. We also know that, in principle, the model describes the best of our knowledge on how tree phenology responds to temperature during endo- and ecodormancy (because this knowledge was used in building the model). The PhenoFlex model has 12 parameters, and we used it to predict 61 years of phenology data, with pretty good agreement between observed and predicted values. Given the much greater number of observations compared to parameters, it is unlikely that such a good fit is a statistical artefact. We do have to concede, however, that using a solver to fit parameters runs the risk of incurring problems that are similar to what can result from p-hacking. The only way to guard against random results that provide good fits is to take a good look at our results, evaluate them in light of our expectations and decide if we can consider them plausible. In this case, I see good reasons for making this call. The chill efficiency curve points to an effective range of chilling conditions that is close to what most researchers and growers have considered effective in the past. Overall, I’m pretty happy with the performance! 31.4 Caveats and assumptions I want to repeat here that the parameter ranges we allowed for the model fit were quite restricted and may not have allowed the model to roam freely. Even though the effective ranges for chill and heat accumulation differed considerably from the original Dynamic Model, we have to acknowledge that this may have influenced the results. We still have a few assumptions in this model. One such assumption concerns the start date of chill accumulation. We don’t set this explicitly, but we assume chill accumulation begins whenever the first chill starts to accrue. Another assumption obviously concerns the general nature of chill and heat accumulation dynamics, which we expect to follow the patterns dictated by the Dynamic and Growing Degree Hours models. Finally, we assume both of these processes to follow the same rules all throughout the respective seasons. I’m not aware of anyone having challenged (or acknowledged) this assumption in the past, but it is still worth stating it here. A last caveat concerns the chill and heat units the model produces. Since the entire temperature response curves are fitted, the numbers of chill and heat units can’t be compared between analyses, crops or locations. This is clearly suboptimal, because it greatly complicates the production of chill or heat maps that aren’t specific to a particular cultivar. 31.5 Outlook There’s a lot that still needs be done with this model. It needs to be tested, we need better guidance for parameter choice, we should think of ways to standardize the chill and heat units, and we should use it in lots of contexts, across climate zones. We should also explore the usefulness of the PhenoFlex framework in the context of future phenology projections, frost risk assessments etc. There is no shortage of things to do… wanna help? Exercises on basic PhenoFlex diagnostics Please document all results of the following assignments in your learning logbook. Make chill and heat response plots for the ‘Roter Boskoop’ PhenoFlex model for the location you did the earlier analyses for. "],["phenoflex3.html", "Chapter 32 Can we improve the performance of PhenoFlex? Learning goals for this lesson 32.1 The motivation 32.2 Using experimental phenology data for assessing the performance of PhenoFlex 32.3 Validation 32.4 Conclusions Exercises on improving the performance of PhenoFlex", " Chapter 32 Can we improve the performance of PhenoFlex? Learning goals for this lesson Parameterize the PhenoFlex model with experimental data Assess the impact of marginal seasons on the predictive performance of PhenoFlex 32.1 The motivation As we have seen during the chapters The PhenoFlex model and The PhenoFlex model - a second look, the PhenoFlex model is rather recent and needs to be validated under different conditions. In addition, some results obtained in the original publication (Luedeling et al., 2021) suggest temperature responses during chill accumulation that seem implausible (see below, in particular the chill response for PhenoFlexfitted for Apple ‘Boskoop’). Chill and heat response plots for two versions of the PhenoFlex model. Note in the figure above the chill response for apple cv. “Boskoop” for temperatures above 25 °C. As we have learned in previous chapters, such high temperature may even be counterproductive for chill accumulation. This response estimated by PhenoFlex may suggest that conditions used for calibrating the modelling framework didn’t vary widely enough during the endo-dormancy period and point out the need for more relevant temperature conditions in the calibration data set to obtain an appropriate set of parameters. 32.2 Using experimental phenology data for assessing the performance of PhenoFlex In our lab, we had the idea of using the data generated in the tree-moving experiment and analyzed in the chapter on Experimentally enhanced PLS to calibrate the PhenoFlex model. This chapter presents an overview of the process and the main results. For more details, refer to the published version of the analysis (Fernandez et al., 2022) (Link). We will first load the weather and phenology data from the data folder and apply some cleaning procedures to comply with PhenoFlex format. If you don’t have the files yet, please first download them and save them in the data folder. Download weather data from the experiment Download phenology data from the experiment library(chillR) library(tidyverse) # Load the data from the folder data &lt;- read_tab(&quot;data/final_weather_data_S1_S2_apple_hourly.csv&quot;) # Generate a new column (Year_2) to simulate the year and comply with the format of PhenoFlex functions data[&quot;Year_2&quot;] &lt;- data$Treatment + data$Year # Since this experiment was conducted during two consecutive seasons, the next step will fix a small continuity issue # generated during the season 2 data[data$Treatment &gt;= 34, &quot;Year_2&quot;] &lt;- data[data$Treatment &gt;= 34, &quot;Year_2&quot;] - 1 # For further compatibility, I will now select the columns needed and will drop &quot;Year&quot; (the original one) data &lt;- data[c(&quot;YEARMODA&quot;, &quot;Year_2&quot;, &quot;Month&quot;, &quot;Day&quot;, &quot;Hour&quot;, &quot;JDay&quot;, &quot;Temp&quot;)] # To replace the missing &quot;Year&quot; column, I will now change the name of the column colnames(data)[which(colnames(data) == &quot;Year_2&quot;)] &lt;- &quot;Year&quot; # Import the phenology data from the repository pheno &lt;- read_tab(&quot;data/final_bio_data_S1_S2_apple.csv&quot;) # Remove troubling treatments pheno &lt;- pheno[!(pheno$Treatment %in% c(36, 3, 23, 24, 17, 18, 61)), c(&quot;Treatment&quot;, &quot;pheno&quot;)] pheno[&quot;Treatment&quot;] &lt;- pheno$Treatment + 2019 colnames(pheno) &lt;- c(&quot;Year&quot;, &quot;pheno&quot;) We can now take a look at the format of both datasets with the help of the head() function to see how they look: Weather records show the hourly temperature trees were exposed to during the experiment. head(data) YEARMODA Year Month Day Hour JDay Temp 20180606 2019 6 6 0 157 13.60700 20180606 2019 6 6 1 157 12.49315 20180606 2019 6 6 2 157 11.76103 20180606 2019 6 6 3 157 11.11030 20180606 2019 6 6 4 157 10.45488 20180606 2019 6 6 5 157 11.95780 Phenology data show the date of full bloom (in day of the year), which was recorded as the moment we observed 50% of flowers open with first petals falling according to the BBCH scale. head(pheno) Year pheno 2020 115 2021 98 2023 64 2024 49 2025 64 2026 50 In both datesets, you can see the column treatment representing a “fake” year or season that corresponds to the actual treatment used in the experiment. For comparison, we developed two versions of the analysis for calibrating the PhenoFlex model. In version 1 (hereafter PhenoFlex_marginal), we included all available experimental seasons, including five seasons that may have been marginal in terms of temperature to overcome the dormancy of apple trees. In version 2 (hereafter PhenoFlex_normal), we removed these seasons from the calibration data set. Experimental seasons used in the different versions of the calibration procedure. The histogram on the left shows the distribution of mean temperature among experimental seasons As you can see in the figure above, we identified these five marginal seasons as a small cluster at the upper limit of the distribution after sorting the seasons according to the mean temperature experienced by the trees between the beginning of the experiment and the moment we recorded full bloom. In the following chunk we are just creating different datasets for the two versions of the analysis. The treatments represented by the years c(2032, 2061, 2065, 2077, 2081) were identified as marginal seasons and removed from the calibration data set in PhenoFlex_normal. pheno_marginal &lt;- pheno pheno_normal &lt;- pheno[!(pheno$Year %in% c(2032, 2061, 2065, 2077, 2081)), ] We can now do the same for the weather data by defining two vectors containing the seasons we want to use for model calibration. We will randomly select 40 seasons for calibration in both versions of the analysis, leaving the remaining 14 experimental seasons for validation. # Define a vector of calibration and validation seasons. Marginal includes # the marginal seasons calibration_seasons &lt;- sort(sample(pheno_normal$Year, 40, replace = FALSE)) calibration_seasons_marginal &lt;- sort(c(sample(calibration_seasons, 35, replace = FALSE), pheno_marginal$Year[which(!(pheno_marginal$Year %in% pheno_normal$Year))])) calibration_seasons_normal &lt;- calibration_seasons # Common validation seasons validation_seasons &lt;- sort(pheno_normal[!(pheno_normal$Year %in% calibration_seasons), &quot;Year&quot;]) # Define the list of seasons (weather data) season_list_marginal &lt;- genSeasonList(data, mrange = c(9, 7), years = calibration_seasons_marginal) season_list_normal &lt;- genSeasonList(data, mrange = c(9, 7), years = calibration_seasons_normal) Now we can apply what we learned in the chapter The PhenoFlex model and fit the model parameters to data. Note that we start the fitting procedure with wide ranges (particularly for yc and zc) in order to let the model find the best estimates. # Set the initial parameters (wide ranges) # yc, zc, s1, Tu, E0, E1, A0, A1, Tf, Tc, Tb, slope lower &lt;- c(20, 100, 0.1, 0, 3000.0, 9000.0, 6000.0, 5.e13, 0, 0, 0, 0.05) par &lt;- c(40, 190, 0.5, 25, 3372.8, 9900.3, 6319.5, 5.939917e13, 4, 36, 4, 1.60) upper &lt;- c(80, 500, 1.0, 30, 4000.0, 10000.0, 7000.0, 6.e13, 10, 40, 10, 50.00) # Run the fitter pheno_fit_marginal &lt;- phenologyFitter(par.guess = par, modelfn = PhenoFlex_GDHwrapper, bloomJDays = pheno_marginal[pheno_marginal$Year %in% calibration_seasons_marginal, &quot;pheno&quot;], SeasonList = season_list_marginal, lower = lower, upper = upper, control = list(smooth = FALSE, verbose = FALSE, maxit = 100, nb.stop.improvement = 10)) # Same for version 2 pheno_fit_normal &lt;- phenologyFitter(par.guess = par, modelfn = PhenoFlex_GDHwrapper, bloomJDays = pheno_normal[pheno_normal$Year %in% calibration_seasons_normal, &quot;pheno&quot;], SeasonList = season_list_normal, lower = lower, upper = upper, control = list(smooth = FALSE, verbose = FALSE, maxit = 100, nb.stop.improvement = 10)) Note that we set the argument maxit in the control list to 100 to make the code run fast. For a real assessment, we should probably use greater values (e.g. 1,000). We are saving the results of the fitting (model parameters and predicted bloom dates) and reading them from the folder to save time in future analyses. write.csv(pheno_fit_marginal$par, &quot;data/PhenoFlex_marginal_params.csv&quot;, row.names = FALSE) write.csv(pheno_fit_normal$par, &quot;data/PhenoFlex_normal_params.csv&quot;, row.names = FALSE) write.csv(data.frame(pheno_marginal[pheno_marginal$Year %in% calibration_seasons_marginal, ], &quot;Predicted&quot; = pheno_fit_marginal$pbloomJDays), &quot;data/PhenoFlex_marginal_predicted_bloom.csv&quot;, row.names = FALSE) write.csv(data.frame(pheno_normal[pheno_normal$Year %in% calibration_seasons_normal, ], &quot;Predicted&quot; = pheno_fit_normal$pbloomJDays), &quot;data/PhenoFlex_normal_predicted_bloom.csv&quot;, row.names = FALSE) Let’s take a look at some results from the fitting procedure. We can obtain the predictions by the model using the fitted parameters and then estimate the prediction error. # Read the parameters params_marginal &lt;- read.csv(&quot;data/PhenoFlex_marginal_params.csv&quot;)[[1]] params_normal &lt;- read.csv(&quot;data/PhenoFlex_normal_params.csv&quot;)[[1]] # Generate a data set to collect the outputs of the fitting for the calibration data out_df_marginal &lt;- read.csv(&quot;data/PhenoFlex_marginal_predicted_bloom.csv&quot;) out_df_normal &lt;- read.csv(&quot;data/PhenoFlex_normal_predicted_bloom.csv&quot;) # Compute the error (observed - predicted) out_df_marginal[[&quot;Error&quot;]] &lt;- out_df_marginal$pheno - out_df_marginal$Predicted out_df_normal[[&quot;Error&quot;]] &lt;- out_df_normal$pheno - out_df_normal$Predicted We can now compute some model performance metrics based on the prediction error estimated above. This is not very relevant during the calibration procedure, but it can give us an idea on how the two PhenoFlex versions compare. calibration_metrics Metric PhenoFlex_marginal PhenoFlex_normal RMSEP 10.61386 3.837238 RPIQ 3.39179 10.163561 There is certainly room for improvement (especially considering that we only used 10 iterations), but the results give us a clear indication that calibrating the model with the marginal seasons reduced the performance of PhenoFlex. Let’s plot some results. out_df_all &lt;- bind_rows(&quot;PhenoFlex marginal&quot; = out_df_marginal, &quot;PhenoFlex normal&quot; = out_df_normal, .id = &quot;PhenoFlex version&quot;) # Plot the observed versus predicted values ggplot(out_df_all, aes(pheno, Predicted)) + geom_point() + geom_abline(intercept = 0, slope = 1) + labs(x = &quot;Observed&quot;) + facet_grid(~ `PhenoFlex version`) + theme_bw() We can see in the plot that the version including the marginal seasons shows a greater dispersion compared to the version excluding the marginal seasons in the calibration of the framework. 32.3 Validation We should probably now take a look at how well both versions can predict bloom dates for seasons that were not contained in the calibration data set. We need to extract the model parameters and use the function PhenoFlex_GDHwrapper() to complete this task. Remember, we are using a common set of seasons for validation of both the PhenoFlex_marginal and PhenoFlex_normal versions. # Generate a validation data set with phenology data valid_df_marginal &lt;- pheno_marginal[pheno_marginal$Year %in% validation_seasons, ] valid_df_normal &lt;- pheno_normal[pheno_normal$Year %in% validation_seasons, ] # Generate a list of seasons with weather data for the validation procedure valid_season_list &lt;- genSeasonList(data, mrange = c(9, 7), years = validation_seasons) # Estimate the bloom dates with PhenoFlexGDHwrapper for (i in 1 : nrow(valid_df_marginal)) { valid_df_marginal[i, &quot;Predicted&quot;] &lt;- PhenoFlex_GDHwrapper(valid_season_list[[i]], params_marginal) } # The same for the second version for (i in 1 : nrow(valid_df_normal)) { valid_df_normal[i, &quot;Predicted&quot;] &lt;- PhenoFlex_GDHwrapper(valid_season_list[[i]], params_normal) } # Compute the error (observed - predicted) valid_df_marginal[[&quot;Error&quot;]] &lt;- valid_df_marginal$pheno - valid_df_marginal$Predicted valid_df_normal[[&quot;Error&quot;]] &lt;- valid_df_normal$pheno - valid_df_normal$Predicted Since we already know the difference between the observed values and the values predicted by the model (i.e. the prediction error) in the validation data set, we can estimate some model performance metrics such as the RMSEP and the RPIQ. To this end, we can use the functions RMSEP() and RPIQ() from chillR. validation_metrics Metric PhenoFlex_marginal PhenoFlex_normal RMSEP 6.643169 4.246336 RPIQ 6.171753 9.655382 The results shown in the table above confirm the pattern we observed in the calibration procedure. The inclusion of the marginal seasons lowered the performance of PhenoFlex. But it is always nice to see the results in a more graphically way, right? So, let’s plot them! # Create a unique data set valid_df_all &lt;- bind_rows(&quot;PhenoFlex marginal&quot; = valid_df_marginal, &quot;PhenoFlex normal&quot; = valid_df_normal, .id = &quot;PhenoFlex version&quot;) # Plot the calibrated and validated ggplot(out_df_all, aes(pheno, Predicted, color = &quot;Calibration&quot;)) + geom_point() + geom_point(data = valid_df_all, aes(pheno, Predicted, color = &quot;Validation&quot;)) + scale_color_manual(values = c(&quot;cadetblue&quot;, &quot;firebrick&quot;)) + geom_abline(intercept = 0, slope = 1) + labs(x = &quot;Observed&quot;, color = &quot;Dataset&quot;) + facet_grid(~ `PhenoFlex version`) + theme_bw() Again, here we see that the red dots (representing the validation seasons) in PhenoFlex_marginal are more dispersed and placed at a greater distance from the line x = y compared to the red dots from the PhenoFlex_normal version. We will now take a look at the chill and heat response curves for both versions of the analysis. To this end, we will make use of the functions apply_const_temp(), gen_bell(), and GDH_response() that we created in the chapter The PhenoFlex model - a second look. We will load the functions again and will hide this process with the chunk options. # Create a data set with theoretical temperatures and heat and chill responses temp_response_marginal &lt;- data.frame(Temp = seq(-5, 60, 0.1), Chill_res = gen_bell(params_marginal, temp_values = seq(-5, 60, 0.1)), Heat_res = GDH_response(params_marginal, seq(-5, 60, 0.1)), Version = &quot;PhenoFlex marginal&quot;) temp_response_normal &lt;- data.frame(Temp = seq(-5, 60, 0.1), Chill_res = gen_bell(params_normal, temp_values = seq(-5, 60, 0.1)), Heat_res = GDH_response(params_normal, seq(-5, 60, 0.1)), Version = &quot;PhenoFlex normal&quot;) # Generate a single data set temp_response &lt;- bind_rows(temp_response_marginal, temp_response_normal) # Plotting ggplot(temp_response, aes(Temp)) + geom_line(aes(y = Chill_res, color = &quot;Chill&quot;)) + geom_line(aes(y = Heat_res * 25, color = &quot;Heat&quot;)) + scale_y_continuous(expand = expansion(mult = c(0.001, 0.01)), sec.axis = sec_axis(~ . / 25, name = &quot;Arbitrary heat units&quot;)) + scale_x_continuous(expand = expansion(mult = 0)) + scale_color_manual(values = c(&quot;blue4&quot;, &quot;firebrick&quot;)) + labs(x = &quot;Temperature (°C)&quot;, y = &quot;Arbitrary chill units&quot;, color = NULL) + facet_grid(Version ~ .) + theme_bw() + theme(legend.position = c(0.85, 0.85)) We see some differences in the chill response among versions, but similar heat curves. To some extent, PhenoFlex_normal emulates the chill response observed in the original chill model (i.e. the Dynamic model). Note that in PhenoFlex_marginal the accumulation of chill only starts at temperatures above 5 °C. Regarding the heat response, PhenoFlex_normal shows accumulation of heat with slightly higher temperatures than the curve shown for PhenoFlex_marginal. Since we used very few model iterations, however, these results are difficult to interpret. 32.4 Conclusions This was just an abbreviated version of the analysis we conducted, but it gives us some interesting insights on the potential limitations of the modelling framework. It seems possible that under extreme conditions, the process of dormancy breaking is modulated by mechanisms that are not considered in the PhenoFlex framework (or in any other frameworks that are currently available). To test this hypothesis, however, additional systematic studies would have to be conducted. Exercises on improving the performance of PhenoFlex Describe (briefly) in your own words: What was the objective of this work? What was the main conclusion? What experiments could we conduct to test the hypothesis that emerged at the end of the conclusion? References Fernandez E, Schiffers K, Urbach C &amp; Luedeling E. (2022). Unusually warm winter seasons may compromise the performance of current phenology models – predicting bloom dates in young apple trees with PhenoFlex. Agricultural and Forest Meteorology, 322, 109020. doi: 10.1016/j.agrformet.2022.109020 Luedeling E, Schiffers K, Fohrmann T &amp; Urbach C. (2021). Pheno-flex - an integrated model to predict spring phenology in temperate fruit trees. Agricultural and Forest Meteorology, 307, 108491. doi: 10.1016/j.agrformet.2021.108491 "],["frost-risk-analysis.html", "Chapter 33 Frost risk analysis Learning goals for this lesson 33.1 Spring frost 33.2 Phenology trend analysis 33.3 Frost risk Exercises on frost risk analysis", " Chapter 33 Frost risk analysis Learning goals for this lesson Appreciate the danger of spring frost for orchard crops Learn how to plot bloom data over time Consolidate skills from earlier lessons by defining a temperature response model and applying it to a temperature dataset Evaluate frost occurrence at a location Plot frost occurrences in relation to bloom dates Quantitatively evaluate long-term trends in the risk of frost events during bloom 33.1 Spring frost Today we’ll look at an application of some of the procedures we looked at. The challenge we’re addressing is the risk of spring frost during flowering. After budbreak, trees are very sensitive to frost, and especially the emerging flowers can be severely damaged by freezing temperatures. As you (should) know, all tree fruits develop from flowers, so severely damaged flowers is bad news. In fact, spring frost events at an unfortunate time can lead to complete crop failure in many orchard crops. The following table illustrates the extent of such losses: Area, production and yield of major fruit trees in Germany in 2017 and 2018. Note the dramatic yield difference between these years. In 2017, orchards in much of the country were hit by a major spring frost event, which caused severe damage to tree flowers DESTATIS; Statistisches Bundesamt. A serious spring frost event in April of 2017, with several consecutive nights of considerable frost (around -5°C) led to strong reductions in the number of viable flowers, which translated into very low final yields. This event caused serious hardship for many fruit growers. Even though this was surely not the first such event ever recorded, it raised concerns about the possible impact of climate change on the risk of frost damage. In this day and age, whenever an unusual weather event happens, we quickly jump to the conclusion that climate change may be at play. This may often be a correct guess, but of course weather has always been variable, with a certain interannual variation being part of our ‘normal’ climate. A critical question in this context is whether 2017 was a freak outlier event or a harbinger of a ‘new normal’, where growers will suffer increasingly from losses due to spring frost events. This is the question we’re trying to address today. The reason why answering this question is worth a bit of effort is that the risk of spring frost should factor into two important strategic decisions in fruit production: Investment in frost protection: Growers can protect themselves from frost damage by choosing among a limited number of frost protection strategies. In most settings, the most effective strategy is the use of frost protection sprinklers, but some growers also use ‘candles’ or wind machines (incl. in some cases helicopters). Each of these strategies requires investing in infrastructure or other materials (such as candles), which will only produce benefits in years with spring frost events. The profitability of such investments thus depends strongly on the likelihood of such events. Cultivar choice: Some tree species or cultivars flower early, and some flower late. Obviously, late-flowering cultivars usually have a lower risk of suffering from spring frost damage than early-flowering ones. However, their fruits may also tend to mature later, at a time when market prices are low, or there may be other reasons for wanting to plant trees with early bloom dates. Also for this decision, knowledge of the risk of spring frost would be very helpful. So let’s see how we can address this. We’ll be focusing on the experimental station of the University of Bonn at Klein-Altendorf. Here it is: library(leaflet) library(dplyr) leaflet() %&gt;% setView(lng = 6.99, lat = 50.625, zoom=12) %&gt;% addTiles() %&gt;% addMarkers(lng = 6.99, lat = 50.625, popup = &quot;Campus Klein-Altendorf&quot;) Figure 33.1: Location of Campus Klein-Altendorf, an experimental station of the University of Bonn By the way, it took me just about 1 minute to find out, using just an internet search engine, how to include an interactive map in a markdown document. This is how easy it is to get impressive things done in markdown (sometimes)! One of the remarkable features of this experimental station is that a few generations of technical staff have been diligently recording phenology data since the 1950s. We also have very good weather data for this entire period. Let’s use this information and the knowledge we’ve already gained in this module to produce a state-of-the-art frost risk assessment (focusing for now only on historic data). Let’s first load long-term weather and bloom datasets into R. Download bloom data for Alexander Lucas pears (1958-2019) Download weather data for Campus Klein Altendorf (1958-2019) Please download the files and save them in your data directory. Now we can load them. CKA_Alexander_Lucas &lt;- read_tab(&quot;data/Alexander_Lucas_bloom_1958_2019.csv&quot;) CKA_weather &lt;- read_tab(&quot;data/TMaxTMin1958-2019_patched.csv&quot;) The CKA_weather dataset looks like the patched weather datasets we’ve seen before. 33.2 Phenology trend analysis Here’s what the bloom dataset CKA_Alexander_Lucas looks like: head(CKA_Alexander_Lucas) Pheno_year First_bloom Full_bloom Last_bloom 1958 19580502 19580503 19580507 1959 19590408 19590413 19590421 1960 19600410 19600415 19600421 1961 19610330 19610408 19610415 1962 19620427 19620505 19620510 1963 19630428 19630504 19630513 We’ll want to plot this with ggplot again later, and by now you may have a good idea of what type of data structure can most effectively do this. We’ll use the pivot_longer function to get our data.frame into the right structure. We’ll also calculate our usual Year, Month and Day columns. Finally, we’ll use a special chillR function (make_JDay) that adds the Julian date to the data.frame. The Julian date is simply the day of the year, i.e. a Julian date of 1 corresponds to \\(1^{st}\\) January, 2 to \\(2^{nd}\\) January, and 32 to \\(1^{st}\\) February etc. library(tidyverse) Alexander_Lucas &lt;- CKA_Alexander_Lucas %&gt;% pivot_longer(cols = &quot;First_bloom&quot;:&quot;Last_bloom&quot;, names_to = &quot;variable&quot;, values_to=&quot;YEARMODA&quot;) %&gt;% mutate(Year = as.numeric(substr(YEARMODA, 1, 4)), Month = as.numeric(substr(YEARMODA, 5, 6)), Day = as.numeric(substr(YEARMODA, 7, 8))) %&gt;% make_JDay() head(Alexander_Lucas) Pheno_year variable YEARMODA Year Month Day JDay 1958 First_bloom 19580502 1958 5 2 122 1958 Full_bloom 19580503 1958 5 3 123 1958 Last_bloom 19580507 1958 5 7 127 1959 First_bloom 19590408 1959 4 8 98 1959 Full_bloom 19590413 1959 4 13 103 We can now plot bloom dates for the historic record: ggplot(data = Alexander_Lucas, aes(Pheno_year, JDay, col = variable)) + geom_line() + theme_bw(base_size = 15) + scale_color_discrete( name = &quot;Phenological event&quot;, labels = c(&quot;First bloom&quot;, &quot;Full bloom&quot;, &quot;Last bloom&quot;)) + xlab(&quot;Phenological year&quot;) + ylab(&quot;Julian date (day of the year)&quot;) It’s a bit hard to see what’s going on here, so let’s add a regression line. ggplot has a convenient function for this. We can even add a standard error to the line: ggplot(data = Alexander_Lucas, aes(Pheno_year, JDay, col = variable)) + geom_line() + theme_bw(base_size = 15) + scale_color_discrete(name = &quot;Phenological event&quot;, labels = c(&quot;First bloom&quot;, &quot;Full bloom&quot;, &quot;Last bloom&quot;)) + xlab(&quot;Phenological year&quot;) + ylab(&quot;Julian date (day of the year)&quot;) + geom_smooth(method = &quot;lm&quot;) We could also use the geom_smooth method to display the data. ggplot(data=Alexander_Lucas,aes(Pheno_year,JDay,col=variable)) + geom_smooth() + theme_bw(base_size=15) + scale_color_discrete( name = &quot;Phenological event&quot;, labels = c(&quot;First bloom&quot;, &quot;Full bloom&quot;, &quot;Last bloom&quot;)) + xlab(&quot;Phenological year&quot;) + ylab(&quot;Julian date (day of the year)&quot;) Looks like we have a trend here, but how can we be sure? The Kendall test is a pretty good tool for testing time series for trends: require(Kendall) Kendall_first &lt;- Kendall(x = Alexander_Lucas$Pheno_year[ which(Alexander_Lucas$variable == &quot;First_bloom&quot;)], y = Alexander_Lucas$JDay[ which(Alexander_Lucas$variable == &quot;First_bloom&quot;)]) Kendall_full &lt;- Kendall(x = Alexander_Lucas$Pheno_year[ which(Alexander_Lucas$variable == &quot;Full_bloom&quot;)], y = Alexander_Lucas$JDay[ which(Alexander_Lucas$variable == &quot;Full_bloom&quot;)]) Kendall_last &lt;- Kendall(x = Alexander_Lucas$Pheno_year[ which(Alexander_Lucas$variable == &quot;Last_bloom&quot;)], y = Alexander_Lucas$JDay[ which(Alexander_Lucas$variable == &quot;Last_bloom&quot;)]) Kendall_first ## tau = -0.186, 2-sided pvalue =0.03533 Kendall_full ## tau = -0.27, 2-sided pvalue =0.0021401 Kendall_last ## tau = -0.233, 2-sided pvalue =0.0083237 This test is a rank correlation test, which focuses on how often a value increases or decreases from one year to the next. If we overwhelmingly have movement in one direction, as is the case here, we have a significant trend. The 2-sided p-value given here can be interpreted like the usual p values we’re used to. In all cases, these values are &lt;0.05, so we can be pretty sure that we have a trend here. The tau value is negative, meaning that we have a decreasing (bloom-advancing) trend. Maybe we’re also interested in the strength of the trend. The Kendall test doesn’t give us that information, and we may need to assume that our data can be described by some sort of mathematical function. Let’s do what most people do and assume a linear model. linear_trend_first &lt;- lm( Alexander_Lucas$JDay[ which(Alexander_Lucas$variable == &quot;First_bloom&quot;)]~ Alexander_Lucas$Pheno_year[ which(Alexander_Lucas$variable == &quot;First_bloom&quot;)]) linear_trend_full &lt;- lm( Alexander_Lucas$JDay[ which(Alexander_Lucas$variable == &quot;Full_bloom&quot;)]~ Alexander_Lucas$Pheno_year[ which(Alexander_Lucas$variable == &quot;First_bloom&quot;)]) linear_trend_last &lt;- lm( Alexander_Lucas$JDay[ which(Alexander_Lucas$variable == &quot;Last_bloom&quot;)]~ Alexander_Lucas$Pheno_year[ which(Alexander_Lucas$variable == &quot;First_bloom&quot;)]) linear_trend_first ## ## Call: ## lm(formula = Alexander_Lucas$JDay[which(Alexander_Lucas$variable == ## &quot;First_bloom&quot;)] ~ Alexander_Lucas$Pheno_year[which(Alexander_Lucas$variable == ## &quot;First_bloom&quot;)]) ## ## Coefficients: ## (Intercept) ## 429.1662 ## Alexander_Lucas$Pheno_year[which(Alexander_Lucas$variable == &quot;First_bloom&quot;)] ## -0.1618 linear_trend_full ## ## Call: ## lm(formula = Alexander_Lucas$JDay[which(Alexander_Lucas$variable == ## &quot;Full_bloom&quot;)] ~ Alexander_Lucas$Pheno_year[which(Alexander_Lucas$variable == ## &quot;First_bloom&quot;)]) ## ## Coefficients: ## (Intercept) ## 569.6720 ## Alexander_Lucas$Pheno_year[which(Alexander_Lucas$variable == &quot;First_bloom&quot;)] ## -0.2305 linear_trend_last ## ## Call: ## lm(formula = Alexander_Lucas$JDay[which(Alexander_Lucas$variable == ## &quot;Last_bloom&quot;)] ~ Alexander_Lucas$Pheno_year[which(Alexander_Lucas$variable == ## &quot;First_bloom&quot;)]) ## ## Coefficients: ## (Intercept) ## 485.9785 ## Alexander_Lucas$Pheno_year[which(Alexander_Lucas$variable == &quot;First_bloom&quot;)] ## -0.1841 What we have to look at is the second model coefficient, which is -0.16 for first bloom, -0.23 for full bloom and -0.18 for last bloom. Such shifts are often specified per decade, so we’ll have to multiply by a factor of 10. Let’s collect all our trend results: phenology_trends &lt;- data.frame(Stage = c(&quot;First bloom&quot;, &quot;Full bloom&quot;, &quot;Last bloom&quot;), Kendall_tau = c(round(Kendall_first[[1]][1],3), round(Kendall_full[[1]][1],3), round(Kendall_last[[1]][1],3)), Kendall_p = c(round(Kendall_first[[2]][1],3), round(Kendall_full[[2]][1],3), round(Kendall_last[[2]][1],3)), Linear_trend_per_decade = c(round(linear_trend_first[[1]][2],2) * 10, round(linear_trend_full[[1]][2],2) * 10, round(linear_trend_last[[1]][2],2) * 10) ) phenology_trends Stage Kendall_tau Kendall_p Linear_trend_per_decade First bloom -0.186 0.035 -1.6 Full bloom -0.270 0.002 -2.3 Last bloom -0.233 0.008 -1.8 33.3 Frost risk To analyze the frost risk, we first need a frost model. We’re going to keep this relatively simple and just count any hour with temperatures &lt;0°C as a frost hour. In reality, the story is a bit more complicated, because as buds break out of dormancy, they gradually become more sensitive to frost. Fully dormant buds can withstand rather deep freezes (in many species), and this hardiness gradually diminishes as phenological development resumes in spring. We’ll stick to a simple model for now. We’ve built simple temperature models before, so this shouldn’t be a big problem for us. As a reminder, we can call up the help file of step_model for guidance. frost_df = data.frame( lower = c(-1000, 0), upper = c(0, 1000), weight = c(1, 0)) frost_model &lt;- function(x) step_model(x, frost_df) Now we can apply this model to the historic record, after converting the temperature record to hourly values: hourly &lt;- stack_hourly_temps(CKA_weather, latitude = 50.625) frost &lt;- tempResponse(hourly, models = c(frost = frost_model)) ggplot(frost, aes(End_year, frost)) + geom_smooth() + geom_point() + ylim(c(0, NA)) + ylab(&quot;Frost hours per year&quot;) + xlab(&quot;Year&quot;) What we see clearly here is that the number of frost hours has decreased quite strongly at Klein-Altendorf. Let’s calculate the same statistics as before: Kendall(x = frost$End_year, y = frost$frost) ## tau = -0.179, 2-sided pvalue =0.041862 lm(frost$frost ~ frost$End_year) ## ## Call: ## lm(formula = frost$frost ~ frost$End_year) ## ## Coefficients: ## (Intercept) frost$End_year ## 11172.57 -5.19 So on average, assuming a linear decline, we’ve lost about -5.2 frost hours per year! You can probably see how we could easily make historic scenarios of frost hour numbers using the functions we learned about in previous lessons. But here we’re not really interested in how many frost hours we’ve had - we want to know if our pear trees have been affected by spring frost. For this we don’t need this aggregation for the whole year - we need daily data of frost occurrence that we can then compare with bloom dates. For this, we need a slightly different version of our frost model: frost_model_no_summ &lt;- function(x) step_model(x, frost_df, summ=FALSE) hourly$hourtemps[, &quot;frost&quot;] &lt;- frost_model_no_summ(hourly$hourtemps$Temp) Daily_frost_hours &lt;- aggregate(hourly$hourtemps$frost, by = list(hourly$hourtemps$YEARMODA), FUN = sum) Daily_frost &lt;- make_JDay(CKA_weather) Daily_frost[, &quot;Frost_hours&quot;] &lt;- Daily_frost_hours$x Here is what just happened: To actually find out whether an individual hour has frost or not, we need a frost model that doesn’t automatically add up all frost hours that accumulate. To achieve this, we have to get back into the step_model function and set the parameter summ to FALSE. We can apply the resulting model directly to the hourly temperatures. We probably shouldn’t plot the data by hour, but rather by day, so we need to summarize the hourly data. This can be achieved with the aggregate function, which can sum up values for all rows in a particular data.frame column that meet certain criteria (the function is actually more general than that, but this is all we need here). We then take our CKA_weather data.frame, add Julian dates to it (make_JDay), and place our daily frost hour data into a new column. Now we’re ready to plot the results. We should find a way to put this into the same plot as our bloom data, so let’s try to use the same axes: Year and JDay. We also wanted to show the number of frost hours of course, so let’s indicate this by using dots of variable size. Since I couldn’t quite figure out how to not show days with 0 frost hours, we should first set the Frost_hours for the respective days to NA. Here’s how this can be achieved with ggplot: Daily_frost$Frost_hours[which(Daily_frost$Frost_hours == 0)] &lt;- NA ggplot(data = Daily_frost, aes(Year, JDay, size = Frost_hours)) + geom_point(col = &quot;light blue&quot;, alpha = 0.8) + scale_size(range = c(0, 3), breaks = c(1, 5, 10, 15, 20), labels = c(&quot;1&quot;, &quot;5&quot;, &quot;10&quot;, &quot;15&quot;, &quot;20&quot;), name = &quot;Frost hours&quot;) + theme_bw(base_size = 15) And now let’s try to plot this in the same figure as the bloom dates: ggplot(data = Alexander_Lucas, aes(Pheno_year, JDay, col = variable)) + geom_line() + theme_bw(base_size = 15) + scale_color_discrete( name = &quot;Phenological event&quot;, labels = c(&quot;First bloom&quot;, &quot;Full bloom&quot;, &quot;Last bloom&quot;)) + xlab(&quot;Phenological year&quot;) + ylab(&quot;Julian date (day of the year)&quot;) + geom_point(data = Daily_frost, aes(Year, JDay, size = Frost_hours), col = &quot;light blue&quot;, alpha = 0.8) + scale_size(range = c(0, 3), breaks = c(1, 5, 10, 15, 20), labels = c(&quot;1&quot;, &quot;5&quot;, &quot;10&quot;, &quot;15&quot;, &quot;20&quot;), name = &quot;Frost hours&quot;) + theme_bw(base_size = 15) Hard to see anything here. We’re really only interested in spring, so let’s only show data for that period: ggplot(data = Alexander_Lucas, aes(Pheno_year, JDay, col = variable)) + geom_line() + theme_bw(base_size = 15) + scale_color_discrete( name = &quot;Phenological event&quot;, labels = c(&quot;First bloom&quot;, &quot;Full bloom&quot;, &quot;Last bloom&quot;)) + xlab(&quot;Phenological year&quot;) + ylab(&quot;Julian date (day of the year)&quot;) + geom_point(data = Daily_frost, aes(Year, JDay, size = Frost_hours), col = &quot;light blue&quot;, alpha = 0.8) + scale_size(range = c(0, 3), breaks = c(1, 5, 10, 15, 20), labels = c(&quot;1&quot;, &quot;5&quot;, &quot;10&quot;, &quot;15&quot;, &quot;20&quot;), name = &quot;Frost hours&quot;) + theme_bw(base_size = 15) + ylim(c(75, 140)) Still hard to see. We need a better way to show the bloom dates. Let’s try a ribbon for the total bloom duration and a line for full bloom. That requires a bit of restructuring. Ribbon_Lucas &lt;- Alexander_Lucas %&gt;% select(Pheno_year, variable, JDay) %&gt;% pivot_wider(names_from = &quot;variable&quot;, values_from = &quot;JDay&quot;) ggplot(data = Ribbon_Lucas, aes(Pheno_year)) + geom_ribbon(aes(ymin = First_bloom, ymax = Last_bloom), fill = &quot;light gray&quot;) + geom_line(aes(y = Full_bloom)) + theme_bw(base_size = 15) + xlab(&quot;Phenological year&quot;) + ylab(&quot;Julian date (day of the year)&quot;) + geom_point(data = Daily_frost, aes(Year, JDay, size = Frost_hours), col = &quot;light blue&quot;, alpha = 0.8) + scale_size(range = c(0, 3), breaks = c(1, 5, 10, 15, 20), labels = c(&quot;1&quot;, &quot;5&quot;, &quot;10&quot;, &quot;15&quot;, &quot;20&quot;), name = &quot;Frost hours&quot;) + theme_bw(base_size = 15) + ylim(c(75, 140)) It’s still a bit hard to see when frost events coincided with bloom. Let’s try to point this out more clearly by adding color. # identify frost events that overlap with bloom lookup_dates &lt;- Ribbon_Lucas row.names(lookup_dates) &lt;- lookup_dates$Pheno_year Daily_frost[, &quot;First_bloom&quot;]&lt;- lookup_dates[as.character(Daily_frost$Year), &quot;First_bloom&quot;] Daily_frost[, &quot;Last_bloom&quot;]&lt;- lookup_dates[as.character(Daily_frost$Year), &quot;Last_bloom&quot;] Daily_frost[which(!is.na(Daily_frost$Frost_hours)), &quot;Bloom_frost&quot;] &lt;- &quot;Before bloom&quot; Daily_frost[which(Daily_frost$JDay &gt;= Daily_frost$First_bloom), &quot;Bloom_frost&quot;]&lt;- &quot;During bloom&quot; Daily_frost[which(Daily_frost$JDay &gt; Daily_frost$Last_bloom), &quot;Bloom_frost&quot;]&lt;- &quot;After bloom&quot; Daily_frost[which(Daily_frost$JDay &gt; 180), &quot;Bloom_frost&quot;]&lt;- &quot;Before bloom&quot; ggplot(data = Ribbon_Lucas, aes(Pheno_year)) + geom_ribbon(aes(ymin = First_bloom, ymax = Last_bloom), fill = &quot;light gray&quot;) + geom_line(aes(y = Full_bloom)) + theme_bw(base_size = 15) + xlab(&quot;Phenological year&quot;) + ylab(&quot;Julian date (day of the year)&quot;) + geom_point(data = Daily_frost, aes(Year, JDay, size = Frost_hours, col = Bloom_frost), alpha = 0.8) + scale_size(range = c(0, 5), breaks = c(1, 5, 10, 15, 20), labels = c(&quot;1&quot;, &quot;5&quot;, &quot;10&quot;, &quot;15&quot;, &quot;20&quot;), name = &quot;Frost hours&quot;) + scale_color_manual( breaks = c(&quot;Before bloom&quot;, &quot;During bloom&quot;, &quot;After bloom&quot;), values = c(&quot;light green&quot;, &quot;red&quot;, &quot;light blue&quot;), name = &quot;Frost timing&quot;) + theme_bw(base_size = 15) + ylim(c(75, 140)) Now let’s see if there’s been a long-term trend in the number of frost hours during bloom: Bloom_frost_trend &lt;- aggregate( Daily_frost$Frost_hours, by = list(Daily_frost$Year, Daily_frost$Bloom_frost), FUN = function(x) sum(x, na.rm = TRUE)) colnames(Bloom_frost_trend) &lt;- c(&quot;Year&quot;, &quot;Frost_timing&quot;, &quot;Frost_hours&quot;) DuringBloom&lt;- Bloom_frost_trend[ which(Bloom_frost_trend$Frost_timing == &quot;During bloom&quot;),] ggplot(data = DuringBloom, aes(Year, Frost_hours)) + geom_col() It’s a bit hard to see whether there’s a trend here. Let’s do some statistics again: Kendall(x = DuringBloom$Year, y = DuringBloom$Frost_hours) ## tau = 0.0834, 2-sided pvalue =0.3797 lm(DuringBloom$Frost_hours ~ DuringBloom$Year) ## ## Call: ## lm(formula = DuringBloom$Frost_hours ~ DuringBloom$Year) ## ## Coefficients: ## (Intercept) DuringBloom$Year ## -159.07879 0.08302 So the slope of this regression indicates an average increase by 0.08 frost hours during bloom each year. However, the Kendall test did not consider this a significant trend. Exercises on frost risk analysis Please document all results of the following assignments in your learning logbook. Download the phenology dataset for the apple cultivar Roter Boskoop from Klein-Altendorf. Download Roter Boskoop dataset Illustrate the development of the bloom period over the duration of the weather record. Use multiple ways to show this - feel free to be creative. Evaluate the occurrence of frost events at Klein-Altendorf since 1958. Illustrate this in a plot. Produce an illustration of the relationship between spring frost events and the bloom period of ‘Roter Boskoop’. Evaluate how the risk of spring frost for this cultivar has changed over time. Has there been a significant trend? "],["a-robust-method-to-estimate-future-frost-risks.html", "Chapter 34 A robust method to estimate future frost risks (?) Learning goals for this lesson 34.1 Frost risk for future scenarios 34.2 Validation 34.3 Exercises for this chapter", " Chapter 34 A robust method to estimate future frost risks (?) Learning goals for this lesson Apply the concepts learned in chapter Making valid tree phenology models Implement a robust (and hopefully valid) methodology to forecast spring phenology under future scenarios Assess the risk of frost events under future scenarios 34.1 Frost risk for future scenarios We have seen in the previous chapter the importance of analyzing the risk of spring frost events in temperate fruit trees for historic periods. However, such analysis provides little information for planning strategies to adapt fruit orchards to potential frost events occurring in the future. What we actually need for supporting farmers in making decisions is an assessment of the probability of experiencing frost events (and ideally also their severity) in the future. Such an assessment should consider the prospective impacts of climate change. This is not an easy task. On the one hand, spring frosts result from the occurrence of temperatures below the sensitivity threshold of the tree, which varies according to which kind of plant tissue is exposed to the cold. Plants become more sensitive to freezing temperatures as they develop from dormancy to harvest. On the other hand, tree development during and after dormancy is itself driven by temperature, with advancing or delaying effects depending on particular factors such as the species, cultivar and ultimately the place. In our lab, we therefore believe that conducting a proper frost risk analysis for future scenarios requires i) a robust method for estimating future temperatures, and ii) a valid modeling framework to predict bloom dates in temperate fruit trees. Fortunately, we may be very close to fulfilling these two requirements as we have seen in chapters Future temperature scenarios and, most recently, The PhenoFlex model. We will use some content of the chapter Making valid tree phenology models. As you (hopefully) remember, in that chapter we combined our dataset of past conditions in Campus Klein-Altendorf with the simulated conditions from our Experimentally enhanced PLS chapter. We used this to determine to what extent the combined temperature domain of these datasets covers the climatic conditions that are projected for future climate scenarios. Here’s how we can create such a plot (very similar to what we did before): # Load all the required packages for this lesson library(chillR) library(tidyverse) library(patchwork) # Import the past weather dataset to build the hull plots for model validity domains # Note: data from 01.01.1958 to 20.06.2019. Not complete season for bloom in 1958 (missing Oct-Dec 1957). Barely passing the threshold for bloom in 2019 (need to set mrange to c(9, 5) in genSeasonList for PhenoFlex calibration) past_weather &lt;- read_tab(&quot;data/TMaxTMin1958-2019_patched.csv&quot;) # Add the column SSP_Time for further discrimination with future scenarios past_weather$SSP_Time &lt;- &quot;Past&quot; # Summarize the data by month. Compute the mean of Tmin and Tmax by RCP_Time, Year, and Month past_months &lt;- past_weather %&gt;% group_by(SSP_Time, Year, Month) %&gt;% summarize(Tmin = mean(Tmin, na.rm = TRUE), Tmax = mean(Tmax, na.rm = TRUE)) unstructured_future_temps &lt;- load_temperature_scenarios(&quot;data/future_climate&quot;, &quot;Bonn_futuretemps&quot;) future_temps &lt;- data.frame(bind_rows(lapply(unstructured_future_temps, bind_rows), .id = &quot;List&quot;)) future_temps &lt;- future_temps %&gt;% mutate(GCM = strsplit(List, &#39;\\\\.&#39;) %&gt;% map(3) %&gt;% unlist(), SSP = strsplit(List, &#39;\\\\.&#39;) %&gt;% map(2) %&gt;% unlist(), Time = strsplit(List, &#39;\\\\.&#39;) %&gt;% map(4) %&gt;% unlist()) %&gt;% select(DATE, Year, Month, Day, Tmin, Tmax, SSP, Time, GCM) future_temps[future_temps$SSP == &quot;ssp126&quot;,&quot;SSP_Time&quot;] &lt;- paste(&quot;SSP1&quot;, future_temps[future_temps$SSP == &quot;ssp126&quot;,&quot;Time&quot;]) future_temps[future_temps$SSP == &quot;ssp245&quot;,&quot;SSP_Time&quot;] &lt;- paste(&quot;SSP2&quot;, future_temps[future_temps$SSP == &quot;ssp245&quot;,&quot;Time&quot;]) future_temps[future_temps$SSP == &quot;ssp585&quot;,&quot;SSP_Time&quot;] &lt;- paste(&quot;SSP5&quot;, future_temps[future_temps$SSP == &quot;ssp585&quot;,&quot;Time&quot;]) # Summarize the data by month. Compute the mean of Tmin and Tmax by RCP_Time, Year, and Month future_months &lt;- future_temps %&gt;% group_by(SSP_Time, Year, Month) %&gt;% summarize(Tmin = mean(Tmin, na.rm = TRUE), Tmax = mean(Tmax, na.rm = TRUE)) # Merge the past and future months to plot them together all_months &lt;- rbind(past_months, future_months) # Add a column for the name of the month all_months$month_name &lt;- factor(all_months$Month, levels = c(6 : 12, 1 : 5), labels = month.name[c(6 : 12, 1 : 5)]) # Calculate the hulls for each group hull_temps &lt;- all_months %&gt;% group_by(SSP_Time, month_name) %&gt;% slice(chull(Tmin, Tmax)) # Load the weather data from the experimental seasons to generate an &quot;Enhanced&quot; temps category enhanced &lt;- read_tab(&quot;data/final_weather_data_S1_S2_pear_hourly.csv&quot;) # Summarize the data. Compute the minimum and maximum records in a daily basis enhanced &lt;- enhanced %&gt;% group_by(YEARMODA, Treatment, Year, Month ) %&gt;% summarize(Tmin = min(Temp, na.rm = TRUE), Tmax = max(Temp, na.rm = TRUE)) # Summarize the data by month now. Compute mean across minimum and maximum records enhanced &lt;- enhanced %&gt;% group_by(Treatment, Month) %&gt;% summarize(Tmin = mean(Tmin), Tmax = mean(Tmax)) # Re-format the column Year and add the column RCP_Time enhanced$Year &lt;- enhanced$Treatment enhanced$SSP_Time &lt;- &quot;Past_enhanced&quot; # Combining the past and the enhanced temps past_months$SSP_Time &lt;- &quot;Past combined&quot; enhanced$SSP_Time &lt;- &quot;Past combined&quot; # Merge all the data. Simulated scenarios, observed scenarios, and enhanced temps all_months_both &lt;- rbind(enhanced, past_months, future_months) # Add the labels for the month no all_months_both$month_name &lt;- factor(all_months_both$Month, levels = c(6 : 12, 1 : 5), labels = month.name[c(6 : 12, 1 : 5)]) # Create the hull hull_temps_both &lt;- all_months_both %&gt;% group_by(SSP_Time, month_name) %&gt;% slice(chull(Tmin, Tmax)) # Remove the temperature for the treatments excluded from the analysis. These treatments may be a bit unrealistic and therefore # difficult to be explained by the model all_months_both_conference &lt;- filter(all_months_both, !(Year %in% c(3, 8, 9, 12, 13, 14, 15, 19, 23, 25, 26, 27, 28, 29, 32))) # Create the hull again hull_temps_both_conference &lt;- all_months_both_conference %&gt;% group_by(SSP_Time,month_name) %&gt;% slice(chull(Tmin, Tmax)) write.csv(hull_temps_both,&quot;data/hull_temps_both.csv&quot;,row.names = FALSE) write.csv(hull_temps_both_conference, &quot;data/hull_temps_both_conference.csv&quot;,row.names = FALSE) hull_temps_both &lt;- read_tab(&quot;data/hull_temps_both.csv&quot;) # Implement the plot showing the overlap among conditions ggplot(hull_temps_both[which(hull_temps_both$Month %in% c(10,11,12,1,2,3)),], aes(Tmin, Tmax, fill = factor(SSP_Time))) + geom_polygon() + facet_wrap(vars(month_name)) + scale_fill_manual(name=&quot;Scenario&quot;, breaks=c(&quot;Past combined&quot;, &quot;SSP1 2050&quot;, &quot;SSP1 2085&quot;, &quot;SSP2 2050&quot;, &quot;SSP2 2085&quot;, &quot;SSP5 2050&quot;, &quot;SSP5 2085&quot;), values=c(alpha(&quot;black&quot;,0.3), alpha(&quot;light green&quot;,0.5), alpha(&quot;dark green&quot;,0.5), alpha(&quot;coral&quot;,0.5), alpha(&quot;dark red&quot;,0.5), alpha(&quot;light blue&quot;,0.5), alpha(&quot;dark blue&quot;,0.5))) + xlab(&quot;Mean daily minimum temperature (°C)&quot;) + ylab(&quot;Mean daily maximum temperature (°C)&quot;) + theme_bw(base_size = 15) This convex-hull plot is showing the coverage considering temperatures in CKA between 1958 and 2019 as well as all experimental seasons analyzed in chapter Experimentally enhanced PLS. To make the phenology modelling approach work with historic and experimental data, we would need to use phenology records from the same species and cultivar (pear cultivar ‘Conference’). Fortunately, we do have historic records for full bloom for this cultivar between 1958 and 2019. However, we may want to subset the experimental data used for the convex-hull plot to only retain seasons that were more or less normal. This is to reduce the misleading effects we may have introduced by using extremely warm treatments. So let’s draw a new convex-hull plot without these unusually warm seasons. This is not a perfect coverage of course but we don’t have more data (for now) for October and November. There is little we can do to fill the coverage gap as we did not include warmer conditions in our experiments during these months. We will proceed with these data hoping that in the near future we are able to identify ‘normal seasons’ in the experimental dataset that help us to improve our modelling validity domain. We can now implement our dormancy modelling framework PhenoFlex by combining historic and experimental records. In this code chunk, we will import and format the data so we can calibrate the model using these records. # Import the phenology data for the historic period 1958-2019 # Note that we are selecting only the Year and full bloom columns historic_pheno_conference &lt;- read_tab(&quot;data/Pheno_pear_conference_1958_2019.csv&quot;)[c(&quot;Year&quot;, &quot;Full_bloom&quot;)] # Remove missing years historic_pheno_conference &lt;- historic_pheno_conference[which(!historic_pheno_conference$Full_bloom==&quot;&quot;),] # Add a column for the JDay historic_pheno_conference$Full_bloom &lt;- dormancyR::date_to_JDay(date = as.Date(historic_pheno_conference$Full_bloom, format = &quot;%d.%m.%Y&quot;), format = &quot;%Y-%m-%d&quot;) # Rename the columns colnames(historic_pheno_conference) &lt;- c(&quot;Year&quot;, &quot;pheno&quot;) # Do the same for the weather data past_weather &lt;- read_tab(&quot;data/TMaxTMin1958-2019_patched.csv&quot;) # Create hourly temps for compatibility with the experimental data set past_weather &lt;- stack_hourly_temps(weather = past_weather, latitude = 50.4)[[&quot;hourtemps&quot;]] # Load the experimental data # Load the data from the folder exp_weather &lt;- read_tab(&quot;data/final_weather_data_S1_S2_pear_hourly.csv&quot;) # Generate a new column (Year_2) to simulate the year and comply with the format of PhenoFlex functions exp_weather[&quot;Year_2&quot;] &lt;- exp_weather$Treatment + exp_weather$Year + 3 # Since this experiment was conducted during two consecutive seasons, the next step will fix a small continuity issue # generated during the season 2 exp_weather[exp_weather$Treatment &gt;= 17, &quot;Year_2&quot;] &lt;- exp_weather[exp_weather$Treatment &gt;= 17, &quot;Year_2&quot;] - 1 # For further compatibility, I will now select the columns needed and will drop &quot;Year&quot; (the original one) exp_weather &lt;- exp_weather[c(&quot;YEARMODA&quot;, &quot;Year_2&quot;, &quot;Month&quot;, &quot;Day&quot;, &quot;Hour&quot;, &quot;JDay&quot;, &quot;Temp&quot;)] # To replace the missing &quot;Year&quot; column, I will now change the name of the column colnames(exp_weather)[which(colnames(exp_weather) == &quot;Year_2&quot;)] &lt;- &quot;Year&quot; # Import the phenology data from the repository exp_pheno &lt;- read_tab(&quot;data/final_bio_data_S1_S2_pear.csv&quot;) exp_pheno[&quot;Treatment&quot;] &lt;- exp_pheno$Treatment + 2019 + 3 # Remove conflictive treatments exp_pheno &lt;- exp_pheno[!(exp_pheno$Treatment %in% c(2025, 2030, 2031, 2034, 2035, 2036, 2037, 2041, 2045, 2047, 2048, 2049, 2050, 2051, 2054)), c(&quot;Treatment&quot;, &quot;pheno&quot;)] # Rename the columns to match the names of the historic dataset colnames(exp_pheno) &lt;- c(&quot;Year&quot;, &quot;pheno&quot;) # Merge the historic and experimental phenology data pheno_merged &lt;- bind_rows(filter(historic_pheno_conference, Year != 1958), exp_pheno) # Merge the historic and experimental phenology data weather_merged &lt;- bind_rows(past_weather[, colnames(past_weather) %in% names(exp_weather)], exp_weather) For phenology and weather records, we now have the historic and experimental data in the same dataset. We can follow the same procedure we implemented in the chapter Can we improve the performance of PhenoFlex? to fit the parameters of PhenoFlex to data. # Define the season used for calibration and validation in the PhenoFlex modelling approach calibration_seasons &lt;- sort(sample(pheno_merged$Year, 50, replace = FALSE)) validation_seasons &lt;- sort(pheno_merged[!(pheno_merged$Year %in% calibration_seasons), &quot;Year&quot;]) # Define the list of seasons (weather data) weather_season_list &lt;- genSeasonList(weather_merged, mrange = c(9, 5), years = calibration_seasons) Now we can apply what we learned in the chapter The PhenoFlex model and fit the model parameters to data. Note that we start the fitting procedure with wide ranges (particularly for yc and zc) in order to let the model find the best estimates. We are saving the parameters and the predicted bloom to our data folder. # Set the initial parameters (wide ranges) # yc, zc, s1, Tu, E0, E1, A0, A1, Tf, Tc, Tb, slope lower &lt;- c(20, 100, 0.1, 0, 3000.0, 9000.0, 6000.0, 5.e13, 0, 0, 0, 0.05) par &lt;- c(40, 190, 0.5, 25, 3372.8, 9900.3, 6319.5, 5.939917e13, 4, 36, 4, 1.60) upper &lt;- c(80, 500, 1.0, 30, 4000.0, 10000.0, 7000.0, 6.e13, 10, 40, 10, 50.00) # Run the fitter pheno_fit &lt;- phenologyFitter(par.guess = par, modelfn = PhenoFlex_GDHwrapper, bloomJDays = pheno_merged[pheno_merged$Year %in% calibration_seasons, &quot;pheno&quot;], SeasonList = weather_season_list, lower = lower, upper = upper, control = list(smooth = FALSE, verbose = FALSE, maxit = 2000, nb.stop.improvement = 20)) # Save the resulting parameters to folder (to avoid having to run the phenology fitter again) write.csv(pheno_fit$par, &quot;data/PhenoFlex_hist_exp_pear.csv&quot;, row.names = FALSE) # Save the results of the predicted phenology for the calibration seasons write.csv(data.frame(pheno_merged[pheno_merged$Year %in% calibration_seasons, ], &quot;Predicted&quot; = pheno_fit$pbloomJDays), &quot;data/PhenoFlex_hist_exp_predicted_bloom_pear.csv&quot;, row.names = FALSE) Let’s take a look at some results from the fitting procedure. We can feed our model with the fitted parameters and then estimate the prediction error by comparing predicted with observed bloom dates. # Read the parameters params &lt;- read.csv(&quot;data/PhenoFlex_hist_exp_pear.csv&quot;)[[1]] # Generate a data set to collect the outputs of the fitting for the calibration data out_df &lt;- read_tab(&quot;data/PhenoFlex_hist_exp_predicted_bloom_pear.csv&quot;) # Compute the error (observed - predicted) out_df[[&quot;Error&quot;]] &lt;- out_df$pheno - out_df$Predicted We can now compute some model performance metrics based on the prediction errors estimated above. This is not very relevant during the calibration procedure, but it can give us an idea on how successful our calibration attempt has been. calibration_metrics Metric Calibration RMSEP 4.59 RPIQ 3.48 There is certainly room for improvement (consider though that we only used 10 iterations of the fitting procedure), but this gives us a relatively small RMSEP for calibration. Let’s plot the results to see the big picture. # Plot the results to see the overall fitting ggplot(out_df, aes(pheno, Predicted)) + geom_point() + geom_abline(intercept = 0, slope = 1) + labs(x = &quot;Observed&quot;) + theme_bw() Once again, this is a good preliminary fitting for calibration but it may worth trying a different par.guess and other arguments within phenologyFitter() during model calibration. 34.2 Validation We should probably now take a look at how well this phenology model can predict bloom dates for seasons not used in the calibration data set. We need to extract the model parameters and use the function PhenoFlex_GDHwrapper() to complete this task. # Generate a validation data set with phenology data valid_df &lt;- pheno_merged[pheno_merged$Year %in% validation_seasons, ] # Generate a list of seasons with weather data for the validation procedure valid_season_list &lt;- genSeasonList(weather_merged, mrange = c(9, 7), years = validation_seasons) # Estimate the bloom dates with PhenoFlexGDHwrapper for (i in 1 : nrow(valid_df)) { valid_df[i, &quot;Predicted&quot;] &lt;- PhenoFlex_GDHwrapper(valid_season_list[[i]], params) } # Compute the error (observed - predicted) valid_df[[&quot;Error&quot;]] &lt;- valid_df$pheno - valid_df$Predicted Since we already know the difference between the observed values and the values predicted by the model (i.e. the prediction error) in the validation data set, we can estimate some model performance metrics such as RMSEP and RPIQ. To this end, we can use the functions RMSEP() and RPIQ() from chillR. Metric PhenoFlex_marginal PhenoFlex_normal RMSEP 6.643169 4.246336 RPIQ 6.171753 9.655382 The results shown in the table above represent a good preliminary performance of the model in forecasting bloom dates in pear trees for conditions we may expect in the future. Note that for a more robust analysis, we should try fitting PhenoFlex many times in order to achieve lower RMSEP values. We could also consider limiting the number of experimental seasons (which may be adding somewhat ‘extreme’ values) to narrow the range of conditions observed in the warm part of the model validity domain. Additional errors may originate from merging two data sets obtained with different methodologies (mature trees in the orchard vs. young potted trees, different observers across experiments, etc.). Let’s take a look at the fitting outcomes. We added labels to show the season presenting an error greater than 10 days. # Plot the validation and calibration results (highlight seasons with 10 or more days of error) ggplot() + geom_point(data = out_df, aes(pheno, Predicted, color = &quot;Calibration&quot;)) + geom_point(data = valid_df, aes(pheno, Predicted, color = &quot;Validation&quot;)) + ggrepel::geom_label_repel(aes(pheno, Predicted, label = Year), data = filter(out_df, abs(Error) &gt; 10), nudge_y = 2, nudge_x = 6) + ggrepel::geom_label_repel(aes(pheno, Predicted, label = Year), data = filter(valid_df, abs(Error) &gt; 10), nudge_y = -1, nudge_x = 9, force = 4) + scale_color_manual(values = c(&quot;cadetblue&quot;, &quot;firebrick&quot;)) + geom_abline(intercept = 0, slope = 1) + labs(x = &quot;Observed&quot;, color = &quot;Dataset&quot;) + theme_bw() Let’s say that we are happy with our validation approach. Using the set of parameters fitted in the previous model runs, we can predict bloom dates for future scenarios. To this end, we will need to use the data generated in chapter Future temperature scenarios. Fortunately, we already loaded that data into R when generating the convex-hull plots. We will use the function PhenoFlex_GDHwrapper() to estimate the date of bloom for future scenarios. The first two sections of the for loop are commands to get the data into a good format for estimating bloom dates. We need to derive hourly records using stack_hourly_temps() and then define the seasons with genSeasonList(). # Create a primer data frame to allocate the results for future bloom future_bloom &lt;- future_temps %&gt;% group_by(SSP_Time, GCM, Year) %&gt;% summarise(Pheno = NA) # Define the scenarios to be used in the for loop scenarios &lt;- unique(future_temps$SSP_Time) # Define the climate models to be used in the for loop climate_models &lt;- unique(future_temps$GCM) # Implement the for loop for (scenario in scenarios){ scen_file &lt;- future_temps %&gt;% filter(SSP_Time == scenario) climate_models &lt;- unique(scen_file$GCM) for (climate_model in climate_models){ # Subset a temporary data frame according to scenario and climate model # and generate hourly temperatures temp_df &lt;- filter(scen_file, GCM == climate_model) %&gt;% stack_hourly_temps(latitude = 50.4) # Define the saeasons to be used for predicting the phenology temp_seasons_list &lt;- genSeasonList(temp_df$hourtemps, mrange = c(9, 7), years = c(2002 : 2101)) # Change the names of the list of seasons to be used as index in the next for loop names(temp_seasons_list) &lt;- 2002 : 2101 # Implement a for loop that runs over the list of seasons to estimate the bloom date using the parameters fitted by the # model for (i in 1 : length(temp_seasons_list)){ # Add the bloom date to the primer data set future_bloom[future_bloom$SSP_Time == scenario &amp; future_bloom$GCM == climate_model &amp; future_bloom$Year == names(temp_seasons_list)[i], &quot;Pheno&quot;] &lt;- PhenoFlex_GDHwrapper(temp_seasons_list[[i]], params) } } } We can now implement the same procedure to estimate bloom dates for historic simulated scenarios. # Bloom for past simulated scenarios #### # Load the historic simulated scenarios temps_past_scenarios &lt;- load_temperature_scenarios(&quot;data&quot;, &quot;Bonn_hist_scenarios&quot;) # Create a single dataset for all the simulated years temps_past_scenarios &lt;- bind_rows(temps_past_scenarios, .id = &quot;Scen_year&quot;) # Make a primer dataset to allocate the results of the bloom projection simulated_bloom &lt;- temps_past_scenarios %&gt;% group_by(Scen_year, Year) %&gt;% summarise(Pheno = NA) # Define the scenario years to be used in the loop scen_years &lt;- unique(simulated_bloom$Scen_year) # Implement the for loop for (scen_year in scen_years){ # Subset a temporary data frame according to scenario and climate model temp_df &lt;- filter(temps_past_scenarios, Scen_year == scen_year) # Generate hourly temperatures in the temporary data frame temp_df &lt;- stack_hourly_temps(temp_df, latitude = 50.4) # Define the saeasons to be used for predicting the phenology temp_seasons_list &lt;- genSeasonList(temp_df$hourtemps, mrange = c(9, 7), years = c(2002 : 2101)) # Change the names of the list of seasons to be used as index in the next for loop names(temp_seasons_list) &lt;- 2002 : 2101 # Implement a for loop that runs over the list of seasons to estimate the bloom date using the parameters fitted by the # model for (i in 1 : length(temp_seasons_list)){ # Add the bloom date to the primer data set simulated_bloom[simulated_bloom$Scen_year == scen_year &amp; simulated_bloom$Year == names(temp_seasons_list)[i], &quot;Pheno&quot;] &lt;- PhenoFlex_GDHwrapper(temp_seasons_list[[i]], params) } } write.csv(simulated_bloom, &quot;data/frost_simulated_bloom.csv&quot;, row.names = FALSE) We are going to produce a plot now to show the likely bloom dates for historic and future scenarios. We will also add the data used for calibration of the PhenoFlex model. The plot is a bit complicated, because it’s difficult to plot two datasets with different axes in the same plot panel. The plotting strategy below goes as follows: We start with a violin plot of the simulated bloom data for the past scenarios. Then we extract the x and y axis limits from this plot (using the layer_scales command). We make a density plot of the calibration data (distinguishing between the historic and experimental data), but only to extract the data from it (the ggplot_build part below). We convert the density data that we extracted from the plot into numeric values that can be plotted on the same axis as the years in the first plot. We then add these data to the first plot as a geom_ribbon. We make a plot of the future data (much easier). We combine both plots using the patchwork package. We save this as an image using the ggsave function. We still had to adjust all kinds of settings… So this wasn’t easy but in the end we got something that was pretty close to what we had in mind. # Plot all bloom prediction results # Plot showing the violins for historic simulated scenarios past_simulated_plot &lt;- ggplot(data = simulated_bloom) + geom_violin( aes(x = Scen_year, group = Scen_year, y = Pheno), linewidth = 0.35, draw_quantiles = c(0.25, 0.5, 0.75), alpha = 0.5) + facet_grid(~ &quot;Historic&quot;) + theme_bw() + theme(axis.title.x=element_blank(), axis.title.y=element_blank(), plot.background = element_rect(fill = &quot;transparent&quot;), panel.background = element_blank(), panel.grid = element_blank(), aspect.ratio = 4) past_xlim &lt;- layer_scales(past_simulated_plot)$x$range$range past_ylim &lt;- layer_scales(past_simulated_plot)$y$range$range # Make a density plot to show the distribution of the seasons used for calibration of the PhenoFlex modelling framework # Create a dataframe with columns to be used in the plot observed_bloom_calibration &lt;- data.frame(out_df, Facet = &quot;Past scenarios&quot;, Dataset = if_else(out_df$Year &gt; 2010, &quot;Experimental&quot;, &quot;Historic&quot;)) # Make a density plot of the bloom dates included in the calibration dataset gg_density_plot &lt;- ggplot() + geom_density(data = observed_bloom_calibration, aes(y = pheno, fill = Dataset) ) # Extract data from the plot density_data &lt;- gg_density_plot %&gt;% ggplot_build() %&gt;% pluck(1,1) %&gt;% select(x:y,group) # Scale data so that they can be plotted on the Year axis density_data[density_data$group == 1, &quot;Dataset&quot;] &lt;- &quot;Experimental&quot; density_data[density_data$group == 2, &quot;Dataset&quot;] &lt;- &quot;Historic&quot; density_data &lt;- density_data %&gt;% mutate(density_scaled = x / max(x), density_scaled = density_scaled * (past_xlim[2] - past_xlim[1]) * 0.9 + past_xlim[1]) # merge the two plots (and plot the violin plot again, so that it&#39;s placed # on top) past_observed_plot &lt;- past_simulated_plot + geom_ribbon(data = density_data, stat = &quot;identity&quot;, position = &quot;identity&quot;, aes(xmin = past_xlim[1], xmax = density_scaled, y = y, fill = Dataset), alpha = 0.75) + geom_violin(data = simulated_bloom, aes(x = Scen_year, group = Scen_year, y = Pheno), size = 0.35, draw_quantiles = c(0.25, 0.5, 0.75), alpha = 0.5) + scale_y_continuous(limits = c(10,160), labels = function (x) format(dormancyR::JDay_to_date(x, 2001, na.rm = TRUE), &quot;%b %d&quot;)) + theme(legend.position = c(0.5, 0.1), axis.text.x = element_text(size = 8, angle = 45, vjust = .4, hjust = .6), legend.text = element_text(size = 6), legend.title = element_text(size = 8)) # Create a violin plot to show future bloom dates future_bloom_plot &lt;- ggplot(na.omit(future_bloom), aes(GCM, Pheno, fill = GCM)) + geom_violin(size = 0.35, draw_quantiles = c(0.25, 0.75)) + stat_summary(fun = &quot;median&quot;, geom = &quot;point&quot;, shape = 4, size = 0.8) + scale_y_continuous(limits = c(10, 160), labels = function (x) format(dormancyR::JDay_to_date(x, 2001, na.rm = TRUE), &quot;%b %d&quot;)) + facet_grid(~ SSP_Time) + theme_bw() + theme(legend.position = &quot;bottom&quot;, legend.key.size = unit(0.4, &quot;cm&quot;), legend.text = element_text(size = 7), axis.title = element_blank(), axis.text = element_blank(), axis.ticks = element_blank() ) # Combine plots library(patchwork) past_observed_plot + future_bloom_plot # Save the plot to the folder ggsave(&quot;pictures/future_pheno_pear.png&quot;, device = &quot;png&quot;, width = 19, height = 15, units = &quot;cm&quot;, dpi = 600) This looks pretty good. We can see that bloom in pear cv. Conference is expected to advance slightly under future scenarios. What we need to know now is the probability of observing frost events during the flowering period. To this end, we will assume a bloom period of 10 days around the expected date for full bloom for each simulated year and take a look at the temperatures during these days. # Frost risk part #### # Add the &quot;buffer&quot; around the estimated bloom dates to compute the number of hours below 0 °C in this period. Hypothetically, this represents the # period of bloom in all scenarios # Define the buffer only once bloom_buffer &lt;- 5 # Mutate the future bloom dataset to add the beggining and end for bloom future_bloom &lt;- future_bloom %&gt;% mutate(Beginning = Pheno - bloom_buffer, End = Pheno + bloom_buffer) # Do the same with the observed bloom dataset (i.e. calibration) observed_bloom_calibration &lt;- observed_bloom_calibration %&gt;% mutate(Beginning = pheno - bloom_buffer, End = pheno + bloom_buffer) # Same with the past simulated data from historic scenarios simulated_bloom &lt;- simulated_bloom %&gt;% mutate(Beginning = Pheno - bloom_buffer, End = Pheno + bloom_buffer) We will now compute the number of frost hours expected to occur under future scenarios as well as under historic simulated scenarios. We implement this by using several for loops. for (i in 1 : nrow(observed_bloom_calibration)){ # Extract the beginning and end date for observed bloom beg_bloom &lt;- observed_bloom_calibration[i, &quot;Beginning&quot;] end_bloom &lt;- observed_bloom_calibration[i, &quot;End&quot;] # Subset a temporary dataframe of weather records for the year of interest temp_df &lt;- filter(weather_merged, Year == observed_bloom_calibration[i, &quot;Year&quot;]) # Add the Julian date temp_df &lt;- make_JDay(temp_df) # Filter only the period for bloom temp_df &lt;- filter(temp_df, JDay %in% c(beg_bloom : end_bloom)) # Calculate the number of hours below 0 °C frost_hours &lt;- max(dormancyR::frost_risk(temp_df$Temp, threshold = 0)) # Add the number of hours to the original dataframe observed_bloom_calibration[i, &quot;Frost&quot;] &lt;- frost_hours } We repeat the procedure for past simulated and future scenarios. # Make a primer dataset to allocate the results of the frost projections simulated_frost &lt;- temps_past_scenarios %&gt;% group_by(Scen_year, Year) %&gt;% summarise(Frost = NA) # Implement the loop over scenario years and simulated years for (scen_year in scen_years) for (year in c(2002 : 2100)){ if(!is.na(filter(simulated_bloom, Scen_year == scen_year &amp; Year == year)[[&quot;Pheno&quot;]] )) { # Extract the beginning and end of the blooming period beg_bloom &lt;- filter(na.omit(simulated_bloom), Scen_year == scen_year &amp; Year == year)[[&quot;Beginning&quot;]] beg_bloom &lt;- trunc(beg_bloom) end_bloom &lt;- filter(na.omit(simulated_bloom), Scen_year == scen_year, Year == year)[[&quot;End&quot;]] end_bloom &lt;- trunc(end_bloom) # Filter the weather data according to the relevant scenario year and simulated year temp_df &lt;- filter(temps_past_scenarios, Scen_year == scen_year &amp; Year == year) # Derive hourly temperatures based on the latitude of Campus Klein-Altendorf temp_df &lt;- stack_hourly_temps(temp_df, latitude = 50.4)[[&quot;hourtemps&quot;]] # Filter the relevant period when bloom is likely to occurs temp_df &lt;- filter(temp_df, JDay %in% c(beg_bloom : end_bloom)) # Compute the number of frost hours frost_hours &lt;- max(dormancyR::frost_risk(temp_df$Temp, threshold = 0)) } else frost_hours &lt;- 0 # Add the number of frost events to the primer dataset simulated_frost[simulated_frost$Scen_year == scen_year &amp; simulated_frost$Year == year, &quot;Frost&quot;] &lt;- frost_hours } # Remove NA cells since the first year has no bloom simulated_frost &lt;- na.omit(simulated_frost) Now we process the future scenarios. # Create a primer data frame to allocate the results for future bloom future_frost &lt;- future_temps %&gt;% group_by(SSP_Time, GCM, Year) %&gt;% summarise(Frost = NA) # Implement the for loop for (scenario in scenarios) {scen_file &lt;- future_bloom %&gt;% filter(SSP_Time == scenario) climate_models &lt;- unique(scen_file$GCM) for (climate_model in climate_models) for (year in c(2002 : 2100)){ if(!is.na(filter(scen_file, GCM == climate_model &amp; Year == year)[[&quot;Pheno&quot;]] )) { beg_bloom &lt;- filter(na.omit(scen_file), GCM == climate_model &amp; Year == year)[[&quot;Beginning&quot;]] beg_bloom &lt;- trunc(beg_bloom) end_bloom &lt;- filter(na.omit(scen_file), GCM == climate_model &amp; Year == year)[[&quot;End&quot;]] end_bloom &lt;- trunc(end_bloom) # Derive hourly temperatures based on the latitude of Campus Klein-Altendorf temp_df &lt;- filter(future_temps, SSP_Time == scenario &amp; GCM == climate_model &amp; Year == year) temp_df &lt;- stack_hourly_temps(temp_df, latitude = 50.4)[[&quot;hourtemps&quot;]] temp_df &lt;- filter(temp_df, JDay %in% c(beg_bloom : end_bloom)) frost_hours &lt;- max(dormancyR::frost_risk(temp_df$Temp, threshold = 0)) } else frost_hours &lt;- 0 future_frost[future_frost$SSP_Time == scenario &amp; future_frost$GCM == climate_model &amp; future_frost$Year == year, &quot;Frost&quot;] &lt;- frost_hours } } # Remove NA cells since the first year has no bloom future_frost &lt;- na.omit(future_frost) We can now plot the results to see the overall picture. We will use the same kind of plot we normally use to show the projections of agro-climatic-related metrics. In brief, we create two plots and combine them using the patchwork package. # Plots past_frost_plot &lt;- ggplot(simulated_frost, aes(Scen_year, Frost, group = Scen_year)) + geom_boxplot(fill = &quot;cadetblue&quot;, outlier.size = 0.8, outlier.alpha = 0.5, outlier.shape = 1) + #geom_point(data = observed_bloom_calibration, aes(as.character(Year), Frost)) + scale_y_continuous(limits = c(0, 90), expand = expansion(mult = 0)) + labs(x = &quot;Year&quot;, y = &quot;Spring frost (hours &lt;0 °C)&quot;) + facet_grid(~ &quot;Historic&quot;) + theme_bw() + theme(axis.text.x = element_text(size = 7, angle = 60, hjust = 1)) future_frost_plot &lt;- ggplot(future_frost, aes(GCM, Frost, fill = GCM)) + geom_boxplot(outlier.size = 0.8, outlier.alpha = 0.5, outlier.shape = 1) + scale_y_continuous(limits = c(0, 90), expand = expansion(mult = 0)) + facet_grid(~ SSP_Time) + theme_bw() + theme(axis.title = element_blank(), axis.text = element_blank(), axis.ticks = element_blank(), legend.position = &quot;bottom&quot;, legend.text = element_text(size = 7.5), legend.key.size = unit(0.3, &quot;cm&quot;)) past_frost_plot + future_frost_plot + plot_layout(widths = c(0.25, 1)) One interesting feature here is the large number of outliers we generated for each simulated scenario. The overall trend suggests there may be a slight decline in the risk of spring frost events for pear cv. Conference under future scenarios although the projections for bloom suggested an advance in the occurrence of the flowering period. 34.3 Exercises for this chapter No exercises for this one. Maybe you still have some work to do on your logbook? "],["major_concepts.html", "Chapter 35 Major concepts Learning goals for this lesson 35.1 Key insights 35.2 Major concepts we’ve encountered Exercises on major concepts", " Chapter 35 Major concepts Learning goals for this lesson Reflect on what we’ve learned in this module Revisit major concepts we’ve encountered along the way 35.1 Key insights 35.1.1 Tree dormancy Most woody perennials that evolved in cold-winter climates fall dormant in winter To resume active growth, they need to fulfill a chill and a heat requirement The chill accumulation period is called endodormancy, the heat accumulation phase ecodormancy Many factors appear to be involved in dormancy release, including intercellular communication, carbohydrate storage and transport, plant hormones and up- and downregulation of genes We don’t currently have full understanding of all this, and there are no convincing process-based models. 35.1.2 Climate change Our planet is warming, and this will change temperature and (probably) precipitation regimes everywhere We don’t know exactly what will happen, but climate scientists have a good enough understanding to make process-based models of the global climate system Global climate models differ, so we should use outputs of multiple models to project future conditions The intensity of future warming will depend on atmospheric greenhouse gas concentrations. Since these can’t be known in advance, we use distinct scenarios - Shared Socioeconomic Pathways (SSPs) at present - to cover the range of possibilities To mitigate climate change, we must cut our greenhouse gas emissions, particularly in the energy sector! 35.1.3 Phenology modeling Phenology modeling is difficult, because there’s still a lot we don’t understand There are a number of chill and heat accumulation models, which (especially the chill models) deliver dramatically different estimates of temperature effects on phenology The frontrunners among models are the Dynamic Model for chill accumulation and the Growing Degree Hour Model for heat accumulation There are some full modeling frameworks that predict future phenology from temperature data, but these have severe shortcomings and typically ignore uncertainties. 35.1.4 Phenology responses to global warming So far, most plant species in most places have responded to increasing temperatures with phenology advances Given what we’ve learned about tree dormancy, this trend may not continue unabated in a progressively warming future Where temperatures are high enough to compromise chill accumulation during endodormancy, phenology advances may be slowed, halted or even reversed This hypothesis makes sense based on first principles, and it appears to be supported by some data, but it needs to be validated further 35.1.5 The PhenoFlex modeling framework The PhenoFlex model combines the best available chill and heat models into a comprehensive framework that allows predicting the timing of spring phases PhenoFlex can be parameterized based on long-term phenology data Parameterization is achieved through use of an empirical fitting algorithm (Simulated Annealing) The model allows characterizing cultivar-specific temperature response functions First results are very promising Among the limitations of PhenoFlex are the difficulty to generalize results across multiple species, and the risk of the fitting procedure returning poor parameter sets 35.2 Major concepts we’ve encountered 35.2.1 Reproducibility and transparency Science should be reproducible and transparent. This is often not fully achievable when we run experiments in the real world, but it is usually possible in modeling studies. We should try to document precisely what we’ve done, and we should make reproducible code available to our colleagues, together with the raw data we used. 35.2.2 Tools We recommended using Github, R and RStudio. Within R, we used a number of add-on packages to improve our workflow. To communicate among the participants within this module, and between instructor and participants, we used Slack. I don’t know if these will be the tools for you later in your career, but I’m sure you’ll benefit from adopting certain tools. Keep looking out for ways to optimize your workflows and become more efficient. 35.2.3 Automate and move on Especially in the kind of research we talked about in this module, but also in many other places in science and business, we keep doing the same tasks over and over again. This is repetitive and boring, and it tends to steal time we could be using for other, more interesting tasks. Learn how to automate repetitive steps, so that you can free up time for creative work. This can also allow you to easily generate similar results from lots of contexts, which might lead to insights that isolated case studies don’t offer. 35.2.4 The power of R I hope this module made you curious about the vast array of methods and tools that R and the associated packages have to offer. Advanced statistics, spatial analysis, animated figures, interactive apps, websites, blogs - all these can be produced with R. This is so much more than just the statistics program it often gets introduced as! And all these functions are free! In my opinion, learning R is one of the most rewarding investments you can make on your path to a scientific career. 35.2.5 Curiosity and interdisciplinarity Spending your whole career in a narrow sub-field of a field may make you an expert in the thing you learned, but it may not put you in a great position to introduce new ideas that may propel your field forward. Of course this can still happen, but there’s lots of evidence that experience outside your field of specialization can provide the necessary inspiration that allows you to make a major contribution. So remain curious and retain the freedom to roam outside your field whenever you find something else interesting. Don’t specialize too strongly too early, or you may miss out on many rewarding experiences! 35.2.6 Uncertainty Uncertainty is an integral part of every real-life issue. All our equations and models are just approximation of what’s really going on out there. We shouldn’t ignore this uncertainty, but try to embrace it, try to quantify it and communicate it whenever we can. This is still quite rarely done in science, constituting a major limitation to the use of most studies for supporting actual real-world decisions. 35.2.6.1 Ensembles Sometimes, as in the case of climate change, uncertainty arises from us not precisely knowing which of a set of scenarios will come true, which analysis method works best, or which of a number of models describes our system most accurately. In such cases, we can consider doing ensemble analyses, i.e. we use all of the options and present the population of results that emerges. This often requires quite a bit of computation, and it isn’t always realistic, but we should try whenever we can (and the ability to automate processes makes this a lot easier). 35.2.6.2 Remaining uncertainties In addition to the type of uncertainty that can be addressed by an ensemble approach, there is a good deal of additional uncertainty that is related to the real world being more complicated than models can ever be. Figuring out these uncertainties isn’t about calculating standard deviations etc. - it is about taking a hard look at the system of interest, recalling everything we’ve learned about the system, and looking for risks and uncertainties we haven’t captured yet. And it is about figuring out how to improve our study to capture as much of this as possible (or reasonable). 35.2.7 p-hacking p-hacking refers to the systematic analysis of lots of variables in large datasets, looking for relationships that happen to be ‘significant’. This process can easily produce significant results by accident, turning up relationships that aren’t meaningful or generally valid. The p-hacking approach is usually devoid of any real systems understanding, but based exclusively on number-crunching. If often involves no serious thoughts about which hypotheses are worth testing, and it is therefore unlikely to lead to real insights into the way the system works. 35.2.8 The dangers of machine learning Machine-learning is particularly prone to p-hacking, because the machine that is doing the learning usually lacks proper training in agriculture, ecology or whatever field it is applied to. It also often involves learning algorithms that model users may not fully understand, so that the ‘learning’ can easily go wrong. There are of course also real machine-learning experts, who know exactly what they’re doing, but I often get the impression that many researchers who use machine-learning techniques simply learned how to use the tools, but are unaware of what can go wrong. 35.2.9 Rationalizing An unfortunate practice in science is the production of statistics based on data, followed by the conjuring up of stories that explain the results. A creative mind can invent narratives to support whatever statistics throw our way. Whether such arguments are actually valid is usually hard to tell. This practice is called rationalizing, as in ‘making something (appear) rational’, when it really isn’t, and we would have been able to produce just as compelling explanations for the opposite results. 35.2.10 Overfitting One thing that can easily go wrong with p-hacking and machine-learning, but also when fitting functions to a dataset, is overfitting. This happens when we use models to describe a process that are much more complex, and have many more degrees of freedom, than the actual process. This allows making models that fit nicely (or even perfectly) to our data, but do not have anything to do with the process we’re trying to study. 35.2.11 The process that generated the data When building models in science, we should not strive to make models that describe our data. We should make models that describe the process that generated the data. This is the biological or ecological process we’re studying, and we should use all our knowledge of that process to generate the model. If the model then fits poorly, we should think about what’s wrong with our understanding, rather than adopting a different type of equation just because it fits better. If we can’t think of an ecological explanation for a model’s functional form, we should drop that model! 35.2.12 The importance of theory All research should be guided by a theory of what’s going on. This is critical for orienting our work and our results in the larger universe of our discipline. Without a theory, statistical analyses are like poking around in the dark without knowing what to look for. With a proper theory, we can formulate hypotheses and expectations, and we can evaluate our results against these. If results are aligned with what we expected to see, we can take them as support of our conceptual understanding. If not, we get valuable food for thought that allows us to refine our hypothesis. This is what the scientific process is all about. The scientific method doesn’t work without a guiding theory. 35.2.13 Conceptual modeling Research should start with a conceptual model that expresses our understanding of the target system and our expectation of what should happen in a particular experiment or situation. This is our representation of the theory that guides our research. It can be expressed in graphical form or in writing, but it should spell out, as explicitly as possible, what we believe going into the experiment, what assumptions we are making, and what we expect the results of our research to be. This concept should then be updated, if necessary, after we’ve concluded our experiments or analyses. 35.2.14 Consistency with existing theory and prior knowledge Each study produces certain results, and researchers have often been tempted to draw sweeping conclusions from the results of isolated studies. Never forget to consider the body of research that has already been compiled when you draw your conclusions. A single study with unusual results cannot easily overturn decades of research that produced different findings. It is still possible, of course, to overturn the established state of knowledge, but this will require strong reasoning and careful consideration of contradictory findings, rather than just one additional datapoint that doesn’t fit the big picture. 35.2.15 Model validity and model validation Whenever we generate a model, we should take steps to validate it. To do this properly, we should be aware of several key concepts. 35.2.15.1 Output vs. process validation Most often when models are validated, we are only presented with the models’ predictions, which are compared to what has been observed in reality. It is certainly important for models to pass this test - models that cannot explain reality at all are not useful. However, in addition to this output validation, we should also undertake process validation whenever we can. This involves producing a conceptual model of our system and then looking at whether the processes we find important are actually implemented in the model. We can of course use what’s in the model to update our own ideas about system processes - we are always allowed to learn from anyone and anything that can teach us something - but we should not give up our idea of what’s important too easily. If we get the impression that a model produces accurate results for the wrong reasons, e.g. despite something really important not being in the model, we should consider rejecting it, even if predictions are closely aligned with observations. 35.2.15.2 Validity domains When using a model for predictions, we need to make ourselves aware first, under what conditions we can expect predictions to be valid. Most often, this will be directly determined by the conditions that were used to produce the model. If a model is developed in a certain range of climate conditions, we should be very hesitant when using it in a different climate. The same applies to strong differences in socioeconomic or cultural settings between training and application conditions. To appreciate the range of conditions the model can be applied in, we should attempt to map the model’s validity domain. It may often be unrealistic to expect a model to have been calibrated under exactly the right conditions. In such situations, we shouldn’t be too hard on modelers who slightly stretch the validity domain. But we should always ask ourselves whether we’ve stretched it too far, and whether we can still trust our predictions. And we may sometimes have to reject the use of models in particular circumstances (even though others may have used them in such a context before). 35.2.15.3 Validation for purpose In validating models, we need to keep in mind the context of the prediction we’re hoping to make, and we should try to validate the model in a situation that resembles that context. E.g. if we aim to make climate change impact assessments, we shouldn’t just test our model based on data from the past, but try to find a validation dataset that was collected under warmer conditions. If we want to predict yield of the next year, we should validate our model by predicting yields for years that we have no other data for. In general, we should choose our validation dataset in such a way that it truly resembles the prediction challenge we’re planning to take on. 35.2.16 Our role in research The concepts of theories, hypotheses, predictions etc. are core ingredients of science. They are the basis of the scientific method. Yet many researchers believe that our prior knowledge, beliefs and expectations shouldn’t be allowed to interfere with the scientific process. Scientists, they may say, are supposed to be strictly objective, rather than using their subjective judgment. This is a major debate in science that has been going on for centuries. Personally, I am convinced that injecting science with a researcher’s subjective knowledge, a.k.a. expertise or professional judgment, usually makes science better, not worse. This should at least be the case where scientists remain critical of their own knowledge, strive to make all their assumptions explicit and continually question what they firmly believe to be true. Developing a mindset that allows us to consistently apply such behavior may be a more important step to becoming a mature researcher than staying abreast with all the fancy analysis methods our field has to offer. Exercises on major concepts None… you’re done! If you’re a student entitled to getting credit for this course, let me have your learning logbook. Thanks for staying with the program to the very end! "],["refs.html", "References", " References Almorox J, Hontoria C &amp; Benito M. (2005). Statistical validation of daylength definitions for estimation of global solar radiation in toledo, spain. Energy Conversion and Management, 46(9-10), 1465–1471. Baldocchi D &amp; Wong S. (2008). Accumulated winter chill is decreasing in the fruit growing regions of california. Climatic Change, 87(1), 153–166. doi: 10.1007/s10584-007-9367-8 Benmoussa H, Ghrab M, Mimoun MB &amp; Luedeling E. (2017a). Chilling and heat requirements for local and foreign almond (prunus dulcis mill.) cultivars in a warm mediterranean location based on 30 years of phenology records. Agricultural and Forest Meteorology, 239, 34–46. doi: 10.1016/j.agrformet.2017.02.030 Benmoussa H, Luedeling E, Ghrab M, Ben Yahmed J &amp; Ben Mimoun M. (2017b). Performance of pistachio (Pistacia vera L.) in warming Mediterranean orchards. Environmental and Experimental Botany, 140, 76–85. doi: 10.1016/j.envexpbot.2017.05.007 Benmoussa H, Luedeling E, Ghrab M &amp; Mimoun MB. (2020). Severe winter chill decline impacts tunisian fruit and nut orchards. Climatic Change, 162, 1249–1267. doi: 10.1007/s10584-020-02774-7 Benmoussa H, Mimoun MB, Ghrab M &amp; Luedeling E. (2018). Climate change threatens central tunisian nut orchards. International Journal of Biometeorology, 62(12), 2245–2255. doi: 10.1007/s00484-018-1628-x Buerkert A, Fernandez E, Tietjen B &amp; Luedeling E. (2020). Revisiting climate change effects on winter chill in mountain oases of northern oman. Climatic Change, 162, 1399–1417. doi: 10.1007/s10584-020-02862-8 Crossa-Raynaud P. (1955). Effets des hivers doux sur le comportement des arbres fruitiers à feuilles caduques: Observations faites en tunisie à la suite de l’hiver 1954-1955. Impr. La Rapide. del Barrio R, Fernandez E, Brendel AS, Whitney C, Campoy JA &amp; Luedeling E. (2020). Climate change impacts on agriculture’s southern frontier–perspectives for farming in north patagonia. International Journal of Climatology, 41(1), 726–742. doi: doi.org/10.1002/joc.6649 Erez A &amp; Fishman S. (1997). Dynamic model chilling portions (excel worksheet). Retrieved from http://ucanr.edu/sites/fruittree/files/49319.xls Fadón E, Fernandez E, Behn H &amp; Luedeling E. (2020). A conceptual framework for winter dormancy in deciduous trees. Agronomy, 10(2), 241. doi: 10.3390/agronomy10020241 Fernandez E, Krefting P, Kunz A, Do H, Fadón E &amp; Luedeling E. (2021). Boosting statistical delineation of chill and heat periods in temperate fruit trees through multi-environment observations. Agricultural and Forest Meteorology, 310, 108652. doi: 10.1016/j.agrformet.2021.108652 Fernandez E, Schiffers K, Urbach C &amp; Luedeling E. (2022). Unusually warm winter seasons may compromise the performance of current phenology models – predicting bloom dates in young apple trees with PhenoFlex. Agricultural and Forest Meteorology, 322, 109020. doi: 10.1016/j.agrformet.2022.109020 Fernandez E, Whitney C, Cuneo IF &amp; Luedeling E. (2020a). Prospects of decreasing winter chill for deciduous fruit production in chile throughout the 21st century. Climatic Change, 423–439. doi: 10.1007/s10584-019-02608-1 Fernandez E, Whitney C &amp; Luedeling E. (2020b). The importance of chill model selection—a multi-site analysis. European Journal of Agronomy, 119, 126103. doi: 10.1016/j.eja.2020.126103 Guo L, Dai J, Ranjitkar S, Xu J &amp; Luedeling E. (2013). Response of chestnut phenology in china to climate variation and change. Agricultural and Forest Meteorology, 180, 164–172. doi: 10.1016/j.agrformet.2013.06.004 Guo L, Dai J, Ranjitkar S, Yu H, Xu J &amp; Luedeling E. (2014a). Chilling and heat requirements for flowering in temperate fruit trees. International Journal of Biometeorology, 58(6), 1195–1206. doi: 10.1007/s00484-013-0714-3 Guo L, Dai J, Wang M, Xu J &amp; Luedeling E. (2015a). Responses of spring phenology in temperate zone trees to climate warming: A case study of apricot flowering in china. Agricultural and Forest Meteorology, 201, 1–7. doi: 10.1016/j.agrformet.2014.10.016 Guo L, Luedeling E, Dai J-H &amp; Xu J-C. (2014b). Differences in heat requirements of flower and leaf buds make hysteranthous trees bloom before leaf unfolding. Plant Diversity and Resources, 36(2), 245–253. doi: 10.7677/ynzwyj201413081 Guo L, Wang J, Li M, Liu L, Xu J, Cheng J, Gang C, Yu Q, Chen J, Peng C &amp; Luedeling E. (2019). Distribution margins as natural laboratories to infer species’ flowering responses to climate warming and implications for frost risk. Agricultural and Forest Meteorology, 268, 299–307. doi: 10.1016/j.agrformet.2019.01.038 Guo L, Xu J, Dai J, Cheng J &amp; Luedeling E. (2015b). Statistical identification of chilling and heat requirements for apricot flower buds in beijing, china. Scientia Horticulturae, 195, 138–144. doi: 10.1016/j.scienta.2015.09.006 Linvill DE. (1990). Calculating chilling hours and chill units from daily maximum and minimum temperature observations. HortScience, 25(1), 14–16. doi: 10.21273/HORTSCI.25.1.14 Luedeling E. (2018). Interpolating hourly temperatures for computing agroclimatic metrics. International Journal of Biometeorology, 62(10), 1799–1807. doi: 10.1007/s00484-018-1582-7 Luedeling E. (2020). The challenge of warming winters – do we understand tree dormancy enough to prepare deciduous orchards in warm places? Acta Horticulturae, 1281, 441–447. doi: 10.17660/ActaHortic.2020.1281.58 Luedeling E, Blanke M &amp; Gebauer J. (2009a). Auswirkungen des Klimawandels auf die Verfügbarkeit von Kältewirkung (Chilling) für Obstgehölze in Deutschland. Erwerbs-Obstbau, 51(3), 81–94. doi: 10.1007/s10341-009-0085-4 Luedeling E &amp; Brown PH. (2011a). A global analysis of the comparability of winter chill models for fruit and nut trees. International Journal of Biometeorology, 55(3), 411–421. doi: 10.1007/s00484-010-0352-y Luedeling E &amp; Gassner A. (2012). Partial least squares regression for analyzing walnut phenology in california. Agricultural and Forest Meteorology, 158, 43–52. doi: 10.1016/j.agrformet.2011.10.020 Luedeling E, Gebauer J &amp; Buerkert A. (2009b). Climate change effects on winter chill for tree crops with chilling requirements on the Arabian Peninsula. Climatic Change, 96(1-2), 219–237. doi: 10.1007/s10584-009-9581-7 Luedeling E, Girvetz EH, Semenov MA &amp; Brown PH. (2011b). Climate change affects winter chill for temperate fruit and nut trees. PloS One, 6(5), e20155. Retrieved from https://journals.plos.org/plosone/article?id=10.1371/journal.pone.0020155 Luedeling E, Guo L, Dai J, Leslie C &amp; Blanke MM. (2013a). Differential responses of trees to temperature variation during the chilling and forcing phases. Agricultural and Forest Meteorology, 181, 33–42. doi: 10.1016/j.agrformet.2013.06.018 Luedeling E, Hale A, Zhang M, Bentley WJ &amp; Dharmasri LC. (2009c). Remote sensing of spider mite damage in california peach orchards. International Journal of Applied Earth Observation and Geoinformation, 11(4), 244–255. doi: 10.1016/j.jag.2009.03.002 Luedeling E, Kunz A &amp; Blanke MM. (2013b). Identification of chilling and heat requirements of cherry trees—a statistical approach. International Journal of Biometeorology, 57(5), 679–689. doi: 10.1007/s00484-012-0594-y Luedeling E, Schiffers K, Fohrmann T &amp; Urbach C. (2021). Pheno-flex - an integrated model to predict spring phenology in temperate fruit trees. Agricultural and Forest Meteorology, 307, 108491. doi: 10.1016/j.agrformet.2021.108491 Luedeling E, Zhang M &amp; Girvetz EH. (2009d). Climatic Changes Lead to Declining Winter Chill for Fruit and Nut Trees in California during 1950–2099. PLoS ONE, 4(7), e6166. doi: 10.1371/journal.pone.0006166 Luedeling E, Zhang M, Luedeling V &amp; Girvetz EH. (2009e). Sensitivity of winter chill models for fruit and nut trees to climatic changes expected in California’s Central Valley. Agriculture, Ecosystems &amp; Environment, 133(1-2), 23–31. doi: 10.1016/j.agee.2009.04.016 Luedeling E, Zhang M, McGranahan G &amp; Leslie C. (2009f). Validation of winter chill models using historic records of walnut phenology. Agricultural and Forest Meteorology, 149(11), 1854–1864. doi: 10.1016/j.agrformet.2009.06.013 Martı́nez-Lüscher J, Hadley P, Ordidge M, Xu X &amp; Luedeling E. (2017). Delayed chilling appears to counteract flowering advances of apricot in southern UK. Agricultural and Forest Meteorology, 237, 209–218. Martı́nez-Lüscher J, Kizildeniz T, Vučetić V, Dai Z, Luedeling E, Leeuwen C van, Gomès E, Pascual I, Irigoyen JJ, Morales F, et al. (2016). Sensitivity of grapevine phenology to water availability, temperature and CO\\(_2\\) concentration. Frontiers in Environmental Science, 4, 48. doi: 10.3389/fenvs.2016.00048 Nuzzo R. (2014). Scientific method: Statistical errors. Nature News, 506(7487), 150. doi: 10.1038/506150a Parmesan C &amp; Yohe G. (2003). A globally coherent fingerprint of climate change impacts across natural systems. Nature, 421(6918), 37–42. doi: https://www.nature.com/articles/nature01286 Platts PJ, Omeny P &amp; Marchant R. (2015). AFRICLIM: High-resolution climate projections for ecological applications in africa. African Journal of Ecology, 103–108. doi: 10.1111/aje.12180 Pope K, Da Silva D, Brown P &amp; DeJong T. (2014). A biologically based approach to modeling spring phenology in temperate deciduous trees. Agricultural and Forest Meteorology, 198, 15–23. doi: 10.1016/j.agrformet.2014.07.009 Richardson E, Seeley S &amp; Walker D. (1974). A model for estimating the completion of rest for \"redhaven\" and \"elberta\" peach trees. HortScience, 9(4), 331–332. Spencer J. (1971). Fourier series reprensentation of the position of the sun. Search, 2(5), 172. Yu H, Luedeling E &amp; Xu J. (2010). Winter and spring warming result in delayed spring phenology on the tibetan plateau. Proceedings of the National Academy of Sciences, 107(51), 22151–22156. doi: 10.1073/pnas.1012490107 Yu H, Xu J, Okuto E &amp; Luedeling E. (2012). Seasonal response of grasslands to climate change on the tibetan plateau. PLoS One, 7(11), e49230. doi: 10.1371/journal.pone.0049230 "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
